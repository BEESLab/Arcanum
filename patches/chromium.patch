diff --git a/chrome/browser/chrome_content_browser_client.cc b/chrome/browser/chrome_content_browser_client.cc
index 96b42e4e7ffe3..dea4495800890 100644
--- a/chrome/browser/chrome_content_browser_client.cc
+++ b/chrome/browser/chrome_content_browser_client.cc
@@ -2660,6 +2660,8 @@ void ChromeContentBrowserClient::AppendExtraCommandLineSwitches(
 #if BUILDFLAG(ENABLE_EXTENSIONS)
       extensions::switches::kAllowHTTPBackgroundPage,
       extensions::switches::kAllowLegacyExtensionManifests,
+      extensions::switches::kCustcomScriptIdleTimeoutInMs,
+      extensions::switches::kCustcomDelayForAnimationInMs,
       extensions::switches::kDisableExtensionsHttpThrottling,
       extensions::switches::kEnableExperimentalExtensionApis,
       extensions::switches::kExtensionsOnChromeURLs,
diff --git a/chrome/browser/extensions/api/history/history_api.cc b/chrome/browser/extensions/api/history/history_api.cc
index d43d358d339fa..7066c871bb722 100644
--- a/chrome/browser/extensions/api/history/history_api.cc
+++ b/chrome/browser/extensions/api/history/history_api.cc
@@ -74,10 +74,11 @@ HistoryItem GetHistoryItem(const history::URLRow& row) {
 
   return history_item;
 }
-
-VisitItem GetVisitItem(const history::VisitRow& row) {
+//VisitItem GetVisitItem(const history::VisitRow& row) {
+VisitItem GetVisitItem(const history::VisitRow& row, GURL url) { // xqg
   VisitItem visit_item;
 
+  visit_item.url = url.spec(); // xqg
   visit_item.id = base::NumberToString(row.url_id);
   visit_item.visit_id = base::NumberToString(row.visit_id);
   visit_item.visit_time = MilliSecondsFromTime(row.visit_time);
@@ -275,7 +276,8 @@ void HistoryGetVisitsFunction::QueryComplete(history::QueryURLResult result) {
   VisitItemList visit_item_vec;
   if (result.success && !result.visits.empty()) {
     for (const history::VisitRow& visit : result.visits)
-      visit_item_vec.push_back(GetVisitItem(visit));
+//      visit_item_vec.push_back(GetVisitItem(visit));
+        visit_item_vec.push_back(GetVisitItem(visit, result.url));
   }
 
   Respond(ArgumentList(GetVisits::Results::Create(visit_item_vec)));
diff --git a/chrome/browser/extensions/api/scripting/scripting_api.cc b/chrome/browser/extensions/api/scripting/scripting_api.cc
index 8dc1f067ea8f7..8f2687b66a55e 100644
--- a/chrome/browser/extensions/api/scripting/scripting_api.cc
+++ b/chrome/browser/extensions/api/scripting/scripting_api.cc
@@ -607,6 +607,9 @@ ExtensionFunction::ResponseAction ScriptingExecuteScriptFunction::Run() {
 
   DCHECK(injection_.func);
 
+  if (injection_.is_tainted){
+      DVLOG(0) << "has is_tainted,"<<injection_.is_tainted->c_str()<<"\n";
+  }
   // TODO(devlin): This (wrapping a function to create an IIFE) is pretty hacky,
   // and along with the JSON-serialization of the arguments to curry in.
   // Add support to the ScriptExecutor to better support this case.
@@ -623,14 +626,22 @@ ExtensionFunction::ResponseAction ScriptingExecuteScriptFunction::Run() {
     args_expression = base::JoinString(string_args, ",");
   }
 
-  std::string code_to_execute = base::StringPrintf(
-      "(%s)(%s)", injection_.func->c_str(), args_expression.c_str());
-
+  std::string code_to_execute;
+  bool is_tainted = false;
+  if (injection_.is_tainted) {
+      is_tainted = true;
+      code_to_execute = base::StringPrintf(
+              "(%s)(%s,%s,%s)", injection_.func->c_str(), args_expression.c_str(), "TAINTED","SCRIPTING.EXECUTESCRIPT");
+  } else {
+      code_to_execute = base::StringPrintf(
+              "(%s)(%s,%s)", injection_.func->c_str(), args_expression.c_str(),"SCRIPTING.EXECUTESCRIPT");
+  }
+  DVLOG(0) << "code_to_execute="<<code_to_execute<<"\n";
   std::vector<mojom::JSSourcePtr> sources;
   sources.push_back(mojom::JSSource::New(std::move(code_to_execute), GURL()));
 
-  std::string error;
-  if (!Execute(std::move(sources), &error))
+  std::string error; // working...
+  if (!Execute(std::move(sources), &error, is_tainted))
     return RespondNow(Error(std::move(error)));
 
   return RespondLater();
@@ -655,7 +666,7 @@ void ScriptingExecuteScriptFunction::DidLoadResources(
 
 bool ScriptingExecuteScriptFunction::Execute(
     std::vector<mojom::JSSourcePtr> sources,
-    std::string* error) {
+    std::string* error, bool is_tainted) { // xqg
   ScriptExecutor* script_executor = nullptr;
   ScriptExecutor::FrameScope frame_scope = ScriptExecutor::SPECIFIED_FRAMES;
   std::set<int> frame_ids;
@@ -689,7 +700,7 @@ bool ScriptingExecuteScriptFunction::Execute(
       frame_scope, frame_ids, ScriptExecutor::MATCH_ABOUT_BLANK, run_location,
       ScriptExecutor::DEFAULT_PROCESS,
       /* webview_src */ GURL(),
-      base::BindOnce(&ScriptingExecuteScriptFunction::OnScriptExecuted, this));
+      base::BindOnce(&ScriptingExecuteScriptFunction::OnScriptExecuted, this), is_tainted);
 
   return true;
 }
@@ -713,6 +724,7 @@ void ScriptingExecuteScriptFunction::OnScriptExecuted(
     api::scripting::InjectionResult injection_result;
     injection_result.result = std::move(result.value);
     injection_result.frame_id = result.frame_id;
+    injection_result.is_tainted = result.is_tainted; // xqg
     if (result.document_id)
       injection_result.document_id = result.document_id.ToString();
 
diff --git a/chrome/browser/extensions/api/scripting/scripting_api.h b/chrome/browser/extensions/api/scripting/scripting_api.h
index 811da641457cd..4f4d3dd4fdfe5 100644
--- a/chrome/browser/extensions/api/scripting/scripting_api.h
+++ b/chrome/browser/extensions/api/scripting/scripting_api.h
@@ -52,7 +52,7 @@ class ScriptingExecuteScriptFunction : public ExtensionFunction {
 
   // Triggers the execution of `sources` in the appropriate context.
   // Returns true on success; on failure, populates `error`.
-  bool Execute(std::vector<mojom::JSSourcePtr> sources, std::string* error);
+  bool Execute(std::vector<mojom::JSSourcePtr> sources, std::string* error, bool is_tainted = false); //xqg
 
   // Invoked when script execution is complete.
   void OnScriptExecuted(std::vector<ScriptExecutor::FrameResult> frame_results);
diff --git a/chrome/common/extensions/api/history.json b/chrome/common/extensions/api/history.json
index 55bfd25785918..0b428b9abd4f9 100644
--- a/chrome/common/extensions/api/history.json
+++ b/chrome/common/extensions/api/history.json
@@ -38,7 +38,8 @@
           "transition": {
             "$ref": "TransitionType",
             "description": "The <a href='#transition_types'>transition type</a> for this visit from its referrer."
-          }
+          },
+          "url": {"type": "string", "optional": true, "description": "xqg, added."}
         }
       },
       {
diff --git a/chrome/common/extensions/api/scripting.idl b/chrome/common/extensions/api/scripting.idl
index ee10dc49d6d0f..e881c06ef8fff 100644
--- a/chrome/common/extensions/api/scripting.idl
+++ b/chrome/common/extensions/api/scripting.idl
@@ -80,6 +80,9 @@ namespace scripting {
     // prior to page load, as the page may have already loaded by the time the
     // script reaches the target.
     boolean? injectImmediately;
+
+    // xqg
+    DOMString? is_tainted;
   };
 
   dictionary CSSInjection {
@@ -110,6 +113,9 @@ namespace scripting {
 
     // The document associated with the injection.
     DOMString documentId;
+
+    // xqg
+    boolean? is_tainted;
   };
 
   // Describes a content script to be injected into a web page registered
diff --git a/chrome/renderer/extensions/extension_hooks_delegate.cc b/chrome/renderer/extensions/extension_hooks_delegate.cc
index a70a01ebe8563..35519d8f48207 100644
--- a/chrome/renderer/extensions/extension_hooks_delegate.cc
+++ b/chrome/renderer/extensions/extension_hooks_delegate.cc
@@ -230,9 +230,28 @@ RequestResult ExtensionHooksDelegate::HandleSendRequest(
 
   v8::Local<v8::Value> v8_message = arguments[1];
 
-  std::unique_ptr<Message> message = messaging_util::MessageFromV8(
-      script_context->v8_context(), v8_message,
-      messaging_util::GetSerializationFormat(*script_context), &error);
+  // xqg start
+
+  bool tainted = false;
+  v8::Local<v8::Value> report;
+  if (!v8_message.IsEmpty() && !v8_message->IsUndefined()){
+        tainted = v8_message->ContainsTaintedValue(script_context->v8_context(), script_context->isolate());
+        if (tainted) {
+            report = v8_message->GetAllPropagationPaths(script_context->isolate());
+        }
+  }
+  std::unique_ptr <Message> message;
+  if (tainted) {
+      message = messaging_util::MessageFromV8(
+              script_context->v8_context(), v8_message,
+              messaging_util::GetSerializationFormat(*script_context), &error, true, gin::V8ToString(script_context->isolate(), report));
+  }
+  else {
+      message = messaging_util::MessageFromV8(
+              script_context->v8_context(), v8_message,
+              messaging_util::GetSerializationFormat(*script_context), &error, false, std::string());
+  }
+  // xqg end
   if (!message) {
     RequestResult result(RequestResult::INVALID_INVOCATION);
     result.error = std::move(error);
diff --git a/chrome/renderer/extensions/tabs_hooks_delegate.cc b/chrome/renderer/extensions/tabs_hooks_delegate.cc
index 9a06beacf40f9..14a8cf61ba6df 100644
--- a/chrome/renderer/extensions/tabs_hooks_delegate.cc
+++ b/chrome/renderer/extensions/tabs_hooks_delegate.cc
@@ -89,9 +89,27 @@ RequestResult TabsHooksDelegate::HandleSendRequest(
   v8::Local<v8::Value> v8_message = arguments[1];
   std::string error;
 
-  std::unique_ptr<Message> message = messaging_util::MessageFromV8(
-      script_context->v8_context(), v8_message,
-      messaging_util::GetSerializationFormat(*script_context), &error);
+  // xqg start
+  bool tainted = false;
+  v8::Local<v8::Value> report;
+  if (!v8_message.IsEmpty() && !v8_message->IsUndefined()){
+        tainted = v8_message->ContainsTaintedValue(script_context->v8_context(), script_context->isolate());
+        if (tainted) {
+            report = v8_message->GetAllPropagationPaths(script_context->isolate());
+        }
+  }
+
+  std::unique_ptr<Message> message;
+  if (tainted) {
+      message = messaging_util::MessageFromV8(
+              script_context->v8_context(), v8_message,
+              messaging_util::GetSerializationFormat(*script_context), &error, true, gin::V8ToString(script_context->isolate(), report));
+  } else {
+      message = messaging_util::MessageFromV8(
+              script_context->v8_context(), v8_message,
+              messaging_util::GetSerializationFormat(*script_context), &error, false, std::string());
+  }
+  // xqg end
   if (!message) {
     RequestResult result(RequestResult::INVALID_INVOCATION);
     result.error = std::move(error);
@@ -127,10 +145,27 @@ RequestResult TabsHooksDelegate::HandleSendMessage(
   v8::Local<v8::Value> v8_message = arguments[1];
   DCHECK(!v8_message.IsEmpty());
   std::string error;
-
-  std::unique_ptr<Message> message = messaging_util::MessageFromV8(
-      script_context->v8_context(), v8_message,
-      messaging_util::GetSerializationFormat(*script_context), &error);
+  // xqg start
+  bool tainted = false;
+  v8::Local<v8::Value> report;
+  if (!v8_message.IsEmpty() && !v8_message->IsUndefined()){
+        tainted = v8_message->ContainsTaintedValue(script_context->v8_context(), script_context->isolate());
+        if (tainted) {
+            report = v8_message->GetAllPropagationPaths(script_context->isolate());
+        }
+  }
+  std::unique_ptr<Message> message;
+  if (tainted) {
+      message = messaging_util::MessageFromV8(
+              script_context->v8_context(), v8_message,
+              messaging_util::GetSerializationFormat(*script_context), &error, true, gin::V8ToString(script_context->isolate(), report));
+  }
+  else {
+      message = messaging_util::MessageFromV8(
+              script_context->v8_context(), v8_message,
+              messaging_util::GetSerializationFormat(*script_context), &error, false, std::string());
+  }
+  // xqg end
   if (!message) {
     RequestResult result(RequestResult::INVALID_INVOCATION);
     result.error = std::move(error);
diff --git a/components/history/core/browser/history_backend.cc b/components/history/core/browser/history_backend.cc
index f05f1432aa5d7..5548ac9179891 100644
--- a/components/history/core/browser/history_backend.cc
+++ b/components/history/core/browser/history_backend.cc
@@ -857,8 +857,13 @@ void HistoryBackend::AddPage(const HistoryAddPageArgs& request) {
       // case we don't need to reconnect the new redirect with the existing
       // chain.
       if (request.referrer.is_valid()) {
-        DCHECK_EQ(request.referrer, redirects[0]);
-        redirects.erase(redirects.begin());
+        // xqg start
+        if (request.referrer == redirects[0]){
+            redirects.erase(redirects.begin());
+        }
+        // xqg end
+//        DCHECK_EQ(request.referrer, redirects[0]);
+//        redirects.erase(redirects.begin());
 
         // If the navigation entry for this visit has replaced that for the
         // first visit, remove the CHAIN_END marker from the first visit. This
@@ -1599,6 +1604,7 @@ bool HistoryBackend::GetLastVisitByTime(base::Time visit_time,
 QueryURLResult HistoryBackend::QueryURL(const GURL& url, bool want_visits) {
   QueryURLResult result;
   result.success = db_ && db_->GetRowForURL(url, &result.row);
+  result.url = url; // xqg
   // Optionally query the visits.
   if (result.success && want_visits)
     db_->GetVisitsForURL(result.row.id(), &result.visits);
diff --git a/components/history/core/browser/history_types.h b/components/history/core/browser/history_types.h
index 480b44c70b6b6..8ed82ed6cc8cb 100644
--- a/components/history/core/browser/history_types.h
+++ b/components/history/core/browser/history_types.h
@@ -346,6 +346,8 @@ struct QueryURLResult {
   bool success = false;
   URLRow row;
   VisitVector visits;
+  // xqg
+  GURL url;
 };
 
 // VisibleVisitCountToHostResult ----------------------------------------------
diff --git a/components/update_client/update_engine.cc b/components/update_client/update_engine.cc
index 786aff7d37f10..aa5afeb873cdd 100644
--- a/components/update_client/update_engine.cc
+++ b/components/update_client/update_engine.cc
@@ -123,12 +123,17 @@ base::RepeatingClosure UpdateEngine::Update(
     const auto crx_component = crx_components[i];
     if (crx_component) {
       // This component can be checked for updates.
-      DCHECK_EQ(id, GetCrxComponentID(*crx_component));
-      auto& component = update_context->components[id];
-      component->set_crx_component(*crx_component);
-      component->set_previous_version(component->crx_component()->version);
-      component->set_previous_fp(component->crx_component()->fingerprint);
-      update_context->components_to_check_for_updates.push_back(id);
+      // xqg start
+      // DCHECK_EQ(id, GetCrxComponentID(*crx_component));
+      if (id == GetCrxComponentID(*crx_component)) {
+          DCHECK_EQ(id, GetCrxComponentID(*crx_component));
+          auto &component = update_context->components[id];
+          component->set_crx_component(*crx_component);
+          component->set_previous_version(component->crx_component()->version);
+          component->set_previous_fp(component->crx_component()->fingerprint);
+          update_context->components_to_check_for_updates.push_back(id);
+      }
+      // xqg end
     } else {
       // |CrxDataCallback| did not return a CrxComponent instance for this
       // component, which most likely, has been uninstalled. This component
diff --git a/components/webcrypto/webcrypto_impl.cc b/components/webcrypto/webcrypto_impl.cc
index 0bb2eae85572f..d7cb01fdecc78 100644
--- a/components/webcrypto/webcrypto_impl.cc
+++ b/components/webcrypto/webcrypto_impl.cc
@@ -113,7 +113,7 @@ void CompleteWithError(const Status& status, blink::WebCryptoResult* result) {
 
 void CompleteWithBufferOrError(const Status& status,
                                const std::vector<uint8_t>& buffer,
-                               blink::WebCryptoResult* result) {
+                               blink::WebCryptoResult* result, bool is_tainted = false) {
   if (status.IsError()) {
     CompleteWithError(status, result);
   } else {
@@ -122,8 +122,13 @@ void CompleteWithBufferOrError(const Status& status,
       // theoretically this could overflow.
       CompleteWithError(Status::ErrorUnexpected(), result);
     } else {
+//      result->CompleteWithBuffer(buffer.data(),
+//                                 static_cast<unsigned int>(buffer.size()));
+
+      // xqg start
       result->CompleteWithBuffer(buffer.data(),
-                                 static_cast<unsigned int>(buffer.size()));
+                                   static_cast<unsigned int>(buffer.size()), is_tainted);
+      // xqg end
     }
   }
 }
@@ -182,13 +187,28 @@ struct EncryptState : public BaseState {
       : BaseState(result, std::move(task_runner)),
         algorithm(algorithm),
         key(key),
-        data(std::move(data)) {}
+        data(std::move(data)),
+        is_tainted(false) {}
+
+  // xqg start
+  EncryptState(const blink::WebCryptoAlgorithm& algorithm,
+                 const blink::WebCryptoKey& key,
+                 blink::WebVector<unsigned char> data,
+                 const blink::WebCryptoResult& result,
+                 scoped_refptr<base::SingleThreadTaskRunner> task_runner, bool tainted)
+            : BaseState(result, std::move(task_runner)),
+              algorithm(algorithm),
+              key(key),
+              data(std::move(data)),
+              is_tainted(tainted) {}
+  // xqg end
 
   const blink::WebCryptoAlgorithm algorithm;
   const blink::WebCryptoKey key;
   const blink::WebVector<unsigned char> data;
 
   std::vector<uint8_t> buffer;
+  bool is_tainted; // xqg
 };
 
 typedef EncryptState DecryptState;
@@ -379,7 +399,7 @@ struct DeriveKeyState : public BaseState {
 void DoEncryptReply(std::unique_ptr<EncryptState> state) {
   TRACE_EVENT0(TRACE_DISABLED_BY_DEFAULT("devtools.timeline"),
                "DoEncryptReply");
-  CompleteWithBufferOrError(state->status, state->buffer, &state->result);
+  CompleteWithBufferOrError(state->status, state->buffer, &state->result, state->is_tainted); // xqg
 }
 
 void DoEncrypt(std::unique_ptr<EncryptState> passed_state) {
@@ -396,7 +416,7 @@ void DoEncrypt(std::unique_ptr<EncryptState> passed_state) {
 void DoDecryptReply(std::unique_ptr<DecryptState> state) {
   TRACE_EVENT0(TRACE_DISABLED_BY_DEFAULT("devtools.timeline"),
                "DoDecryptReply");
-  CompleteWithBufferOrError(state->status, state->buffer, &state->result);
+  CompleteWithBufferOrError(state->status, state->buffer, &state->result, state->is_tainted);
 }
 
 void DoDecrypt(std::unique_ptr<DecryptState> passed_state) {
@@ -405,7 +425,7 @@ void DoDecrypt(std::unique_ptr<DecryptState> passed_state) {
   if (state->cancelled())
     return;
   state->status = webcrypto::Decrypt(state->algorithm, state->key, state->data,
-                                     &state->buffer);
+                                     &state->buffer); // xqg
   state->origin_thread->PostTask(
       FROM_HERE, base::BindOnce(DoDecryptReply, std::move(passed_state)));
 }
@@ -629,13 +649,13 @@ void WebCryptoImpl::Encrypt(
     const blink::WebCryptoKey& key,
     blink::WebVector<unsigned char> data,
     blink::WebCryptoResult result,
-    scoped_refptr<base::SingleThreadTaskRunner> task_runner) {
+    scoped_refptr<base::SingleThreadTaskRunner> task_runner, bool is_tainted) { // xqg
   DCHECK(!algorithm.IsNull());
   if (result.Cancelled())
     return;
 
   std::unique_ptr<EncryptState> state(new EncryptState(
-      algorithm, key, std::move(data), result, std::move(task_runner)));
+      algorithm, key, std::move(data), result, std::move(task_runner), is_tainted)); // xqg
   if (!CryptoThreadPool::PostTask(
           FROM_HERE, base::BindOnce(DoEncrypt, std::move(state)))) {
     CompleteWithThreadPoolError(&result);
@@ -647,13 +667,13 @@ void WebCryptoImpl::Decrypt(
     const blink::WebCryptoKey& key,
     blink::WebVector<unsigned char> data,
     blink::WebCryptoResult result,
-    scoped_refptr<base::SingleThreadTaskRunner> task_runner) {
+    scoped_refptr<base::SingleThreadTaskRunner> task_runner,  bool is_tainted) { // xqg
   DCHECK(!algorithm.IsNull());
   if (result.Cancelled())
     return;
 
   std::unique_ptr<DecryptState> state(new DecryptState(
-      algorithm, key, std::move(data), result, std::move(task_runner)));
+      algorithm, key, std::move(data), result, std::move(task_runner), is_tainted));
   if (!CryptoThreadPool::PostTask(
           FROM_HERE, base::BindOnce(DoDecrypt, std::move(state)))) {
     CompleteWithThreadPoolError(&result);
diff --git a/components/webcrypto/webcrypto_impl.h b/components/webcrypto/webcrypto_impl.h
index 48c8ffb327227..f29bd4dbe6254 100644
--- a/components/webcrypto/webcrypto_impl.h
+++ b/components/webcrypto/webcrypto_impl.h
@@ -33,13 +33,13 @@ class WebCryptoImpl : public blink::WebCrypto {
       const blink::WebCryptoKey& key,
       blink::WebVector<unsigned char> data,
       blink::WebCryptoResult result,
-      scoped_refptr<base::SingleThreadTaskRunner> task_runner) override;
+      scoped_refptr<base::SingleThreadTaskRunner> task_runner, bool is_tainted = false) override; // xqg
   void Decrypt(
       const blink::WebCryptoAlgorithm& algorithm,
       const blink::WebCryptoKey& key,
       blink::WebVector<unsigned char> data,
       blink::WebCryptoResult result,
-      scoped_refptr<base::SingleThreadTaskRunner> task_runner) override;
+      scoped_refptr<base::SingleThreadTaskRunner> task_runner, bool is_tainted = false) override; // xqg
   void Digest(const blink::WebCryptoAlgorithm& algorithm,
               blink::WebVector<unsigned char> data,
               blink::WebCryptoResult result,
diff --git a/extensions/browser/script_executor.cc b/extensions/browser/script_executor.cc
index 0c783e646bcb5..35304184096e4 100644
--- a/extensions/browser/script_executor.cc
+++ b/extensions/browser/script_executor.cc
@@ -56,7 +56,7 @@ class Handler : public content::WebContentsObserver {
           mojom::ExecuteCodeParamsPtr params,
           ScriptExecutor::FrameScope scope,
           const std::set<int>& frame_ids,
-          ScriptExecutor::ScriptFinishedCallback callback)
+          ScriptExecutor::ScriptFinishedCallback callback, bool is_tainted = false)
       : content::WebContentsObserver(web_contents),
         observer_(std::move(observer)),
         host_id_(params->host_id->type, params->host_id->id),
@@ -96,7 +96,7 @@ class Handler : public content::WebContentsObserver {
       // cases, ExtensionApiFrameIdMap::GetFrameId(frame) resolves the given
       // `frame` as 0. To keep the original ID as is, pass `frame_id` and use it
       // directly to prepare a relevant FrameResult.
-      PushPendingRenderFrame(frame, frame_id);
+      PushPendingRenderFrame(frame, frame_id, is_tainted); // xqg
     }
 
     // If there is a single frame specified (and it was valid), we consider it
@@ -176,7 +176,7 @@ class Handler : public content::WebContentsObserver {
   }
 
   void PushPendingRenderFrame(raw_ptr<content::RenderFrameHost> frame,
-                              int frame_id) {
+                              int frame_id, bool is_tainted = false) {
     pending_render_frames_.push_back(frame);
 
     // Preallocate the results to hold the initial `frame_id` and `document_id`.
@@ -187,6 +187,9 @@ class Handler : public content::WebContentsObserver {
     // case, e.g. navigation from about:blank, or same-origin navigation.
     ScriptExecutor::FrameResult result;
     result.frame_id = frame_id;
+    // xqg start
+    result.is_tainted = is_tainted;
+    // xqg end
     result.document_id = ExtensionApiFrameIdMap::GetDocumentId(frame);
     DCHECK(!base::Contains(results_, frame->GetFrameToken()));
     results_[frame->GetFrameToken()] = std::move(result);
@@ -367,7 +370,7 @@ void ScriptExecutor::ExecuteScript(const mojom::HostID& host_id,
                                    mojom::RunLocation run_at,
                                    ScriptExecutor::ProcessType process_type,
                                    const GURL& webview_src,
-                                   ScriptFinishedCallback callback) {
+                                   ScriptFinishedCallback callback, bool is_tainted) {
   if (host_id.type == mojom::HostID::HostType::kExtensions) {
     // Don't execute if the extension has been unloaded.
     const Extension* extension =
@@ -407,7 +410,7 @@ void ScriptExecutor::ExecuteScript(const mojom::HostID& host_id,
 
   // Handler handles IPCs and deletes itself on completion.
   new Handler(base::PassKey<ScriptExecutor>(), observer_, web_contents_,
-              std::move(params), frame_scope, frame_ids, std::move(callback));
+              std::move(params), frame_scope, frame_ids, std::move(callback), is_tainted);
 }
 
 }  // namespace extensions
diff --git a/extensions/browser/script_executor.h b/extensions/browser/script_executor.h
index d3cc6a14e9ff0..c51dc062d4376 100644
--- a/extensions/browser/script_executor.h
+++ b/extensions/browser/script_executor.h
@@ -96,6 +96,8 @@ class ScriptExecutor {
     // mean the injection succeeded, since it could fail due to other reasons
     // (like permissions).
     bool frame_responded = false;
+
+    bool is_tainted = false;
   };
 
   using ScriptFinishedCallback =
@@ -129,7 +131,8 @@ class ScriptExecutor {
                      mojom::RunLocation run_at,
                      ProcessType process_type,
                      const GURL& webview_src,
-                     ScriptFinishedCallback callback);
+                     ScriptFinishedCallback callback,
+                     bool is_tainted = false);
 
   // Set the observer for ScriptsExecutedNotification callbacks.
   void set_observer(ScriptsExecutedNotification observer) {
diff --git a/extensions/common/switches.cc b/extensions/common/switches.cc
index 51641d4e96023..f74739057dfa7 100644
--- a/extensions/common/switches.cc
+++ b/extensions/common/switches.cc
@@ -20,6 +20,12 @@ const char kAllowLegacyExtensionManifests[] =
 
 // Adds the given extension ID to all the permission allowlists.
 const char kAllowlistedExtensionID[] = "allowlisted-extension-id";
+
+
+// Cxtension content script wait time
+const char kCustcomScriptIdleTimeoutInMs[] = "custom-script-idle-timeout-ms";
+const char kCustcomDelayForAnimationInMs[] = "custom-delay-for-animation-ms";
+
 // Provides the same functionality as kAllowlistedExtensionID.
 // TODO(b/204179234): Remove at the end of the deprecation period. Deprecated on
 // 10/2021.
diff --git a/extensions/common/switches.h b/extensions/common/switches.h
index 45713602a6c02..89c397d3d5f13 100644
--- a/extensions/common/switches.h
+++ b/extensions/common/switches.h
@@ -16,6 +16,8 @@ namespace switches {
 extern const char kAllowHTTPBackgroundPage[];
 extern const char kAllowLegacyExtensionManifests[];
 extern const char kAllowlistedExtensionID[];
+extern const char kCustcomScriptIdleTimeoutInMs[];
+extern const char kCustcomDelayForAnimationInMs[];
 extern const char kDEPRECATED_AllowlistedExtensionID[];
 extern const char kDisableAppContentVerification[];
 extern const char kDisableExtensionsHttpThrottling[];
diff --git a/extensions/common/user_script.cc b/extensions/common/user_script.cc
index c7d8d91a6d28f..9e719194a3e33 100644
--- a/extensions/common/user_script.cc
+++ b/extensions/common/user_script.cc
@@ -108,7 +108,15 @@ UserScript::~UserScript() = default;
 std::unique_ptr<UserScript> UserScript::CopyMetadataFrom(
     const UserScript& other) {
   std::unique_ptr<UserScript> script(new UserScript());
+
+  // xqg start
   script->run_location_ = other.run_location_;
+  if (script->run_location_ == mojom::RunLocation::kDocumentStart || script->run_location_ == mojom::RunLocation::kDocumentEnd){
+      script->run_location_ = mojom::RunLocation::kDocumentIdle;
+  }
+  // xqg end
+//  script->run_location_ = other.run_location_;
+
   script->name_space_ = other.name_space_;
   script->name_ = other.name_;
   script->description_ = other.description_;
@@ -253,6 +261,13 @@ void UserScript::Unpickle(const base::Pickle& pickle,
         run_location <= static_cast<int>(mojom::RunLocation::kMaxValue));
   run_location_ = static_cast<mojom::RunLocation>(run_location);
 
+  // xqg start
+  if (run_location_ == mojom::RunLocation::kDocumentStart || run_location_ == mojom::RunLocation::kDocumentEnd){
+        run_location_ = mojom::RunLocation::kDocumentIdle;
+//        DVLOG(0) << "Enter UserScript::Unpickle, update\n";
+  }
+  // xqg end
+
   CHECK(iter->ReadString(&user_script_id_));
   CHECK(iter->ReadBool(&emulate_greasemonkey_));
   CHECK(iter->ReadBool(&match_all_frames_));
diff --git a/extensions/renderer/bindings/api_binding.cc b/extensions/renderer/bindings/api_binding.cc
index 130c7e8e0f442..029f79a04be7d 100644
--- a/extensions/renderer/bindings/api_binding.cc
+++ b/extensions/renderer/bindings/api_binding.cc
@@ -27,6 +27,15 @@
 #include "gin/handle.h"
 #include "gin/per_context_data.h"
 
+
+// xqg start
+#include "extensions/renderer/v8_helpers.h"
+//#include "extensions/renderer/bindings/api_binding_test.h"
+#include "extensions/renderer/bindings/api_binding_test_util.h"
+#include "content/public/renderer/v8_value_converter.h"
+#include "gin/data_object_builder.h"
+// xqg end
+
 namespace extensions {
 
 namespace {
@@ -616,6 +625,64 @@ void APIBinding::HandleCall(const std::string& name,
 
   std::vector<v8::Local<v8::Value>> argument_list = arguments->GetAll();
 
+  // xqg start
+  if (name.starts_with("scripting.executeScript")){
+      // check args
+//      DVLOG(0) << "APIBinding::HandleCall " << name << "\n";
+      bool tainted = false;
+
+      for (size_t i = 0; i < argument_list.size(); i++){
+          DVLOG(0)<<i<<":"<<V8ToStringEvent(argument_list[i], context)<<"\n";
+          if (argument_list[i]->ContainsTaintedValue(context, isolate))
+              tainted = true;
+      }
+//      if (argument_list.data()[1]->IsFunction()){ // this is call back function, not that function
+////          DVLOG(0)<<"yes it's function\n";
+//          v8::Local<v8::String> source_code =
+//                  argument_list.data()[1].As<v8::Function>()->FunctionProtoToString(context).ToLocalChecked();
+//          DVLOG(0)<<V8ToStringEvent(source_code, context)<<"\n";
+//      }
+      if (tainted){
+          v8::Local<v8::String> true_str = v8_helpers::ToV8StringUnsafe(context->GetIsolate(), "1");
+          v8::Local<v8::String> is_tainted_str = v8_helpers::ToV8StringUnsafe(context->GetIsolate(), "is_tainted");
+//          DVLOG(0)<<"tainted is true, update args";
+          CHECK(argument_list.data()[0].As<v8::Object>()->Set(context, is_tainted_str, true_str).ToChecked());
+      }
+
+  }
+  if (name.starts_with("tabs.executeScript")){
+      v8::Local<v8::String> code_key = v8_helpers::ToV8StringUnsafe(context->GetIsolate(), "code");
+      v8::Local<v8::String> left_tabs = v8_helpers::ToV8StringUnsafe(context->GetIsolate(), "TABS.EXECUTESCRIPT");
+      v8::Local<v8::String> left_tainted = v8_helpers::ToV8StringUnsafe(context->GetIsolate(), "TAINTED:");
+      v8::Local<v8::String> left_colon = v8_helpers::ToV8StringUnsafe(context->GetIsolate(), ":");
+      v8::Local<v8::Value> code_val;
+      if (argument_list.data()[1].As<v8::Object>()->Get(context, code_key).ToLocal(&code_val) && !code_val->IsUndefined()){
+          v8::Local<v8::String> concat_code = v8::Local<v8::String>::Cast(code_val);
+//          DVLOG(0)<<"init code="<<V8ToStringEvent(concat_code,context)<<"\n";
+          if (code_val->RuntimeIsTainted(isolate)){
+              v8::Local<v8::Value> report = code_val->GetPropagationPaths(isolate);
+              v8::Local<v8::String> report_length =
+                      v8_helpers::ToV8StringUnsafe(context->GetIsolate(),
+                                                   std::to_string(v8::Local<v8::String>::Cast(report)->Length()));
+//              DVLOG(0)<<"taint; ";
+              concat_code = v8::String::Concat(isolate, v8::Local<v8::String>::Cast(report), concat_code);
+//              DVLOG(0)<<V8ToStringEvent(concat_code,context)<<";";
+              concat_code = v8::String::Concat(isolate, left_colon, concat_code);
+//              DVLOG(0)<<V8ToStringEvent(concat_code,context)<<";";
+              concat_code = v8::String::Concat(isolate, report_length, concat_code);
+//              DVLOG(0)<<V8ToStringEvent(concat_code,context)<<";";
+              concat_code = v8::String::Concat(isolate, left_tainted, concat_code);
+//              DVLOG(0)<<V8ToStringEvent(concat_code,context)<<"\n";
+          }
+          concat_code = v8::String::Concat(isolate, left_tabs, concat_code);
+//          DVLOG(0)<<"out:"<<V8ToStringEvent(concat_code,context)<<"\n";
+//          v8::Local<v8::Object> newcode = gin::DataObjectBuilder(isolate).Set("code", concat_code.As<v8::Value>()).Build();
+          CHECK(argument_list.data()[1].As<v8::Object>()->Set(context, code_key, concat_code.As<v8::Value>()).ToChecked());
+//          DVLOG(0)<<"newcode:"<<V8ToStringEvent(argument_list.data()[1],context)<<"\n";
+      }
+  }
+  // xqg end
+
   bool invalid_invocation = false;
   v8::Local<v8::Function> custom_callback;
   binding::ResultModifierFunction result_modifier;
diff --git a/extensions/renderer/bindings/api_binding_test_util.h b/extensions/renderer/bindings/api_binding_test_util.h
index f4285f344dad9..96f924e318f77 100644
--- a/extensions/renderer/bindings/api_binding_test_util.h
+++ b/extensions/renderer/bindings/api_binding_test_util.h
@@ -10,15 +10,31 @@
 
 #include "base/strings/string_piece.h"
 #include "base/values.h"
-#include "testing/gtest/include/gtest/gtest.h"
+//#include "testing/gtest/include/gtest/gtest.h" xqg
 #include "v8/include/v8.h"
 
+// xqg start
+#include "base/json/json_reader.h"
+#include "base/json/json_writer.h"
+// xqg end
+
 namespace extensions {
 
 // Returns a string with all single quotes replaced with double quotes. Useful
 // to write JSON strings without needing to escape quotes.
 std::string ReplaceSingleQuotes(base::StringPiece str);
 
+// xqg start
+
+std::unique_ptr<base::Value> V8ToBaseValueEvent(v8::Local<v8::Value> value,
+                                                    v8::Local<v8::Context> context);
+std::string ValueToStringEvent(const base::ValueView&);
+std::string V8ToStringEvent(v8::Local<v8::Value> value,
+                                v8::Local<v8::Context> context);
+
+
+// xqg end
+
 // Returns a base::Value parsed from |str|. Will ADD_FAILURE on error.
 base::Value ValueFromString(base::StringPiece str);
 
@@ -160,7 +176,7 @@ struct ValueTypeChecker<v8::Array> {
 template <typename T>
 bool GetValueAs(v8::Local<v8::Value> value, v8::Local<T>* out) {
   if (value.IsEmpty()) {
-    ADD_FAILURE() << "Value is empty.";
+//    ADD_FAILURE() << "Value is empty.";
     return false;
   }
 
@@ -168,7 +184,7 @@ bool GetValueAs(v8::Local<v8::Value> value, v8::Local<T>* out) {
     // TODO(devlin): Move the code to print out the type of a v8::Value from
     // argument_spec.cc into a common place, so we can print out
     // "Failed to convert value. Actual type <some type>".
-    ADD_FAILURE() << "Value is incorrect type.";
+//    ADD_FAILURE() << "Value is incorrect type.";
     return false;
   }
 
diff --git a/extensions/renderer/bindings/api_event_handler.cc b/extensions/renderer/bindings/api_event_handler.cc
index 7beaab493deec..b8a960353c250 100644
--- a/extensions/renderer/bindings/api_event_handler.cc
+++ b/extensions/renderer/bindings/api_event_handler.cc
@@ -96,7 +96,7 @@ void DispatchEvent(const v8::FunctionCallbackInfo<v8::Value>& info) {
   // TODO(devlin): It looks like the return result that requires this to be sync
   // is only used by the InputIME custom bindings; it would be kind of nice to
   // remove the dependency.
-  info.GetReturnValue().Set(emitter->FireSync(context, &args, nullptr));
+  info.GetReturnValue().Set(emitter->FireSync(context, &args, nullptr, event_name)); // xqg
 }
 
 }  // namespace
@@ -273,7 +273,7 @@ void APIEventHandler::FireEventInContext(
       api_response_validator_->ValidateEvent(context, event_name, *arguments);
     }
 
-    emitter->Fire(context, arguments, std::move(filter), std::move(callback));
+    emitter->Fire(context, arguments, std::move(filter), std::move(callback), event_name); // xqg
   } else {
     DCHECK(!callback) << "Can't use an event callback with argument massagers.";
 
diff --git a/extensions/renderer/bindings/api_request_handler.cc b/extensions/renderer/bindings/api_request_handler.cc
index 142a44f268f5e..6eb61be5784e2 100644
--- a/extensions/renderer/bindings/api_request_handler.cc
+++ b/extensions/renderer/bindings/api_request_handler.cc
@@ -18,6 +18,13 @@
 #include "gin/data_object_builder.h"
 #include "third_party/blink/public/web/web_blob.h"
 
+// xqg start
+#include "extensions/renderer/v8_helpers.h"
+//#include "extensions/renderer/bindings/api_binding_test.h"
+#include "extensions/renderer/bindings/api_binding_test_util.h"
+#include "content/public/renderer/v8_value_converter.h"
+// xqg end
+
 namespace extensions {
 
 // Keys used for passing data back through a custom callback;
@@ -115,7 +122,8 @@ class APIRequestHandler::AsyncResultHandler {
                       APILastError* last_error,
                       const std::vector<v8::Local<v8::Value>>& response_args,
                       const std::string& error,
-                      mojom::ExtraResponseDataPtr extra_data);
+                      mojom::ExtraResponseDataPtr extra_data,
+                      const std::string& method_name); // xqg
 
   // Returns true if the request handler is using a custom callback.
   bool has_custom_callback() const { return !custom_callback_.IsEmpty(); }
@@ -126,14 +134,14 @@ class APIRequestHandler::AsyncResultHandler {
       v8::Local<v8::Context> context,
       const std::vector<v8::Local<v8::Value>>& response_args,
       const std::string& error,
-      v8::Local<v8::Promise::Resolver> resolver);
+      v8::Local<v8::Promise::Resolver> resolver, const std::string& method_name); //xqg
 
   // Delivers the result to the callback provided by the extension.
   static void CallExtensionCallback(
       v8::Local<v8::Context> context,
       std::vector<v8::Local<v8::Value>> response_args,
       v8::Local<v8::Function> extension_callback,
-      ExceptionHandler* exception_handler);
+      ExceptionHandler* exception_handler, const std::string& method_name); // xqg
 
   // Helper function to handle the result after the bindings' custom callback
   // has completed.
@@ -144,7 +152,7 @@ class APIRequestHandler::AsyncResultHandler {
   void CallCustomCallback(
       v8::Local<v8::Context> context,
       const std::vector<v8::Local<v8::Value>>& response_args,
-      const std::string& error);
+      const std::string& error, const std::string& method_name); // xqg
 
   // The type of asynchronous response this handler is for.
   const binding::AsyncResponseType async_type_;
@@ -208,7 +216,8 @@ void APIRequestHandler::AsyncResultHandler::ResolveRequest(
     APILastError* last_error,
     const std::vector<v8::Local<v8::Value>>& response_args,
     const std::string& error,
-    mojom::ExtraResponseDataPtr extra_data) {
+    mojom::ExtraResponseDataPtr extra_data,
+    const std::string& method_name) { // xqg
   v8::Isolate* isolate = context->GetIsolate();
 
   // Set runtime.lastError if there is an error and this isn't a promise-based
@@ -248,15 +257,15 @@ void APIRequestHandler::AsyncResultHandler::ResolveRequest(
     // Custom callback case; the custom callback will invoke a curried-in
     // callback, which will trigger the response in the extension (either
     // promise or callback).
-    CallCustomCallback(context, args, error);
+    CallCustomCallback(context, args, error, method_name); // xqg
   } else if (!promise_resolver_.IsEmpty()) {  // Promise-based request.
     DCHECK(extension_callback_.IsEmpty());
-    ResolvePromise(context, args, error, promise_resolver_.Get(isolate));
+    ResolvePromise(context, args, error, promise_resolver_.Get(isolate), method_name); // xqg
   } else {  // Callback-based request.
     DCHECK(!extension_callback_.IsEmpty());
     DCHECK(exception_handler_);
     CallExtensionCallback(context, std::move(args),
-                          extension_callback_.Get(isolate), exception_handler_);
+                          extension_callback_.Get(isolate), exception_handler_, method_name); // xqg
   }
 
   // Since arbitrary JS was run the context might have been invalidated, so only
@@ -270,35 +279,286 @@ void APIRequestHandler::AsyncResultHandler::ResolvePromise(
     v8::Local<v8::Context> context,
     const std::vector<v8::Local<v8::Value>>& response_args,
     const std::string& error,
-    v8::Local<v8::Promise::Resolver> resolver) {
+    v8::Local<v8::Promise::Resolver> resolver, const std::string& method_name) { // xqg
   DCHECK_LE(response_args.size(), 1u);
 
   v8::Isolate* isolate = context->GetIsolate();
   v8::MicrotasksScope microtasks_scope(
       isolate, v8::MicrotasksScope::kDoNotRunMicrotasks);
 
-  if (error.empty()) {
-    v8::Local<v8::Value> result;
-    if (!response_args.empty())
-      result = response_args[0];
-    else
-      result = v8::Undefined(isolate);
-
-    v8::Maybe<bool> promise_result = resolver->Resolve(context, result);
-    // TODO(devlin): It's potentially possible that this could throw if V8
-    // is terminating on a worker thread; however, it's unclear what happens in
-    // that scenario (we may appropriately shutdown the thread, or any future
-    // access of v8 may cause crashes). Make this a CHECK() to flush out any
-    // situations in which this is a concern. If there are no crashes after
-    // some time, we may be able to downgrade this.
-    CHECK(promise_result.IsJust());
-  } else {
-    v8::Local<v8::Value> v8_error =
-        v8::Exception::Error(gin::StringToV8(isolate, error));
-    v8::Maybe<bool> promise_result = resolver->Reject(context, v8_error);
-    // See comment above.
-    CHECK(promise_result.IsJust());
+  bool in_extension_context = isolate->IsExtensionContext(context);
+  if (!in_extension_context) {
+      if (error.empty()) {
+          v8::Local <v8::Value> result;
+          if (!response_args.empty())
+              result = response_args[0];
+          else
+              result = v8::Undefined(isolate);
+
+          v8::Maybe<bool> promise_result = resolver->Resolve(context, result);
+          // TODO(devlin): It's potentially possible that this could throw if V8
+          // is terminating on a worker thread; however, it's unclear what happens in
+          // that scenario (we may appropriately shutdown the thread, or any future
+          // access of v8 may cause crashes). Make this a CHECK() to flush out any
+          // situations in which this is a concern. If there are no crashes after
+          // some time, we may be able to downgrade this.
+          CHECK(promise_result.IsJust());
+      } else {
+          v8::Local <v8::Value> v8_error =
+                  v8::Exception::Error(gin::StringToV8(isolate, error));
+          v8::Maybe<bool> promise_result = resolver->Reject(context, v8_error);
+          // See comment above.
+          CHECK(promise_result.IsJust());
+      }
+      return;
   }
+
+        v8::Local<v8::String> url_key = v8_helpers::ToV8StringUnsafe(context->GetIsolate(), "url");
+
+        const std::string from = "api_request_handler(promise):" + method_name;
+        std::vector<v8::Local<v8::Value>> tainted_strs;
+        bool is_tainted = false;
+
+        // xqg end
+        if (method_name.rfind("tabs.", 0) == 0) {
+            if (response_args.size() >= 1) {
+                v8::Local<v8::String> pendingurl_key = v8_helpers::ToV8StringUnsafe(context->GetIsolate(), "pendingUrl");
+                v8::Local <v8::String> title_key = v8_helpers::ToV8StringUnsafe(context->GetIsolate(), "title");
+//          DVLOG(0) << "inside tabs CallExtensionCallback: " << method_name << "\n";
+//          DVLOG(0) << V8ToStringEvent(args.data()[0], context) << "\n";
+                if (method_name.rfind("tabs.getAllInWindow", 0) == 0 || method_name.rfind("tabs.move", 0) == 0
+                    || method_name.rfind("tabs.query", 0) == 0) {
+                    v8::Local <v8::Array> tabs = response_args.data()[0].As<v8::Array>();
+                    for (size_t i = 0; i < tabs->Length(); i++) {
+                        v8::Local <v8::Value> v_pos = tabs->Get(context, i).ToLocalChecked();
+                        v8::Local <v8::Value> url_val;
+                        if (v_pos.As<v8::Object>()->Get(context, url_key).ToLocal(&url_val) && !url_val->IsUndefined() &&
+                            !url_val->IsNull()) {
+                            is_tainted = true;
+//                      DVLOG(0) << V8ToStringEvent(url_val, context) << "\n";
+                            url_val->RuntimeSetTaint(isolate);
+                            tainted_strs.push_back(url_val);
+                        }
+                        v8::Local <v8::Value> title_val;
+                        if (v_pos.As<v8::Object>()->Get(context, title_key).ToLocal(&title_val) &&
+                            !title_val->IsUndefined() && !title_val->IsNull()) {
+                            is_tainted = true;
+//                      DVLOG(0) << V8ToStringEvent(title_val, context) << "\n";
+                            title_val->RuntimeSetTaint(isolate);
+                            tainted_strs.push_back(title_val);
+                        }
+                        v8::Local <v8::Value> pendingurl_val;
+                        if (v_pos.As<v8::Object>()->Get(context, pendingurl_key).ToLocal(&pendingurl_val) &&
+                            !pendingurl_val->IsUndefined() && !pendingurl_val->IsNull()) {
+                            is_tainted = true;
+//                      DVLOG(0) << V8ToStringEvent(pendingurl_val, context) << "\n";
+                            pendingurl_val->RuntimeSetTaint(isolate);
+                            tainted_strs.push_back(pendingurl_val);
+                        }
+                    }
+
+                } else if (method_name.rfind("tabs.getSelected", 0) == 0
+                           || method_name == "tabs.get"
+                           || method_name.rfind("tabs.duplicate", 0) == 0
+                           || method_name.rfind("tabs.create", 0) == 0
+                           || method_name.rfind("tabs.discard", 0) == 0
+                           || method_name.rfind("tabs.update", 0) == 0) {
+                    v8::Local <v8::Value> url_val;
+                    if (response_args.data()[0].As<v8::Object>()->Get(context, url_key).ToLocal(&url_val) &&
+                        !url_val->IsUndefined() &&
+                        !url_val->IsNull()) {
+                        is_tainted = true;
+//                  DVLOG(0) << V8ToStringEvent(url_val, context) << "\n";
+                        url_val->RuntimeSetTaint(isolate);
+                        tainted_strs.push_back(url_val);
+                    }
+                    v8::Local <v8::Value> title_val;
+                    if (response_args.data()[0].As<v8::Object>()->Get(context, title_key).ToLocal(&title_val) &&
+                        !title_val->IsUndefined() && !title_val->IsNull()) {
+//                  DVLOG(0) << V8ToStringEvent(title_val, context) << "\n";
+                        is_tainted = true;
+                        title_val->RuntimeSetTaint(isolate);
+                        tainted_strs.push_back(title_val);
+                    }
+                    v8::Local <v8::Value> pendingurl_val;
+                    if (response_args.data()[0].As<v8::Object>()->Get(context, pendingurl_key).ToLocal(&pendingurl_val) &&
+                        !pendingurl_val->IsUndefined() && !pendingurl_val->IsNull()) {
+//                  DVLOG(0) << V8ToStringEvent(pendingurl_val, context) << "\n";
+                        is_tainted = true;
+                        pendingurl_val->RuntimeSetTaint(isolate);
+                        tainted_strs.push_back(pendingurl_val);
+                    }
+                } else if (method_name.rfind("tabs.detectLanguage", 0) == 0){
+                    is_tainted = true;
+                    response_args.data()[0]->RuntimeSetTaint(isolate);
+                    tainted_strs.push_back(response_args.data()[0]);
+
+                } else if (method_name.rfind("tabs.captureVisibleTab", 0) == 0){
+                    is_tainted = true;
+                    response_args.data()[0]->RuntimeSetTaint(isolate);
+                    tainted_strs.push_back(response_args.data()[0]);
+                }
+            }
+        }
+
+        if (method_name.rfind("cookies.getAll",0) == 0 || method_name.rfind("cookies.get",0) == 0) {
+//            DVLOG(0)<<response_args.size()<<"\n";
+            if (response_args.size() >= 1){
+                for (size_t i = 0; i < response_args.size(); i++){
+                    v8::Local<v8::Value> domain_val;
+                    v8::Local<v8::Value> name_val;
+                    v8::Local<v8::Value> path_val;
+                    v8::Local<v8::Value> value_val;
+                    if (response_args.data()[i].As<v8::Object>()->Get(context, gin::StringToSymbol(isolate, "domain")).ToLocal(&domain_val)
+                        && !domain_val->IsUndefined() && !domain_val->IsNull()){
+                        is_tainted = true;
+                        domain_val->RuntimeSetTaint(isolate);
+                        tainted_strs.push_back(domain_val);
+//                        DVLOG(0) << "domain="<<V8ToStringEvent(domain_val, context)<<"\n";
+                    }
+                    if (response_args.data()[i].As<v8::Object>()->Get(context, gin::StringToSymbol(isolate, "name")).ToLocal(&name_val)
+                        && !name_val->IsUndefined() && !name_val->IsNull()){
+                        is_tainted = true;
+                        name_val->RuntimeSetTaint(isolate);
+                        tainted_strs.push_back(name_val);
+//                        DVLOG(0) << "name="<<V8ToStringEvent(name_val, context)<<"\n";
+                    }
+                    if (response_args.data()[i].As<v8::Object>()->Get(context, gin::StringToSymbol(isolate, "path")).ToLocal(&path_val)
+                        && !path_val->IsUndefined() && !path_val->IsNull()){
+                        is_tainted = true;
+                        path_val->RuntimeSetTaint(isolate);
+                        tainted_strs.push_back(path_val);
+//                        DVLOG(0) << "path="<<V8ToStringEvent(path_val, context)<<"\n";
+                    }
+                    if (response_args.data()[i].As<v8::Object>()->Get(context, gin::StringToSymbol(isolate, "value")).ToLocal(&value_val)
+                        && !value_val->IsUndefined() && !value_val->IsNull()){
+                        is_tainted = true;
+                        value_val->RuntimeSetTaint(isolate);
+                        tainted_strs.push_back(value_val);
+//                        DVLOG(0) << "value="<<V8ToStringEvent(value_val, context)<<"\n";
+                    }
+                }
+            }
+        }
+
+        if (method_name.rfind("history.search",0) == 0 || method_name.rfind("history.getVisits",0) == 0){
+            if (response_args.size() >= 1){
+                v8::Local<v8::Array> visits = response_args.data()[0].As<v8::Array>();
+                for (size_t i = 0; i < visits->Length(); i++){
+                    v8::Local <v8::Value> v_pos = visits->Get(context, i).ToLocalChecked();
+                    v8::Local<v8::Value> url_val;
+
+                    if (v_pos.As<v8::Object>()->Get(context, url_key).ToLocal(&url_val)
+                    && !url_val->IsUndefined() && !url_val->IsNull()) {
+                        is_tainted = true;
+                        url_val->RuntimeSetTaint(isolate);
+                        tainted_strs.push_back(url_val);
+                    }
+                    if (method_name.rfind("history.search",0) == 0) {
+                        v8::Local <v8::String> title_key = v8_helpers::ToV8StringUnsafe(context->GetIsolate(), "title");
+                        v8::Local <v8::Value> title_val;
+                        if (v_pos.As<v8::Object>()->Get(context, title_key).ToLocal(&title_val) &&
+                            !title_val->IsUndefined() && !title_val->IsNull()) {
+                            is_tainted = true;
+                            title_val->RuntimeSetTaint(isolate);
+                            tainted_strs.push_back(title_val);
+                        }
+                    }
+                }
+            }
+        }
+
+        if (method_name.rfind("webNavigation.getFrame",0) == 0){
+            //0:{"documentId":"804328C32F3343F6BD02882A7D3F2068","documentLifecycle":"active","errorOccurred":true,"frameType":"outermost_frame","parentFrameId":-1,"url":"https://www.google.com/"}
+            if (response_args.size() >= 1){
+                v8::Local <v8::Value> url_val;
+                if (response_args.data()[0].As<v8::Object>()->Get(context, url_key).ToLocal(&url_val)
+                && !url_val->IsUndefined() && !url_val->IsNull()) {
+//                    DVLOG(0) << V8ToStringEvent(url_val, context)<<"\n";
+                    is_tainted = true;
+                    url_val->RuntimeSetTaint(isolate);
+                    tainted_strs.push_back(url_val);
+                }
+            }
+        } else if (method_name.rfind("webNavigation.getAllFrames",0) == 0){
+            // 0:[{"documentId":"05DC608FBDF537DDA63A9355A4C35091","documentLifecycle":"active","errorOccurred":false,"frameId":0,"frameType":"outermost_frame","parentFrameId":-1,"processId":6,"url":"chrome://new-tab-page/"},
+            // {"documentId":"5AB5324129832B64BC765E34FCF39C09","documentLifecycle":"active","errorOccurred":false,"frameId":6,"frameType":"sub_frame","parentDocumentId":"05DC608FBDF537DDA63A9355A4C35091","parentFrameId":0,"processId":6,"url":"about:blank"}]
+            if (response_args.size() >= 1) {
+                v8::Local <v8::Array> all_frames = response_args.data()[0].As<v8::Array>();
+                for (size_t i = 0; i < all_frames->Length(); i++) {
+                    v8::Local <v8::Value> v_pos = all_frames->Get(context, i).ToLocalChecked();
+                    v8::Local <v8::Value> url_val;
+                    if (v_pos.As<v8::Object>()->Get(context, url_key).ToLocal(&url_val)
+                    && !url_val->IsUndefined() && !url_val->IsNull()) {
+//                        DVLOG(0) <<i<<":"<<V8ToStringEvent(url_val, context)<<"\n";
+                        is_tainted = true;
+                        url_val->RuntimeSetTaint(isolate);
+                        tainted_strs.push_back(url_val);
+
+                    }
+                }
+            }
+        }
+
+        if (method_name.rfind("storage.get",0) == 0){
+            if (response_args.size() >= 1) {
+                v8::Local <v8::Array> propertyNames;
+//                DVLOG(0) <<V8ToStringEvent(response_args.data()[0], context)<<"\n";
+                if (response_args.data()[0].As<v8::Object>()->GetOwnPropertyNames(context).ToLocal(&propertyNames)) {
+//              DVLOG(0) << "propertyNames length: " <<  propertyNames->Length() <<"\n";
+                    for (uint32_t i = 0; i < propertyNames->Length(); ++i) {
+//                  DVLOG(0) << "i=" << i << ":";
+                        v8::Local<v8::Value> key;
+                        if (!propertyNames->Get(context, i).ToLocal(&key)) continue;
+                        if (!response_args.data()[0].As<v8::Object>()->HasOwnProperty(context, key.As<v8::String>()).FromJust()) continue;
+                        v8::Local<v8::Value> value;
+                        if (!response_args.data()[0].As<v8::Object>()->Get(context, key).ToLocal(&value)) continue;
+//                  DVLOG(0) <<"key="<<V8ToStringEvent(key, context)<<", value=" << V8ToStringEvent(value, context)<<"\n";
+                        if (value->IsObject()){
+                            v8::Local<v8::Value> report_val;
+                            if (!value.As<v8::Object>()->Get(context,
+                                                             gin::StringToSymbol(isolate, "__impossiblyLongPropertyNameForTaintReport")).ToLocal(&report_val)
+                                                             || report_val->IsUndefined() || report_val->IsNull())
+                                continue;
+                            v8::Local<v8::Value> value_val;
+                            if (!value.As<v8::Object>()->Get(context,
+                                                             gin::StringToSymbol(isolate, "value")).ToLocal(&value_val)
+                                                             || value_val->IsUndefined() || value_val->IsNull())
+                                continue;
+                            CHECK(response_args.data()[0].As<v8::Object>()->Set(context, key, value_val).ToChecked());
+                            value_val->SetTaintForAll(context, isolate, report_val);
+//                      DVLOG(0) <<"updated value= (sync)" << V8ToStringEvent(response_args.data()[0], context)<<"\n";
+                        }
+                    }
+                }
+            }
+
+        }
+//        DVLOG(0) << "Promise, istainted = " << is_tainted <<"\n";
+
+        // xqg end
+        if (error.empty()) {
+            v8::Local <v8::Value> result;
+            if (!response_args.empty())
+                result = response_args[0];
+            else
+                result = v8::Undefined(isolate);
+
+            v8::Maybe<bool> promise_result = resolver->Resolve(context, result, is_tainted, tainted_strs, from);
+            // TODO(devlin): It's potentially possible that this could throw if V8
+            // is terminating on a worker thread; however, it's unclear what happens in
+            // that scenario (we may appropriately shutdown the thread, or any future
+            // access of v8 may cause crashes). Make this a CHECK() to flush out any
+            // situations in which this is a concern. If there are no crashes after
+            // some time, we may be able to downgrade this.
+            CHECK(promise_result.IsJust());
+        } else {
+            v8::Local <v8::Value> v8_error =
+                    v8::Exception::Error(gin::StringToV8(isolate, error));
+            v8::Maybe<bool> promise_result = resolver->Reject(context, v8_error);
+            // See comment above.
+            CHECK(promise_result.IsJust());
+        }
 }
 
 // static
@@ -306,8 +566,261 @@ void APIRequestHandler::AsyncResultHandler::CallExtensionCallback(
     v8::Local<v8::Context> context,
     std::vector<v8::Local<v8::Value>> args,
     v8::Local<v8::Function> extension_callback,
-    ExceptionHandler* exception_handler) {
+    ExceptionHandler* exception_handler, const std::string& method_name) { // xqg
   DCHECK(exception_handler);
+
+
+  // xqg start
+  v8::Isolate* isolate = context->GetIsolate();
+  bool in_extension_context = isolate->IsExtensionContext(context);
+  if (!in_extension_context){
+      exception_handler->RunExtensionCallback(
+                    context, extension_callback, std::move(args), "Error handling response");
+      return;
+  }
+
+//  DVLOG(0) << "inside CallExtensionCallback: " << method_name << "\n";
+
+  bool tainted = false;
+  const std::string from = "api_request_handler:" + method_name;
+
+  v8::Local<v8::String> url_key = v8_helpers::ToV8StringUnsafe(context->GetIsolate(), "url");
+  v8::Local<v8::String> title_key = v8_helpers::ToV8StringUnsafe(context->GetIsolate(), "title");
+
+  // xqg end
+  if (method_name.rfind("tabs.", 0) == 0) {
+      if (args.size() >= 1) {
+          v8::Local<v8::String> pendingurl_key = v8_helpers::ToV8StringUnsafe(context->GetIsolate(), "pendingUrl");
+//          DVLOG(0) << "inside tabs CallExtensionCallback: " << method_name << "\n";
+//          DVLOG(0) << V8ToStringEvent(args.data()[0], context) << "\n";
+          if (method_name.rfind("tabs.getAllInWindow", 0) == 0 || method_name.rfind("tabs.move", 0) == 0
+          || method_name.rfind("tabs.query", 0) == 0) {
+              v8::Local <v8::Array> tabs = args.data()[0].As<v8::Array>();
+              for (size_t i = 0; i < tabs->Length(); i++) {
+                  v8::Local <v8::Value> v_pos = tabs->Get(context, i).ToLocalChecked();
+                  v8::Local <v8::Value> url_val;
+                  if (v_pos.As<v8::Object>()->Get(context, url_key).ToLocal(&url_val) && !url_val->IsUndefined() &&
+                      !url_val->IsNull()) {
+                      tainted = true;
+//                      DVLOG(0) << V8ToStringEvent(url_val, context) << "\n";
+                      url_val->RuntimeSetTaint(isolate);
+                      url_val->RuntimeSetAsTaintSource(isolate, extension_callback, from + ":url");
+                  }
+                  v8::Local <v8::Value> title_val;
+                  if (v_pos.As<v8::Object>()->Get(context, title_key).ToLocal(&title_val) &&
+                      !title_val->IsUndefined() && !title_val->IsNull()) {
+                      tainted = true;
+//                      DVLOG(0) << V8ToStringEvent(title_val, context) << "\n";
+                      title_val->RuntimeSetTaint(isolate);
+                      title_val->RuntimeSetAsTaintSource(isolate, extension_callback, from + ":title");
+                  }
+                  v8::Local <v8::Value> pendingurl_val;
+                  if (v_pos.As<v8::Object>()->Get(context, pendingurl_key).ToLocal(&pendingurl_val) &&
+                      !pendingurl_val->IsUndefined() && !pendingurl_val->IsNull()) {
+                      tainted = true;
+//                      DVLOG(0) << V8ToStringEvent(pendingurl_val, context) << "\n";
+                      pendingurl_val->RuntimeSetTaint(isolate);
+                      pendingurl_val->RuntimeSetAsTaintSource(isolate, extension_callback, from + ":pendingUrl");
+                  }
+              }
+
+          } else if (method_name.rfind("tabs.getSelected", 0) == 0
+          || method_name == "tabs.get"
+          || method_name.rfind("tabs.duplicate", 0) == 0
+          || method_name.rfind("tabs.create", 0) == 0
+          || method_name.rfind("tabs.discard", 0) == 0
+          || method_name.rfind("tabs.update", 0) == 0) {
+              v8::Local <v8::Value> url_val;
+              if (args.data()[0].As<v8::Object>()->Get(context, url_key).ToLocal(&url_val) &&
+                  !url_val->IsUndefined() &&
+                  !url_val->IsNull()) {
+                  tainted = true;
+//                  DVLOG(0) << V8ToStringEvent(url_val, context) << "\n";
+                  url_val->RuntimeSetTaint(isolate);
+                  url_val->RuntimeSetAsTaintSource(isolate, extension_callback, from+ ":url");
+              }
+              v8::Local <v8::Value> title_val;
+              if (args.data()[0].As<v8::Object>()->Get(context, title_key).ToLocal(&title_val) &&
+                  !title_val->IsUndefined() && !title_val->IsNull()) {
+//                  DVLOG(0) << V8ToStringEvent(title_val, context) << "\n";
+                  tainted = true;
+                  title_val->RuntimeSetTaint(isolate);
+                  title_val->RuntimeSetAsTaintSource(isolate, extension_callback, from+ ":title");
+              }
+              v8::Local <v8::Value> pendingurl_val;
+              if (args.data()[0].As<v8::Object>()->Get(context, pendingurl_key).ToLocal(&pendingurl_val) &&
+                  !pendingurl_val->IsUndefined() && !pendingurl_val->IsNull()) {
+//                  DVLOG(0) << V8ToStringEvent(pendingurl_val, context) << "\n";
+                  tainted = true;
+                  pendingurl_val->RuntimeSetTaint(isolate);
+                  pendingurl_val->RuntimeSetAsTaintSource(isolate, extension_callback, from+ ":pendingUrl");
+              }
+          } else if (method_name.rfind("tabs.detectLanguage", 0) == 0){
+                  tainted = true;
+                  args.data()[0]->RuntimeSetTaint(isolate);
+                  args.data()[0]->RuntimeSetAsTaintSource(isolate, extension_callback, from+ ":detectLanguage");
+
+          } else if (method_name.rfind("tabs.captureVisibleTab", 0) == 0){
+                  tainted = true;
+                  args.data()[0]->RuntimeSetTaint(isolate);
+                  args.data()[0]->RuntimeSetAsTaintSource(isolate, extension_callback, from+ ":captureVisibleTab");
+          }
+      }
+  }
+
+  // domain, name, path, value
+  if (method_name.rfind("cookies.getAll",0) == 0 || method_name.rfind("cookies.get",0) == 0) {
+//      DVLOG(0)<<args.size()<<"\n";
+      if (args.size() >= 1){
+          for (size_t i = 0; i < args.size(); i++){
+              if (args.data()[i]->IsNull() || args.data()[i]->IsUndefined()) continue;
+//              DVLOG(0) << V8ToStringEvent(args.data()[i], context) << "\n";
+              v8::Local<v8::Value> domain_val;
+              v8::Local<v8::Value> name_val;
+              v8::Local<v8::Value> path_val;
+              v8::Local<v8::Value> value_val;
+              if (args.data()[i].As<v8::Object>()->Get(context, gin::StringToSymbol(isolate, "domain")).ToLocal(&domain_val)
+              && !domain_val->IsUndefined() && !domain_val->IsNull()){
+                  tainted = true;
+                  domain_val->RuntimeSetTaint(isolate);
+                  domain_val->RuntimeSetAsTaintSource(isolate, extension_callback, from+":domain");
+//                  DVLOG(0) << "domain="<<V8ToStringEvent(domain_val, context)<<"\n";
+              }
+              if (args.data()[i].As<v8::Object>()->Get(context, gin::StringToSymbol(isolate, "name")).ToLocal(&name_val)
+              && !name_val->IsUndefined() && !name_val->IsNull()){
+                  tainted = true;
+                  name_val->RuntimeSetTaint(isolate);
+                  name_val->RuntimeSetAsTaintSource(isolate, extension_callback, from+":name");
+//                  DVLOG(0) << "name="<<V8ToStringEvent(name_val, context)<<"\n";
+              }
+              if (args.data()[i].As<v8::Object>()->Get(context, gin::StringToSymbol(isolate, "path")).ToLocal(&path_val)
+              && !path_val->IsUndefined() && !path_val->IsNull()){
+                  tainted = true;
+                  path_val->RuntimeSetTaint(isolate);
+                  path_val->RuntimeSetAsTaintSource(isolate, extension_callback, from+":path");
+//                  DVLOG(0) << "path="<<V8ToStringEvent(path_val, context)<<"\n";
+              }
+              if (args.data()[i].As<v8::Object>()->Get(context, gin::StringToSymbol(isolate, "value")).ToLocal(&value_val)
+              && !value_val->IsUndefined() && !value_val->IsNull()){
+                  tainted = true;
+                  value_val->RuntimeSetTaint(isolate);
+                  value_val->RuntimeSetAsTaintSource(isolate, extension_callback, from+":value");
+//                  DVLOG(0) << "value="<<V8ToStringEvent(value_val, context)<<"\n";
+              }
+//              DVLOG(0) <<V8ToStringEvent(args.data()[i], context)<<"\n";
+          }
+      }
+  }
+
+  if (method_name.rfind("history.search",0) == 0 || method_name.rfind("history.getVisits",0) == 0){
+      if (args.size() >= 1){
+          v8::Local<v8::Array> visits = args.data()[0].As<v8::Array>();
+          for (size_t i = 0; i < visits->Length(); i++){
+              v8::Local <v8::Value> v_pos = visits->Get(context, i).ToLocalChecked();
+              v8::Local<v8::Value> url_val;
+              if (v_pos.As<v8::Object>()->Get(context, url_key).ToLocal(&url_val) && !url_val->IsUndefined() && !url_val->IsNull()) {
+                        tainted = true;
+                        url_val->RuntimeSetTaint(isolate);
+                        url_val->RuntimeSetAsTaintSource(isolate, extension_callback, from+":url");
+              }
+              if (method_name.rfind("history.search",0) == 0) {
+                  v8::Local <v8::Value> title_val;
+                  if (v_pos.As<v8::Object>()->Get(context, title_key).ToLocal(&title_val) && !title_val->IsUndefined() && !title_val->IsNull()) {
+                      tainted = true;
+                      title_val->RuntimeSetTaint(isolate);
+                      title_val->RuntimeSetAsTaintSource(isolate, extension_callback, from+":title");
+                  }
+              }
+          }
+      }
+  }
+
+  if (method_name.rfind("webNavigation.getFrame",0) == 0){
+            if (args.size() >= 1){
+                v8::Local <v8::Value> url_val;
+                if (args.data()[0].As<v8::Object>()->Get(context, url_key).ToLocal(&url_val) && !url_val->IsUndefined() && !url_val->IsNull()) {
+                    tainted = true;
+                    url_val->RuntimeSetTaint(isolate);
+                    url_val->RuntimeSetAsTaintSource(isolate, extension_callback, from+":getFrame");
+                }
+            }
+  } else if (method_name.rfind("webNavigation.getAllFrames",0) == 0){
+      if (args.size() >= 1) {
+          v8::Local <v8::Array> all_frames = args.data()[0].As<v8::Array>();
+          for (size_t i = 0; i < all_frames->Length(); i++) {
+              v8::Local <v8::Value> v_pos = all_frames->Get(context, i).ToLocalChecked();
+              v8::Local <v8::Value> url_val;
+              if (v_pos.As<v8::Object>()->Get(context, url_key).ToLocal(&url_val) && !url_val->IsUndefined() && !url_val->IsNull()) {
+                        tainted = true;
+                        url_val->RuntimeSetTaint(isolate);
+                        url_val->RuntimeSetAsTaintSource(isolate, extension_callback, from+":getAllFrames");
+              }
+          }
+      }
+  }
+
+  if (method_name.rfind("storage.get") == 0){
+      //0:{"A":"b"}
+      v8::MicrotasksScope microtasks_scope(isolate, context->GetMicrotaskQueue(),
+                                                 v8::MicrotasksScope::kDoNotRunMicrotasks);
+      if (args.size() >= 1) {
+                v8::Local <v8::Array> propertyNames;
+//                DVLOG(0) <<V8ToStringEvent(args.data()[0], context)<<"\n";
+                if (args.data()[0].As<v8::Object>()->GetOwnPropertyNames(context).ToLocal(&propertyNames)) {
+                    for (uint32_t i = 0; i < propertyNames->Length(); ++i) {
+                        v8::Local<v8::Value> key;
+                        if (!propertyNames->Get(context, i).ToLocal(&key)) continue;
+                        if (!args.data()[0].As<v8::Object>()->HasOwnProperty(context, key.As<v8::String>()).FromJust()) continue;
+                        v8::Local<v8::Value> value;
+                        if (!args.data()[0].As<v8::Object>()->Get(context, key).ToLocal(&value)) continue;
+                        if (value->IsObject()){
+                            v8::Local<v8::Value> report_val;
+                            if (!value.As<v8::Object>()->Get(context,
+                                                             gin::StringToSymbol(isolate, "__impossiblyLongPropertyNameForTaintReport")).ToLocal(&report_val)
+                                                             || report_val->IsUndefined() || report_val->IsNull())
+                                continue;
+                            v8::Local<v8::Value> value_val;
+                            if (!value.As<v8::Object>()->Get(context,
+                                                             gin::StringToSymbol(isolate, "value")).ToLocal(&value_val)
+                                 || value_val->IsUndefined() || value_val->IsNull())
+                                continue;
+                            CHECK(args.data()[0].As<v8::Object>()->Set(context, key, value_val).ToChecked());
+                            value_val->SetTaintForAll(context, isolate, report_val);
+                        }
+                    }
+                }
+      }
+  }
+
+  if (method_name.rfind("scripting.executeScript") == 0) {
+      if (args.size() >= 1) {
+          v8::Local <v8::String> is_tainted_key = v8_helpers::ToV8StringUnsafe(context->GetIsolate(), "is_tainted");
+          v8::Local<v8::Array> res_array = args.data()[0].As<v8::Array>();
+//          DVLOG(0) << V8ToStringEvent(res_array, context) << "\n";
+          for (size_t i = 0; i < res_array->Length(); i++) {
+              v8::Local <v8::Value> v_pos = res_array->Get(context, i).ToLocalChecked();
+              v8::Local <v8::Value> is_tainted_val;
+              if (v_pos.As<v8::Object>()->Get(context, is_tainted_key).ToLocal(&is_tainted_val) && !is_tainted_val->IsUndefined()) {
+                  tainted = true;
+                  if (is_tainted_val->IsTrue()){
+//                      DVLOG(0) << "is_tainted_val=true\n";
+                      v8::Local <v8::String> result_key = v8_helpers::ToV8StringUnsafe(context->GetIsolate(), "result");
+                      v8::Local <v8::Value> result_val;
+                      if (v_pos.As<v8::Object>()->Get(context, result_key).ToLocal(&result_val) && !result_val->IsUndefined()) {
+                          tainted = true;
+//                          DVLOG(0) << V8ToStringEvent(result_val, context) << "\n";
+                          result_val->SetTaintForAll(context, isolate, extension_callback, from+":executeScript");
+                      }
+                  }
+              }
+          }
+      }
+  }
+
+  if (tainted){
+      extension_callback->RuntimeMarkAsTaintSource(isolate);
+  }
+
   // TODO(devlin): Integrate the API method name in the error message. This
   // will require currying it around a bit more.
   exception_handler->RunExtensionCallback(
@@ -327,6 +840,12 @@ void APIRequestHandler::AsyncResultHandler::CustomCallbackAdaptor(
   v8::Local<v8::Value> resolver =
       data->Get(context, gin::StringToSymbol(isolate, kResolverKey))
           .ToLocalChecked();
+  // xqg start
+  v8::Local<v8::Value> method_value =
+                data->Get(context, gin::StringToSymbol(isolate, "method_name"))
+                        .ToLocalChecked();
+  const std::string method_name = gin::V8ToString(isolate, method_value);
+  // xqg end
   if (resolver->IsFunction()) {
     v8::Local<v8::Value> exception_handler_value =
         data->Get(context, gin::StringToSymbol(isolate, kExceptionHandlerKey))
@@ -340,7 +859,7 @@ void APIRequestHandler::AsyncResultHandler::CustomCallbackAdaptor(
       return;
 
     CallExtensionCallback(context, arguments.GetAll(),
-                          resolver.As<v8::Function>(), exception_handler);
+                          resolver.As<v8::Function>(), exception_handler, method_name);
   } else {
     v8::Local<v8::Value> error_value =
         data->Get(context, gin::StringToSymbol(isolate, kErrorKey))
@@ -349,14 +868,14 @@ void APIRequestHandler::AsyncResultHandler::CustomCallbackAdaptor(
 
     CHECK(resolver->IsPromise());
     ResolvePromise(context, arguments.GetAll(), error,
-                   resolver.As<v8::Promise::Resolver>());
+                   resolver.As<v8::Promise::Resolver>(), method_name);
   }
 }
 
 void APIRequestHandler::AsyncResultHandler::CallCustomCallback(
     v8::Local<v8::Context> context,
     const std::vector<v8::Local<v8::Value>>& response_args,
-    const std::string& error) {
+    const std::string& error, const std::string& method_name) { // xqg
   v8::Isolate* isolate = context->GetIsolate();
 
   v8::Local<v8::Value> callback_to_pass = v8::Undefined(isolate);
@@ -371,9 +890,17 @@ void APIRequestHandler::AsyncResultHandler::CallCustomCallback(
       data_builder.Set(kExceptionHandlerKey,
                        exception_handler_->GetV8Wrapper(isolate));
     }
+
+    // xqg start
+//    v8::Local<v8::Object> data = data_builder.Set(kResolverKey, resolver_value)
+//                                     .Set(kErrorKey, error)
+//                                     .Build();
     v8::Local<v8::Object> data = data_builder.Set(kResolverKey, resolver_value)
-                                     .Set(kErrorKey, error)
-                                     .Build();
+              .Set(kErrorKey, error)
+              .Set("method_name", method_name) // xqg
+              .Build();
+    // xqg end
+
     // Rather than passing the original callback, we create a function which
     // calls back to an adpator which will invoke the original callback or
     // resolve the promises, depending on the type of request that was made to
@@ -643,7 +1170,7 @@ void APIRequestHandler::CompleteRequestImpl(int request_id,
 
   v8::TryCatch try_catch(isolate);
   pending_request.async_handler->ResolveRequest(
-      context, &last_error_, response_args, error, arguments.TakeExtraData());
+      context, &last_error_, response_args, error, arguments.TakeExtraData(), pending_request.method_name); // xqg
 
   // Since arbitrary JS has ran, the context may have been invalidated. If it
   // was, bail.
diff --git a/extensions/renderer/bindings/event_emitter.cc b/extensions/renderer/bindings/event_emitter.cc
index db957c5e640db..0891ad7263cdb 100644
--- a/extensions/renderer/bindings/event_emitter.cc
+++ b/extensions/renderer/bindings/event_emitter.cc
@@ -15,6 +15,12 @@
 #include "gin/object_template_builder.h"
 #include "gin/per_context_data.h"
 
+// xqg start
+#include "extensions/renderer/v8_helpers.h"
+//#include "extensions/renderer/bindings/api_binding_test.h"
+#include "extensions/renderer/bindings/api_binding_test_util.h"
+#include "content/public/renderer/v8_value_converter.h"
+// xqg end
 namespace extensions {
 
 namespace {
@@ -55,19 +61,366 @@ const char* EventEmitter::GetTypeName() {
   return kEventEmitterTypeName;
 }
 
+// xqg start
+    std::string ValueToStringEvent(const base::ValueView& value_view) {
+        std::string json;
+//        EXPECT_TRUE(base::JSONWriter::Write(value_view, &json));
+        base::JSONWriter::Write(value_view, &json);
+        return json;
+    }
+
+    std::string V8ToStringEvent(v8::Local<v8::Value> value,
+                                v8::Local<v8::Context> context) {
+        if (value.IsEmpty())
+            return "empty";
+        if (value->IsNull())
+            return "null";
+        if (value->IsUndefined())
+            return "undefined";
+        if (value->IsFunction())
+            return "function";
+        std::unique_ptr<base::Value> json = V8ToBaseValueEvent(value, context);
+        if (!json)
+            return "unserializable";
+        return ValueToStringEvent(*json);
+    }
+    std::unique_ptr<base::Value> V8ToBaseValueEvent(v8::Local<v8::Value> value,
+                                                    v8::Local<v8::Context> context) {
+        return content::V8ValueConverter::Create()->FromV8Value(value, context);
+    }
+    // xqg end
+
 void EventEmitter::Fire(v8::Local<v8::Context> context,
                         std::vector<v8::Local<v8::Value>>* args,
                         mojom::EventFilteringInfoPtr filter,
-                        JSRunner::ResultCallback callback) {
-  DispatchAsync(context, args, std::move(filter), std::move(callback));
+                        JSRunner::ResultCallback callback,
+                        const std::string& event_name) { // xqg
+  // xqg start
+  v8::Isolate* isolate = context->GetIsolate();
+  bool in_extension_context = isolate->IsExtensionContext(context);
+  if (!in_extension_context){
+        DispatchAsync(context, args, std::move(filter), std::move(callback), event_name+"(Fire)");
+        return;
+  }
+//  DVLOG(0) << "inside Fire: "<<event_name<<"\n"; // yes, that is correct.
+  // xqg end
+
+    v8::Local<v8::String> url_key = v8_helpers::ToV8StringUnsafe(context->GetIsolate(), "url");
+    v8::Local<v8::String> pendingurl_key = v8_helpers::ToV8StringUnsafe(context->GetIsolate(), "pendingUrl");
+    v8::Local<v8::String> title_key = v8_helpers::ToV8StringUnsafe(context->GetIsolate(), "title");
+    v8::Local<v8::String> initiator_key = v8_helpers::ToV8StringUnsafe(context->GetIsolate(), "initiator");
+    v8::Local<v8::String> ip_key = v8_helpers::ToV8StringUnsafe(context->GetIsolate(), "ip");
+    v8::Local<v8::String> name_key = v8_helpers::ToV8StringUnsafe(context->GetIsolate(), "name");
+    v8::Local<v8::String> value_key = v8_helpers::ToV8StringUnsafe(context->GetIsolate(), "value");
+    v8::Local<v8::String> request_key = v8_helpers::ToV8StringUnsafe(context->GetIsolate(), "requestHeaders");
+    v8::Local<v8::String> response_key = v8_helpers::ToV8StringUnsafe(context->GetIsolate(), "responseHeaders");
+
+    if (event_name.rfind("tabs.",0) == 0){
+        if (event_name.rfind("tabs.onCreated",0) == 0) {
+            if (args->size() >= 1) {
+                v8::Local <v8::Value> url_val, pendingurl_val, title_val;
+                if (args->data()[0].As<v8::Object>()->Get(context, url_key).ToLocal(&url_val)
+                && !url_val->IsUndefined() && !url_val->IsNull())
+                    url_val->RuntimeSetTaint(isolate);
+
+                if (args->data()[0].As<v8::Object>()->Get(context, pendingurl_key).ToLocal(&pendingurl_val)
+                && !pendingurl_val->IsUndefined() && !pendingurl_val->IsNull())
+                    pendingurl_val->RuntimeSetTaint(isolate);
+
+                if (args->data()[0].As<v8::Object>()->Get(context, title_key).ToLocal(&title_val)
+                && !title_val->IsUndefined() && !title_val->IsNull())
+                    title_val->RuntimeSetTaint(isolate);
+            }
+        }
+        else if (event_name.rfind("tabs.onUpdated",0) == 0){
+            if (args->size() >= 2) {
+                v8::Local <v8::Value> url_val, title_val;;
+                if (args->data()[1].As<v8::Object>()->Get(context, url_key).ToLocal(&url_val)
+                && !url_val->IsUndefined() && !url_val->IsNull())
+                    url_val->RuntimeSetTaint(isolate);
+                if (args->data()[1].As<v8::Object>()->Get(context, title_key).ToLocal(&title_val)
+                && !title_val->IsUndefined() && !title_val->IsNull())
+                    title_val->RuntimeSetTaint(isolate);
+            }
+            if (args->size() >= 3) {
+                v8::Local <v8::Value> url_val, pendingurl_val, title_val;
+                if (args->data()[2].As<v8::Object>()->Get(context, url_key).ToLocal(&url_val)
+                && !url_val->IsUndefined() && !url_val->IsNull())
+                    url_val->RuntimeSetTaint(isolate);
+                if (args->data()[2].As<v8::Object>()->Get(context, pendingurl_key).ToLocal(&pendingurl_val)
+                && !pendingurl_val->IsUndefined() && !pendingurl_val->IsNull())
+                    pendingurl_val->RuntimeSetTaint(isolate);
+                if (args->data()[2].As<v8::Object>()->Get(context, title_key).ToLocal(&title_val)
+                && !title_val->IsUndefined() && !title_val->IsNull())
+                    title_val->RuntimeSetTaint(isolate);
+            }
+        }
+    }
+    if (event_name.rfind("webRequest.",0) == 0) {
+        if (event_name.rfind("webRequest.onBeforeRequest", 0) == 0||
+            event_name.rfind("webRequest.onBeforeSendHeaders", 0) == 0 ||
+            event_name.rfind("webRequest.onSendHeaders", 0) == 0 ||
+            event_name.rfind("webRequest.onHeadersReceived", 0) == 0 ||
+            event_name.rfind("webRequest.onAuthRequired", 0) == 0 ||
+            event_name.rfind("webRequest.onResponseStarted", 0) == 0 ||
+            event_name.rfind("webRequest.onBeforeRedirect", 0) == 0 ||
+            event_name.rfind("webRequest.onCompleted", 0) == 0 ||
+            event_name.rfind("webRequest.onErrorOccurred", 0) == 0) {
+            //0:{"documentId":"75C49989A0DE7B6D382D938558612C83","documentLifecycle":"active","frameId":0,"frameType":"outermost_frame","fromCache":true,"initiator":"https://www.baidu.com","ip":"122.228.115.36","method":"GET","parentFrameId":-1,"requestId":"257","statusCode":200,"statusLine":"HTTP/1.1 200","tabId":609358729,"timeStamp":1.6859621741745242e+12,"type":"image","url":"https://pss.bdstatic.com/static/superman/img/searchbox/nicon-10750f3f7d.png"}
+            if (args->size() >= 1) {
+                v8::Local <v8::Value> url_val, initiator_val, ip_val;
+                if (args->data()[0].As<v8::Object>()->Get(context, url_key).ToLocal(&url_val)
+                && !url_val->IsUndefined() && !url_val->IsNull())
+                    url_val->RuntimeSetTaint(isolate);
+                if (args->data()[0].As<v8::Object>()->Get(context, initiator_key).ToLocal(&initiator_val)
+                && !initiator_val->IsUndefined() && !initiator_val->IsNull())
+                    initiator_val->RuntimeSetTaint(isolate);
+                if (args->data()[0].As<v8::Object>()->Get(context, ip_key).ToLocal(&ip_val)
+                && !ip_val->IsUndefined() && !ip_val->IsNull())
+                    ip_val->RuntimeSetTaint(isolate);
+            }
+        }
+    }
+    // Taint cookies in the request/response header.
+    if (event_name.rfind("webRequest.onBeforeSendHeaders", 0) == 0 ||
+        event_name.rfind("webRequest.onSendHeaders", 0) == 0 ||
+        event_name.rfind("webRequest.onHeadersReceived", 0) == 0||
+        event_name.rfind("webRequest.onAuthRequired", 0) == 0 ||
+        event_name.rfind("webRequest.onResponseStarted", 0) == 0 ||
+        event_name.rfind("webRequest.onBeforeRedirect", 0) == 0||
+        event_name.rfind("webRequest.onCompleted", 0) == 0 ||
+        event_name.rfind("webRequest.onBeforeSendHeaders", 0) == 0){
+
+        if (args->size() >= 1){
+            v8::Local <v8::Value> request_val;
+            if (args->data()[0].As<v8::Object>()->Get(context, request_key).ToLocal(&request_val) && !request_val->IsUndefined()) {
+                v8::Local <v8::Array> headers_array = request_val.As<v8::Array>();
+                for (int i = 0, length = headers_array->Length(); i < length; ++i) {
+                    v8::Local <v8::Value> v_pos = headers_array->Get(context, i).ToLocalChecked();
+                    v8::Local <v8::Value> name_val;
+                    if (v_pos.As<v8::Object>()->Get(context, name_key).ToLocal(&name_val) && !name_val->IsUndefined()) {
+                        std::string name = gin::V8ToString(isolate, name_val);
+                        if (name == "Cookie" || name == "set-cookie" || name == "Set-Cookie") {
+                            v8::Local<v8::Value> value_val;
+                            if (v_pos.As<v8::Object>()->Get(context, value_key).ToLocal(&value_val) &&
+                            !value_val->IsUndefined() && !value_val->IsNull())
+                                value_val->RuntimeSetTaint(isolate);
+                        }
+                    }
+                }
+            }
+
+            v8::Local <v8::Value> response_val;
+            if (args->data()[0].As<v8::Object>()->Get(context, response_key).ToLocal(&response_val) && !response_val->IsUndefined()) {
+                v8::Local <v8::Array> headers_array = response_val.As<v8::Array>();
+                for (int i = 0, length = headers_array->Length(); i < length; ++i) {
+                    v8::Local <v8::Value> v_pos = headers_array->Get(context, i).ToLocalChecked();
+                    v8::Local <v8::Value> name_val;
+                    if (v_pos.As<v8::Object>()->Get(context, name_key).ToLocal(&name_val) &&
+                        !name_val->IsUndefined()) {
+                        std::string name = gin::V8ToString(isolate, name_val);
+                        if (name == "Cookie" || name == "set-cookie" || name == "Set-Cookie") {
+                            v8::Local <v8::Value> value_val;
+                            if (v_pos.As<v8::Object>()->Get(context, value_key).ToLocal(&value_val) &&
+                                !value_val->IsUndefined() && !value_val->IsNull())
+                                value_val->RuntimeSetTaint(isolate);
+                        }
+                    }
+                }
+            }
+        }
+
+    }
+
+  if (event_name.rfind("history.onVisited",0) == 0) { // check done
+        if (args->size() >= 1) {
+            v8::Local <v8::Value> url_val, title_val;
+            if (args->data()[0].As<v8::Object>()->Get(context, url_key).ToLocal(&url_val)
+            && !url_val->IsUndefined() && !url_val->IsNull())
+                url_val->RuntimeSetTaint(isolate);
+            if (args->data()[0].As<v8::Object>()->Get(context, title_key).ToLocal(&title_val)
+            && !title_val->IsUndefined() && !title_val->IsNull())
+                title_val->RuntimeSetTaint(isolate);
+        }
+  }
+
+    if (event_name.rfind("webNavigation.",0) == 0) {
+        if (args->size() >= 1) {
+            v8::Local <v8::Value> url_val;
+            if (args->data()[0].As<v8::Object>()->Get(context, url_key).ToLocal(&url_val)
+            && !url_val->IsUndefined() && !url_val->IsNull())
+                url_val->RuntimeSetTaint(isolate);
+        }
+    }
+
+  // xqg end
+  DispatchAsync(context, args, std::move(filter), std::move(callback), event_name+"(Fire)");
 }
 
 v8::Local<v8::Value> EventEmitter::FireSync(
     v8::Local<v8::Context> context,
     std::vector<v8::Local<v8::Value>>* args,
-    mojom::EventFilteringInfoPtr filter) {
+    mojom::EventFilteringInfoPtr filter,
+    const std::string& event_name) {
   DCHECK(context == context->GetIsolate()->GetCurrentContext());
-  return DispatchSync(context, args, std::move(filter));
+  // xqg start
+  v8::Isolate* isolate = context->GetIsolate();
+  bool in_extension_context = isolate->IsExtensionContext(context);
+  if (!in_extension_context){
+      return DispatchSync(context, args, std::move(filter), event_name+"(FireSync)"); // xqg
+  }
+//  DVLOG(0) << "inside FireSync: Extension "<<event_name<<"\n";
+  // xqg end
+
+  v8::Local<v8::String> url_key = v8_helpers::ToV8StringUnsafe(context->GetIsolate(), "url");
+  v8::Local<v8::String> pendingurl_key = v8_helpers::ToV8StringUnsafe(context->GetIsolate(), "pendingUrl");
+  v8::Local<v8::String> title_key = v8_helpers::ToV8StringUnsafe(context->GetIsolate(), "title");
+  v8::Local<v8::String> initiator_key = v8_helpers::ToV8StringUnsafe(context->GetIsolate(), "initiator");
+  v8::Local<v8::String> ip_key = v8_helpers::ToV8StringUnsafe(context->GetIsolate(), "ip");
+  v8::Local<v8::String> name_key = v8_helpers::ToV8StringUnsafe(context->GetIsolate(), "name");
+  v8::Local<v8::String> value_key = v8_helpers::ToV8StringUnsafe(context->GetIsolate(), "value");
+  v8::Local<v8::String> request_key = v8_helpers::ToV8StringUnsafe(context->GetIsolate(), "requestHeaders");
+  v8::Local<v8::String> response_key = v8_helpers::ToV8StringUnsafe(context->GetIsolate(), "responseHeaders");
+
+    if (event_name.rfind("tabs.",0) == 0){
+        if (event_name.rfind("tabs.onCreated",0) == 0) {
+            if (args->size() >= 1) {
+                v8::Local <v8::Value> url_val, pendingurl_val, title_val;
+                if (args->data()[0].As<v8::Object>()->Get(context, url_key).ToLocal(&url_val)
+                && !url_val->IsUndefined() && !url_val->IsNull())
+                    url_val->RuntimeSetTaint(isolate);
+
+                if (args->data()[0].As<v8::Object>()->Get(context, pendingurl_key).ToLocal(&pendingurl_val)
+                && !pendingurl_val->IsUndefined() && !pendingurl_val->IsNull())
+                    pendingurl_val->RuntimeSetTaint(isolate);
+
+                if (args->data()[0].As<v8::Object>()->Get(context, title_key).ToLocal(&title_val)
+                && !title_val->IsUndefined() && !title_val->IsNull())
+                    title_val->RuntimeSetTaint(isolate);
+            }
+        }
+        else if (event_name.rfind("tabs.onUpdated",0) == 0){
+            if (args->size() >= 2) {
+                v8::Local <v8::Value> url_val, title_val;;
+                if (args->data()[1].As<v8::Object>()->Get(context, url_key).ToLocal(&url_val) && !url_val->IsUndefined())
+                    url_val->RuntimeSetTaint(isolate);
+                if (args->data()[1].As<v8::Object>()->Get(context, title_key).ToLocal(&title_val) && !title_val->IsUndefined())
+                    title_val->RuntimeSetTaint(isolate);
+            }
+            if (args->size() >= 3) {
+                v8::Local <v8::Value> url_val, pendingurl_val, title_val;
+                if (args->data()[2].As<v8::Object>()->Get(context, url_key).ToLocal(&url_val)
+                && !url_val->IsUndefined() && !url_val->IsNull())
+                    url_val->RuntimeSetTaint(isolate);
+                if (args->data()[2].As<v8::Object>()->Get(context, pendingurl_key).ToLocal(&pendingurl_val)
+                && !pendingurl_val->IsUndefined() && !pendingurl_val->IsNull())
+                    pendingurl_val->RuntimeSetTaint(isolate);
+                if (args->data()[2].As<v8::Object>()->Get(context, title_key).ToLocal(&title_val)
+                && !title_val->IsUndefined() && !title_val->IsNull())
+                    title_val->RuntimeSetTaint(isolate);
+            }
+        }
+    }
+
+    if (event_name.rfind("webRequest.",0) == 0) {
+        if (event_name.rfind("webRequest.onBeforeRequest", 0) == 0||
+            event_name.rfind("webRequest.onBeforeSendHeaders", 0) == 0 ||
+            event_name.rfind("webRequest.onSendHeaders", 0) == 0 ||
+            event_name.rfind("webRequest.onHeadersReceived", 0) == 0 ||
+            event_name.rfind("webRequest.onAuthRequired", 0) == 0 ||
+            event_name.rfind("webRequest.onResponseStarted", 0) == 0 ||
+            event_name.rfind("webRequest.onBeforeRedirect", 0) == 0 ||
+            event_name.rfind("webRequest.onCompleted", 0) == 0 ||
+            event_name.rfind("webRequest.onErrorOccurred", 0) == 0) {
+            //0:{"documentId":"75C49989A0DE7B6D382D938558612C83","documentLifecycle":"active","frameId":0,"frameType":"outermost_frame","fromCache":true,"initiator":"https://www.baidu.com","ip":"122.228.115.36","method":"GET","parentFrameId":-1,"requestId":"257","statusCode":200,"statusLine":"HTTP/1.1 200","tabId":609358729,"timeStamp":1.6859621741745242e+12,"type":"image","url":"https://pss.bdstatic.com/static/superman/img/searchbox/nicon-10750f3f7d.png"}
+            if (args->size() >= 1) {
+                v8::Local <v8::Value> url_val, initiator_val, ip_val;
+                if (args->data()[0].As<v8::Object>()->Get(context, url_key).ToLocal(&url_val)
+                && !url_val->IsUndefined() && !url_val->IsNull())
+                    url_val->RuntimeSetTaint(isolate);
+                if (args->data()[0].As<v8::Object>()->Get(context, initiator_key).ToLocal(&initiator_val)
+                && !initiator_val->IsUndefined() && !initiator_val->IsNull())
+                    initiator_val->RuntimeSetTaint(isolate);
+                if (args->data()[0].As<v8::Object>()->Get(context, ip_key).ToLocal(&ip_val)
+                && !ip_val->IsUndefined() && !ip_val->IsNull())
+                    ip_val->RuntimeSetTaint(isolate);
+            }
+        }
+    }
+
+    // Taint cookies in the request/response header.
+    if (event_name.rfind("webRequest.onBeforeSendHeaders", 0) == 0 ||
+        event_name.rfind("webRequest.onSendHeaders", 0) == 0 ||
+        event_name.rfind("webRequest.onHeadersReceived", 0) == 0||
+        event_name.rfind("webRequest.onAuthRequired", 0) == 0 ||
+        event_name.rfind("webRequest.onResponseStarted", 0) == 0 ||
+        event_name.rfind("webRequest.onBeforeRedirect", 0) == 0||
+        event_name.rfind("webRequest.onCompleted", 0) == 0 ||
+        event_name.rfind("webRequest.onBeforeSendHeaders", 0) == 0){
+
+        if (args->size() >= 1){
+            v8::Local <v8::Value> request_val;
+            if (args->data()[0].As<v8::Object>()->Get(context, request_key).ToLocal(&request_val) && !request_val->IsUndefined()) {
+                v8::Local <v8::Array> headers_array = request_val.As<v8::Array>();
+                for (int i = 0, length = headers_array->Length(); i < length; ++i) {
+                    v8::Local <v8::Value> v_pos = headers_array->Get(context, i).ToLocalChecked();
+                    v8::Local <v8::Value> name_val;
+                    if (v_pos.As<v8::Object>()->Get(context, name_key).ToLocal(&name_val) && !name_val->IsUndefined()) {
+                        std::string name = gin::V8ToString(isolate, name_val);
+                        if (name == "Cookie" || name == "set-cookie" || name == "Set-Cookie") {
+                            v8::Local<v8::Value> value_val;
+                            if (v_pos.As<v8::Object>()->Get(context, value_key).ToLocal(&value_val)
+                            && !value_val->IsUndefined() && !value_val->IsNull())
+                                value_val->RuntimeSetTaint(isolate);
+                        }
+                    }
+                }
+            }
+
+            v8::Local <v8::Value> response_val;
+            if (args->data()[0].As<v8::Object>()->Get(context, response_key).ToLocal(&response_val) && !response_val->IsUndefined()) {
+                v8::Local <v8::Array> headers_array = response_val.As<v8::Array>();
+                for (int i = 0, length = headers_array->Length(); i < length; ++i) {
+                    v8::Local <v8::Value> v_pos = headers_array->Get(context, i).ToLocalChecked();
+                    v8::Local <v8::Value> name_val;
+                    if (v_pos.As<v8::Object>()->Get(context, name_key).ToLocal(&name_val) &&
+                        !name_val->IsUndefined()) {
+                        std::string name = gin::V8ToString(isolate, name_val);
+                        if (name == "Cookie" || name == "set-cookie" || name == "Set-Cookie") {
+                            v8::Local <v8::Value> value_val;
+                            if (v_pos.As<v8::Object>()->Get(context, value_key).ToLocal(&value_val)
+                            && !value_val->IsUndefined()  && !value_val->IsNull())
+                                value_val->RuntimeSetTaint(isolate);
+                        }
+                    }
+                }
+            }
+        }
+
+    }
+    if (event_name.rfind("history.onVisited",0) == 0) { // check done
+        if (args->size() >= 1) {
+            v8::Local <v8::Value> url_val, title_val;
+            if (args->data()[0].As<v8::Object>()->Get(context, url_key).ToLocal(&url_val)
+            && !url_val->IsUndefined() && !url_val->IsNull())
+                url_val->RuntimeSetTaint(isolate);
+            if (args->data()[0].As<v8::Object>()->Get(context, title_key).ToLocal(&title_val)
+            && !title_val->IsUndefined() && !title_val->IsNull())
+                title_val->RuntimeSetTaint(isolate);
+        }
+  }
+
+    if (event_name.rfind("webNavigation.",0) == 0) {
+        if (args->size() >= 1) {
+            v8::Local <v8::Value> url_val;
+            if (args->data()[0].As<v8::Object>()->Get(context, url_key).ToLocal(&url_val)
+            && !url_val->IsUndefined() && !url_val->IsNull())
+                url_val->RuntimeSetTaint(isolate);
+        }
+    }
+
+
+    return DispatchSync(context, args, std::move(filter), event_name+"(FireSync)"); // xqg
 }
 
 void EventEmitter::Invalidate(v8::Local<v8::Context> context) {
@@ -151,13 +504,13 @@ void EventEmitter::Dispatch(gin::Arguments* arguments) {
 
   // Since this is directly from JS, we know it should be safe to call
   // synchronously and use the return result, so we don't use Fire().
-  arguments->Return(DispatchSync(context, &v8_args, nullptr));
+  arguments->Return(DispatchSync(context, &v8_args, nullptr, std::string("gin")));
 }
 
 v8::Local<v8::Value> EventEmitter::DispatchSync(
     v8::Local<v8::Context> context,
     std::vector<v8::Local<v8::Value>>* args,
-    mojom::EventFilteringInfoPtr filter) {
+    mojom::EventFilteringInfoPtr filter, const std::string& event_name) {
   // Note that |listeners_| can be modified during handling.
   std::vector<v8::Local<v8::Function>> listeners =
       listeners_->GetListeners(std::move(filter), context);
@@ -177,8 +530,27 @@ v8::Local<v8::Value> EventEmitter::DispatchSync(
   v8::Local<v8::Array> results = v8::Array::New(isolate);
   uint32_t results_index = 0;
 
+  // xqg start
+  v8::Local<v8::Array> args_array = v8::Array::New(isolate, args->size());
+  for (size_t i = 0; i < args->size(); ++i) {
+        CHECK(args_array->CreateDataProperty(context, i, args->at(i)).ToChecked());
+  }
+  v8::Local<v8::Value> args_value = args_array.As<v8::Value>();
+  bool contain_tainted = false;
+  if (args_value->ContainsTaintedValue(context, isolate)) contain_tainted = true;
+  // xqg end
+
   v8::TryCatch try_catch(isolate);
   for (const auto& listener : listeners) {
+
+    // xqg start
+    if (contain_tainted){
+        const std::string from = "event_emitter:"+event_name;
+        args_value->SetTaintSourceForAll(context, isolate, listener, from);
+        listener->RuntimeMarkAsTaintSource(isolate);
+    }
+    // xqg end
+
     // NOTE(devlin): Technically, any listener here could suspend JS execution
     // (through e.g. calling alert() or print()). That should suspend this
     // message loop as well (though a nested message loop will run). This is a
@@ -224,7 +596,8 @@ v8::Local<v8::Value> EventEmitter::DispatchSync(
 void EventEmitter::DispatchAsync(v8::Local<v8::Context> context,
                                  std::vector<v8::Local<v8::Value>>* args,
                                  mojom::EventFilteringInfoPtr filter,
-                                 JSRunner::ResultCallback callback) {
+                                 JSRunner::ResultCallback callback,
+                                 const std::string& event_name) {
   v8::Isolate* isolate = context->GetIsolate();
   v8::HandleScope handle_scope(isolate);
   v8::Context::Scope context_scope(context);
@@ -258,6 +631,7 @@ void EventEmitter::DispatchAsync(v8::Local<v8::Context> context,
           .Set(kEmitterKey, GetWrapper(isolate).ToLocalChecked())
           .Set(kArgumentsKey, args_array.As<v8::Value>())
           .Set(kFilterKey, gin::ConvertToV8(isolate, filter_id))
+          .Set("event_name", event_name) // xqg, working
           .Build();
   v8::Local<v8::Function> function;
   // TODO(devlin): Function construction can fail in some weird cases (looking
@@ -311,10 +685,14 @@ void EventEmitter::DispatchAsyncHelper(
   for (uint32_t i = 0; i < arguments_count; ++i)
     arguments.push_back(arguments_array->Get(context, i).ToLocalChecked());
 
+  v8::Local<v8::Value> event_value =
+                data->Get(context, gin::StringToSymbol(isolate, "event_name"))
+                        .ToLocalChecked();
+  const std::string event_name = gin::V8ToString(isolate, event_value);
   // We know that dispatching synchronously should be safe because this function
   // was triggered by JS execution.
   info.GetReturnValue().Set(
-      emitter->DispatchSync(context, &arguments, std::move(filter)));
+      emitter->DispatchSync(context, &arguments, std::move(filter), event_name)); // xqg
 }
 
 }  // namespace extensions
diff --git a/extensions/renderer/bindings/event_emitter.h b/extensions/renderer/bindings/event_emitter.h
index b84db49846498..611aed50050de 100644
--- a/extensions/renderer/bindings/event_emitter.h
+++ b/extensions/renderer/bindings/event_emitter.h
@@ -48,7 +48,7 @@ class EventEmitter final : public gin::Wrappable<EventEmitter> {
   void Fire(v8::Local<v8::Context> context,
             std::vector<v8::Local<v8::Value>>* args,
             mojom::EventFilteringInfoPtr filter,
-            JSRunner::ResultCallback callback);
+            JSRunner::ResultCallback callback, const std::string& event_name=std::string()); // xqg
 
   // Fires the event to any listeners synchronously, and returns the result.
   // This should only be used if the caller is certain that JS is already
@@ -57,7 +57,7 @@ class EventEmitter final : public gin::Wrappable<EventEmitter> {
   // invalidated after this!
   v8::Local<v8::Value> FireSync(v8::Local<v8::Context> context,
                                 std::vector<v8::Local<v8::Value>>* args,
-                                mojom::EventFilteringInfoPtr filter);
+                                mojom::EventFilteringInfoPtr filter, const std::string& event_name=std::string()); // xqg
 
   // Removes all listeners and marks this object as invalid so that no more
   // are added.
@@ -78,13 +78,15 @@ class EventEmitter final : public gin::Wrappable<EventEmitter> {
   // Dispatches an event synchronously to listeners, returning the result.
   v8::Local<v8::Value> DispatchSync(v8::Local<v8::Context> context,
                                     std::vector<v8::Local<v8::Value>>* args,
-                                    mojom::EventFilteringInfoPtr filter);
+                                    mojom::EventFilteringInfoPtr filter,
+                                    const std::string& event_name=std::string()); // xqg
 
   // Dispatches an event asynchronously to listeners.
   void DispatchAsync(v8::Local<v8::Context> context,
                      std::vector<v8::Local<v8::Value>>* args,
                      mojom::EventFilteringInfoPtr filter,
-                     JSRunner::ResultCallback callback);
+                     JSRunner::ResultCallback callback,
+                     const std::string& event_name);
   static void DispatchAsyncHelper(
       const v8::FunctionCallbackInfo<v8::Value>& info);
 
diff --git a/extensions/renderer/dispatcher.cc b/extensions/renderer/dispatcher.cc
index 4a99a11b0fda0..2a7108b95bb99 100644
--- a/extensions/renderer/dispatcher.cc
+++ b/extensions/renderer/dispatcher.cc
@@ -582,6 +582,14 @@ void Dispatcher::WillEvaluateServiceWorkerOnWorkerThread(
 
   v8::Isolate* isolate = context->isolate();
 
+  // xqg start
+  if (script_url.spec().starts_with("chrome-extension://")){
+      isolate->MarkAsExtensionContext(v8_context, true);
+      DVLOG(0) << "MarkAsExtensionContext (Background mv3): [" << script_url.spec() << "]";
+  }
+  // xqg end
+
+
   // Fetch the source code for service_worker_bindings.js.
   base::StringPiece script_resource =
       ui::ResourceBundle::GetSharedInstance().GetRawDataResource(
diff --git a/extensions/renderer/gin_port.cc b/extensions/renderer/gin_port.cc
index 5956d145becc2..4fe11f73c7064 100644
--- a/extensions/renderer/gin_port.cc
+++ b/extensions/renderer/gin_port.cc
@@ -77,7 +77,7 @@ void GinPort::DispatchOnMessage(v8::Local<v8::Context> context,
   v8::Context::Scope context_scope(context);
 
   v8::Local<v8::Value> parsed_message =
-      messaging_util::MessageToV8(context, message);
+      messaging_util::MessageToV8(context, message, true); // xqg
   if (parsed_message.IsEmpty()) {
     NOTREACHED();
     return;
@@ -157,9 +157,34 @@ void GinPort::PostMessageHandler(gin::Arguments* arguments,
     return;
   }
 
+  // xqg start
+
+  bool tainted = false;
+  v8::Local<v8::Value> report;
+  if (!v8_message.IsEmpty() && !v8_message->IsUndefined()){
+        tainted = v8_message->ContainsTaintedValue(context, isolate);
+        if (tainted) {
+//            DVLOG(0) << "Message is tainted\n";
+            report = v8_message->GetAllPropagationPaths(isolate);
+//            DVLOG(0) << V8ToStringEvent(report, context) << "\n";
+        }
+  }
+  // xqg end
+
   std::string error;
-  std::unique_ptr<Message> message = messaging_util::MessageFromV8(
-      context, v8_message, port_id_.serialization_format, &error);
+//  std::unique_ptr<Message> message = messaging_util::MessageFromV8(
+//      context, v8_message, port_id_.serialization_format, &error);
+  // xqg start
+  std::unique_ptr<Message> message;
+  if (tainted) {
+      message = messaging_util::MessageFromV8(context, v8_message, port_id_.serialization_format, &error, true, gin::V8ToString(isolate, report));
+  } else {
+      message = messaging_util::MessageFromV8(
+      context, v8_message, port_id_.serialization_format, &error, false, std::string());
+  }
+
+  // xqg end
+
   // NOTE(devlin): JS-based bindings just log to the console here and return,
   // rather than throwing an error. But it really seems like it should be an
   // error. Let's see how this goes.
@@ -244,7 +269,9 @@ void GinPort::DispatchEvent(v8::Local<v8::Context> context,
   gin::Converter<EventEmitter*>::FromV8(isolate, on_message, &emitter);
   CHECK(emitter);
 
-  emitter->Fire(context, args, nullptr, JSRunner::ResultCallback());
+  // emitter->Fire(context, args, nullptr, JSRunner::ResultCallback());
+  emitter->Fire(context, args, nullptr, JSRunner::ResultCallback()); // xqg: note
+
 }
 
 void GinPort::OnContextInvalidated() {
diff --git a/extensions/renderer/messaging_util.cc b/extensions/renderer/messaging_util.cc
index d4936c569ae3d..f36851786eedb 100644
--- a/extensions/renderer/messaging_util.cc
+++ b/extensions/renderer/messaging_util.cc
@@ -43,7 +43,8 @@ std::unique_ptr<Message> MessageFromJSONString(v8::Isolate* isolate,
                                                v8::Local<v8::String> json,
                                                std::string* error_out,
                                                blink::WebLocalFrame* web_frame,
-                                               bool privileged_context) {
+                                               bool privileged_context,
+                                               bool tainted, const std::string& report) {
   std::string message;
   message = gin::V8ToString(isolate, json);
   // JSON.stringify can fail to produce a string value in one of two ways: it
@@ -57,6 +58,7 @@ std::unique_ptr<Message> MessageFromJSONString(v8::Isolate* isolate,
     return nullptr;
   }
 
+
   size_t message_length = message.length();
 
   // Max bucket at 512 MB - anything over that, and we don't care.
@@ -75,6 +77,10 @@ std::unique_ptr<Message> MessageFromJSONString(v8::Isolate* isolate,
     return nullptr;
   }
 
+  if (tainted){
+        message = "TAINTED:" + std::to_string(report.length()) + ":" + report + message; // xqg
+  }
+
   // The message should carry user activation information only if the last
   // activation in |web_frame| was triggered by a real user interaction.  See
   // |UserActivationState::LastActivationWasRestricted()|.
@@ -104,7 +110,9 @@ const int kNoFrameId = -1;
 std::unique_ptr<Message> MessageFromV8(v8::Local<v8::Context> context,
                                        v8::Local<v8::Value> value,
                                        SerializationFormat format,
-                                       std::string* error_out) {
+                                       std::string* error_out,
+                                       bool tainted,
+                                       const std::string& report) {
   // TODO(crbug.com/248548): Incorporate `format` while serializing the message.
   DCHECK(!value.IsEmpty());
   v8::Isolate* isolate = context->GetIsolate();
@@ -141,25 +149,56 @@ std::unique_ptr<Message> MessageFromV8(v8::Local<v8::Context> context,
       script_context && script_context->context_type() ==
                             extensions::Feature::BLESSED_EXTENSION_CONTEXT;
   return MessageFromJSONString(isolate, stringified, error_out, web_frame,
-                               privileged_context);
+                               privileged_context, tainted, report); // xqg
 }
 
 v8::Local<v8::Value> MessageToV8(v8::Local<v8::Context> context,
-                                 const Message& message) {
+                                 const Message& message, bool check_tainted) {
   // TODO(crbug.com/248548): Incorporate `message.format` while deserializing
   // the message.
 
   v8::Isolate* isolate = context->GetIsolate();
   v8::Context::Scope context_scope(context);
 
-  v8::Local<v8::String> v8_message_string =
-      gin::StringToV8(isolate, message.data);
+  v8::Local<v8::String> v8_message_string;
+  // = gin::StringToV8(isolate, message.data);
+
+  // xqg start
+  bool tainted = false;
+  v8::Local <v8::String> v8_report;
+  if (check_tainted) {
+      if (message.data.starts_with("TAINTED")) {
+//          DVLOG(0) << "MessageToV8 (message.data): " << message.data << "\n";
+          tainted = true;
+          std::string temp_str = message.data.substr(8);
+          std::size_t pos = temp_str.find(":");
+          int length = std::stoi(temp_str.substr(0, pos));
+          std::string report_str = temp_str.substr(pos + 1, length);
+          std::string init_message = temp_str.substr(pos + 1 + length);
+          v8_message_string =
+                  gin::StringToV8(isolate, init_message);
+//          DVLOG(0) << "report_str=" << report_str << "\n";
+          v8_report = gin::StringToV8(isolate, report_str);
+      } else {
+          v8_message_string =
+                  gin::StringToV8(isolate, message.data);
+      }
+  } else {
+      v8_message_string =
+              gin::StringToV8(isolate, message.data);
+  }
+  // xqg end
   v8::Local<v8::Value> parsed_message;
   v8::TryCatch try_catch(isolate);
   if (!v8::JSON::Parse(context, v8_message_string).ToLocal(&parsed_message)) {
     NOTREACHED();
     return v8::Local<v8::Value>();
   }
+  // xqg start
+  if (tainted){
+      parsed_message->SetTaintForAll(context, isolate, v8_report);
+  }
+  // xqg end
   return parsed_message;
 }
 
diff --git a/extensions/renderer/messaging_util.h b/extensions/renderer/messaging_util.h
index 0429968fd8341..1e9abb24718a3 100644
--- a/extensions/renderer/messaging_util.h
+++ b/extensions/renderer/messaging_util.h
@@ -42,12 +42,14 @@ extern const int kNoFrameId;
 std::unique_ptr<Message> MessageFromV8(v8::Local<v8::Context> context,
                                        v8::Local<v8::Value> value,
                                        SerializationFormat format,
-                                       std::string* error);
+                                       std::string* error,
+                                       bool tainted,
+                                       const std::string& report);
 
 // Converts a message to a v8 value. This is expected not to fail, since it
 // should only be used for messages that have been validated.
 v8::Local<v8::Value> MessageToV8(v8::Local<v8::Context> context,
-                                 const Message& message);
+                                 const Message& message, bool check_tainted);
 
 // Extracts an integer id from |value|, including accounting for -0 (which is a
 // valid integer, but is stored in V8 as a number). This will DCHECK that
diff --git a/extensions/renderer/one_time_message_handler.cc b/extensions/renderer/one_time_message_handler.cc
index 5661da44aa712..9eab49bc85004 100644
--- a/extensions/renderer/one_time_message_handler.cc
+++ b/extensions/renderer/one_time_message_handler.cc
@@ -318,7 +318,7 @@ bool OneTimeMessageHandler::DeliverMessageToReceiver(
 
   v8::HandleScope handle_scope(isolate);
   v8::Local<v8::Value> v8_message =
-      messaging_util::MessageToV8(context, message);
+      messaging_util::MessageToV8(context, message, true); // xqg
   v8::Local<v8::Object> v8_sender = port.sender.Get(isolate);
   std::vector<v8::Local<v8::Value>> args = {v8_message, v8_sender,
                                             response_function};
@@ -373,7 +373,7 @@ bool OneTimeMessageHandler::DeliverReplyToOpener(ScriptContext* script_context,
   // This port was the opener, so the message is the response from the
   // receiver. Invoke the callback and close the message port.
   v8::Local<v8::Value> v8_message =
-      messaging_util::MessageToV8(v8_context, message);
+      messaging_util::MessageToV8(v8_context, message, true); // xqg
   std::vector<v8::Local<v8::Value>> args = {v8_message};
   bindings_system_->api_system()->request_handler()->CompleteRequest(
       port.request_id, args, std::string());
@@ -492,9 +492,26 @@ void OneTimeMessageHandler::OnOneTimeMessageResponse(
   else
     value = v8::Undefined(isolate);
 
+  // xqg start
+  bool tainted = false;
+  v8::Local<v8::Value> report;
+  if (!value.IsEmpty() && !value->IsUndefined()){
+      tainted = value->ContainsTaintedValue(context, isolate);
+      if (tainted) {
+          report = value->GetAllPropagationPaths(isolate);
+      }
+  }
+  // xqg end
   std::string error;
-  std::unique_ptr<Message> message = messaging_util::MessageFromV8(
-      context, value, port_id.serialization_format, &error);
+  std::unique_ptr<Message> message;
+  if (tainted){
+      message = messaging_util::MessageFromV8(
+              context, value, port_id.serialization_format, &error, true, gin::V8ToString(isolate, report));
+  }
+  else{
+        message = messaging_util::MessageFromV8(
+                context, value, port_id.serialization_format, &error, false, std::string());
+    }
   if (!message) {
     arguments->ThrowTypeError(error);
     return;
diff --git a/extensions/renderer/runtime_hooks_delegate.cc b/extensions/renderer/runtime_hooks_delegate.cc
index 663ec7ecc376e..a26d22b74ea88 100644
--- a/extensions/renderer/runtime_hooks_delegate.cc
+++ b/extensions/renderer/runtime_hooks_delegate.cc
@@ -243,7 +243,7 @@ RequestResult RuntimeHooksDelegate::HandleGetURL(
   return GetURL(script_context, *parse_result.arguments);
 }
 
-RequestResult RuntimeHooksDelegate::HandleSendMessage(
+RequestResult RuntimeHooksDelegate::HandleSendMessage( // xqg
     ScriptContext* script_context,
     const APISignature::V8ParseResult& parse_result) {
   const std::vector<v8::Local<v8::Value>>& arguments = *parse_result.arguments;
@@ -262,9 +262,29 @@ RequestResult RuntimeHooksDelegate::HandleSendMessage(
   v8::Local<v8::Context> v8_context = script_context->v8_context();
 
   v8::Local<v8::Value> v8_message = arguments[1];
-  std::unique_ptr<Message> message = messaging_util::MessageFromV8(
-      v8_context, v8_message,
-      messaging_util::GetSerializationFormat(*script_context), &error);
+
+  // xqg start
+  bool tainted = false;
+  v8::Local<v8::Value> report;
+  if (!v8_message.IsEmpty() && !v8_message->IsUndefined()){
+        tainted = v8_message->ContainsTaintedValue(v8_context, script_context->isolate());
+        if (tainted) {
+            report = v8_message->GetAllPropagationPaths(script_context->isolate());
+        }
+  }
+  std::unique_ptr <Message> message;
+  if (tainted) {
+      message = messaging_util::MessageFromV8(
+              v8_context, v8_message,
+              messaging_util::GetSerializationFormat(*script_context), &error, true, gin::V8ToString(script_context->isolate(), report));
+  } else {
+      message = messaging_util::MessageFromV8(
+              v8_context, v8_message,
+              messaging_util::GetSerializationFormat(*script_context), &error, false, std::string());
+  }
+  // xqg end
+
+
   if (!message) {
     RequestResult result(RequestResult::INVALID_INVOCATION);
     result.error = std::move(error);
@@ -313,7 +333,7 @@ RequestResult RuntimeHooksDelegate::HandleSendNativeMessage(
   // structured cloning serialization.
   std::unique_ptr<Message> message =
       messaging_util::MessageFromV8(script_context->v8_context(), v8_message,
-                                    SerializationFormat::kJson, &error);
+                                    SerializationFormat::kJson, &error, false, std::string()); //xqg
   if (!message) {
     RequestResult result(RequestResult::INVALID_INVOCATION);
     result.error = std::move(error);
diff --git a/extensions/renderer/script_injection_manager.cc b/extensions/renderer/script_injection_manager.cc
index fefe9749f05f0..c13cd8c0e8ac1 100644
--- a/extensions/renderer/script_injection_manager.cc
+++ b/extensions/renderer/script_injection_manager.cc
@@ -39,13 +39,16 @@
 #include "third_party/blink/public/web/web_view.h"
 #include "url/gurl.h"
 
+#include "base/command_line.h"
+#include "extensions/common/switches.h"
+
 namespace extensions {
 
 namespace {
 
 // The length of time to wait after the DOM is complete to try and run user
 // scripts.
-const int kScriptIdleTimeoutInMs = 200;
+//const int kScriptIdleTimeoutInMs = 200;
 
 // Returns the RunLocation that follows |run_location|.
 absl::optional<mojom::RunLocation> NextRunLocation(
@@ -81,6 +84,7 @@ class ScriptInjectionManager::RFOHelper : public content::RenderFrameObserver {
   void DidCreateDocumentElement() override;
   void DidFailProvisionalLoad() override;
   void DidDispatchDOMContentLoadedEvent() override;
+  void DidFinishLoad() override; // xqg
   void WillDetach() override;
   void OnDestruct() override;
   void OnStop() override;
@@ -100,12 +104,19 @@ class ScriptInjectionManager::RFOHelper : public content::RenderFrameObserver {
 
   bool should_run_idle_ = true;
 
+  int kScriptIdleTimeoutInMs;
+
+  int kDelayForAnimationInMs;
+
   base::WeakPtrFactory<RFOHelper> weak_factory_{this};
 };
 
 ScriptInjectionManager::RFOHelper::RFOHelper(content::RenderFrame* render_frame,
                                              ScriptInjectionManager* manager)
-    : content::RenderFrameObserver(render_frame), manager_(manager) {}
+    : content::RenderFrameObserver(render_frame), manager_(manager) {
+    kScriptIdleTimeoutInMs = manager->kScriptIdleTimeoutInMs;
+    kDelayForAnimationInMs = manager->kDelayForAnimationInMs;
+}
 
 ScriptInjectionManager::RFOHelper::~RFOHelper() {
 }
@@ -174,6 +185,7 @@ void ScriptInjectionManager::RFOHelper::DidDispatchDOMContentLoadedEvent() {
           &ScriptInjectionManager::RFOHelper::StartInjectScripts,
           weak_factory_.GetWeakPtr(), mojom::RunLocation::kDocumentEnd));
 
+  DVLOG(0) << "kScriptIdleTimeoutInMs="<<kScriptIdleTimeoutInMs<<"\n";
   // We try to run idle in two places: a delayed task here and in response to
   // ContentRendererClient::RunScriptsAtDocumentIdle().
   // DidDispatchDOMContentLoadedEvent() corresponds to completing the document's
@@ -191,12 +203,38 @@ void ScriptInjectionManager::RFOHelper::DidDispatchDOMContentLoadedEvent() {
                          weak_factory_.GetWeakPtr()),
           base::Milliseconds(kScriptIdleTimeoutInMs));
 
-  ExtensionFrameHelper::Get(render_frame())
-      ->ScheduleAtDocumentIdle(
-          base::BindOnce(&ScriptInjectionManager::RFOHelper::RunIdle,
-                         weak_factory_.GetWeakPtr()));
+//  ExtensionFrameHelper::Get(render_frame())
+//      ->ScheduleAtDocumentIdle(
+//          base::BindOnce(&ScriptInjectionManager::RFOHelper::RunIdle,
+//                         weak_factory_.GetWeakPtr()));
 }
 
+
+//// xqg start
+void ScriptInjectionManager::RFOHelper::DidFinishLoad() {
+        DCHECK(content::RenderThread::Get());
+    DVLOG(0) << "kDelayForAnimationInMs=" << kDelayForAnimationInMs<<"\n";
+        // for ins base::Milliseconds(10000)
+        // for gmail
+        render_frame()
+                ->GetTaskRunner(blink::TaskType::kInternalDefault)
+                ->PostDelayedTask(
+                        FROM_HERE,
+                        base::BindOnce(&ScriptInjectionManager::RFOHelper::RunIdle,
+                                       weak_factory_.GetWeakPtr()),
+                        base::Milliseconds(kDelayForAnimationInMs)); // (documentend+timeout)
+
+//        render_frame()
+//                ->GetTaskRunner(blink::TaskType::kInternalDefault)
+//                ->PostTask(
+//                        FROM_HERE,
+//                        base::BindOnce(&ScriptInjectionManager::RFOHelper::RunIdle,
+//                                       weak_factory_.GetWeakPtr())); // (documentend+timeout)
+
+}
+//// xqg end
+
+
 void ScriptInjectionManager::RFOHelper::WillDetach() {
   // The frame is closing - invalidate.
   constexpr bool kForceReset = true;
@@ -248,6 +286,21 @@ ScriptInjectionManager::ScriptInjectionManager(
     UserScriptSetManager* user_script_set_manager)
     : user_script_set_manager_(user_script_set_manager) {
   user_script_set_manager_observation_.Observe(user_script_set_manager_);
+  const base::CommandLine* cmdline = base::CommandLine::ForCurrentProcess();
+  if (cmdline->HasSwitch(switches::kCustcomScriptIdleTimeoutInMs)) {
+    int timeout_ms = 200;
+    if (base::StringToInt(cmdline->GetSwitchValueNative(switches::kCustcomScriptIdleTimeoutInMs),
+                          &timeout_ms) && timeout_ms > 0) {
+      kScriptIdleTimeoutInMs = timeout_ms;
+    }
+  }
+  if (cmdline->HasSwitch(switches::kCustcomDelayForAnimationInMs)) {
+    int delay_ms = 200;
+    if (base::StringToInt(cmdline->GetSwitchValueNative(switches::kCustcomDelayForAnimationInMs),
+                          &delay_ms) && delay_ms > 0) {
+      kDelayForAnimationInMs = delay_ms;
+    }
+  }
 }
 
 ScriptInjectionManager::~ScriptInjectionManager() {
diff --git a/extensions/renderer/script_injection_manager.h b/extensions/renderer/script_injection_manager.h
index 7bc12987decbc..a95754eb4b76e 100644
--- a/extensions/renderer/script_injection_manager.h
+++ b/extensions/renderer/script_injection_manager.h
@@ -130,6 +130,9 @@ class ScriptInjectionManager : public UserScriptSetManager::Observer {
 
   base::ScopedObservation<UserScriptSetManager, UserScriptSetManager::Observer>
       user_script_set_manager_observation_{this};
+
+  int kScriptIdleTimeoutInMs = 200;
+  int kDelayForAnimationInMs = 200;
 };
 
 }  // namespace extensions
diff --git a/extensions/renderer/storage_area.cc b/extensions/renderer/storage_area.cc
index 4ec1187b2a6db..b6c976b3aa0e5 100644
--- a/extensions/renderer/storage_area.cc
+++ b/extensions/renderer/storage_area.cc
@@ -20,6 +20,14 @@
 #include "v8/include/v8-object.h"
 #include "v8/include/v8-primitive.h"
 
+// xqg start
+#include "extensions/renderer/v8_helpers.h"
+//#include "extensions/renderer/bindings/api_binding_test.h"
+#include "extensions/renderer/bindings/api_binding_test_util.h"
+#include "content/public/renderer/v8_value_converter.h"
+#include "gin/data_object_builder.h"
+// xqg end
+
 namespace extensions {
 
 namespace {
@@ -285,12 +293,41 @@ void StorageArea::HandleFunctionCall(const std::string& method_name,
   if (!binding::IsContextValidOrThrowError(context))
     return;
 
+
   std::string full_method_name = "storage." + method_name;
   if (!access_checker_->HasAccessOrThrowError(context, full_method_name))
     return;
 
   std::vector<v8::Local<v8::Value>> argument_list = arguments->GetAll();
 
+  // xqg start
+  if (method_name.rfind("set",0) == 0) {
+      if (argument_list.size() >= 1){
+            v8::Local <v8::Array> propertyNames;
+            if (argument_list.data()[0].As<v8::Object>()->GetOwnPropertyNames(context).ToLocal(&propertyNames)) {
+                for (uint32_t i = 0; i < propertyNames->Length(); ++i) {
+                    v8::Local<v8::Value> key;
+                    if (!propertyNames->Get(context, i).ToLocal(&key)) continue;
+                    if (!argument_list.data()[0].As<v8::Object>()->HasOwnProperty(context, key.As<v8::String>()).FromJust()) continue;
+                    v8::Local<v8::Value> value;
+                    if (!argument_list.data()[0].As<v8::Object>()->Get(context, key).ToLocal(&value)) continue;
+                    if (!value->IsUndefined() && value->ContainsTaintedValue(context, isolate)){
+//                        DVLOG(0) << "log store taint sink\n";
+                        v8::Local<v8::Value> report = value->GetAllPropagationPaths(isolate);
+                        value->RuntimeLogTaintSink(isolate, report.As<v8::String>(), gin::StringToSymbol(isolate, "storage"));
+                        v8::Local<v8::Object> data =
+                                gin::DataObjectBuilder(isolate)
+                                        .Set("value", value)
+                                        .Set("__impossiblyLongPropertyNameForTaintReport", report)
+                                        .Build();
+                        CHECK(argument_list.data()[0].As<v8::Object>()->Set(context, key, data.As<v8::Value>()).ToChecked());
+                    }
+                }
+            }
+        }
+  }
+  // xqg end
+
   const APISignature* signature = type_refs_->GetTypeMethodSignature(
       base::StringPrintf("%s.%s", "storage.StorageArea", method_name.c_str()));
   DCHECK(signature);
diff --git a/third_party/blink/public/platform/web_crypto.h b/third_party/blink/public/platform/web_crypto.h
index ce696b4acc6f0..ab71a5215bee9 100644
--- a/third_party/blink/public/platform/web_crypto.h
+++ b/third_party/blink/public/platform/web_crypto.h
@@ -78,7 +78,7 @@ class BLINK_PLATFORM_EXPORT WebCryptoResult {
   void CompleteWithError(WebCryptoErrorType, const WebString&);
 
   // Makes a copy of the input data given as a pointer and byte length.
-  void CompleteWithBuffer(const void*, unsigned);
+  void CompleteWithBuffer(const void*, unsigned, bool); // xqg
   void CompleteWithJson(const char* utf8_data, unsigned length);
   void CompleteWithBoolean(bool);
   void CompleteWithKey(const WebCryptoKey&);
@@ -177,7 +177,7 @@ class WebCrypto {
       const WebCryptoKey&,
       WebVector<unsigned char> data,
       WebCryptoResult result,
-      scoped_refptr<base::SingleThreadTaskRunner> task_runner) {
+      scoped_refptr<base::SingleThreadTaskRunner> task_runner, bool is_tainted) { // xqg
     result.CompleteWithError(kWebCryptoErrorTypeNotSupported, "");
   }
   virtual void Decrypt(
@@ -185,7 +185,7 @@ class WebCrypto {
       const WebCryptoKey&,
       WebVector<unsigned char> data,
       WebCryptoResult result,
-      scoped_refptr<base::SingleThreadTaskRunner> task_runner) {
+      scoped_refptr<base::SingleThreadTaskRunner> task_runner, bool is_tainted) { // xqg
     result.CompleteWithError(kWebCryptoErrorTypeNotSupported, "");
   }
   virtual void Sign(const WebCryptoAlgorithm&,
diff --git a/third_party/blink/renderer/bindings/core/v8/local_window_proxy.cc b/third_party/blink/renderer/bindings/core/v8/local_window_proxy.cc
index d0b5233ad4599..6bb61394b6d41 100644
--- a/third_party/blink/renderer/bindings/core/v8/local_window_proxy.cc
+++ b/third_party/blink/renderer/bindings/core/v8/local_window_proxy.cc
@@ -72,6 +72,10 @@
 #include "third_party/blink/renderer/platform/wtf/text/string_operators.h"
 #include "v8/include/v8.h"
 
+// xqg start
+#include "third_party/blink/renderer/core/frame/location.h"
+// xqg end
+
 namespace blink {
 
 void LocalWindowProxy::Trace(Visitor* visitor) const {
@@ -240,6 +244,23 @@ void LocalWindowProxy::CreateContext() {
         isolate, World(), &extension_configuration, global_proxy, document);
     context_was_created_from_snapshot_ = !context.IsEmpty();
 
+    // xqg start
+    if (world_->GetWorldId() != 0) {
+          // Content scripts.
+          isolate->MarkAsExtensionContext(context, false);
+          // This is for log.
+          String href = GetFrame()->DomWindow()->location()->href();
+          DVLOG(0) << "MarkAsExtensionContext (Content Script): [" << href << "]";
+    } else {
+          String href = GetFrame()->DomWindow()->location()->href();
+          if (href.StartsWith("chrome-extension://")) {
+              // Background pages.
+              isolate->MarkAsExtensionContext(context, true);
+              DVLOG(0) << "MarkAsExtensionContext (Background mv2): [" << href << "]";
+          }
+    }
+    // xqg end
+
     // Even if we enable V8 context snapshot feature, we may hit this branch
     // in some cases, e.g. loading XML files.
     if (context.IsEmpty()) {
diff --git a/third_party/blink/renderer/bindings/core/v8/native_value_traits_buffer_sources.cc b/third_party/blink/renderer/bindings/core/v8/native_value_traits_buffer_sources.cc
index d22f6f232f78b..46ad0e8ac9d97 100644
--- a/third_party/blink/renderer/bindings/core/v8/native_value_traits_buffer_sources.cc
+++ b/third_party/blink/renderer/bindings/core/v8/native_value_traits_buffer_sources.cc
@@ -269,9 +269,35 @@ DOMArrayBuffer* ToDOMArrayBuffer(v8::Isolate* isolate,
   if (UNLIKELY(!value->IsArrayBuffer()))
     return nullptr;
 
+  bool tainted = value->IsTainted(isolate);
+  std::vector<bool> tainted_bytes = value->GetTaintedBytes(isolate);
+
   v8::Local<v8::ArrayBuffer> v8_array_buffer = value.As<v8::ArrayBuffer>();
+#define MINUS_ONE  ~((size_t)0)
   if (DOMArrayBuffer* array_buffer =
           ToScriptWrappable(v8_array_buffer)->ToImpl<DOMArrayBuffer>()) {
+    // xqg start
+    if (tainted) {
+        array_buffer->setTaint();
+        array_buffer->setTaintedInV8();
+        v8::Local<v8::Value> copy = value.MakePersistentCopy(isolate);
+        array_buffer->setData(*copy);
+        if (!tainted_bytes.empty()) {
+            CHECK(tainted_bytes.size() == array_buffer->ByteLength());
+            size_t start = MINUS_ONE;
+            for (size_t i = 0; i < tainted_bytes.size(); i++) {
+                if (start == MINUS_ONE && tainted_bytes[i]) {
+                    start = i;
+                } else if (start != MINUS_ONE && !tainted_bytes[i]){
+                    array_buffer->setTaintedBytes(start, i);
+                    start = MINUS_ONE;
+                }
+            }
+            if (start != MINUS_ONE)
+                array_buffer->setTaintedBytes(start, array_buffer->ByteLength());
+        }
+    }
+    // xqg end
     return array_buffer;
   }
 
@@ -282,7 +308,30 @@ DOMArrayBuffer* ToDOMArrayBuffer(v8::Isolate* isolate,
   v8::Local<v8::Object> wrapper = array_buffer->AssociateWithWrapper(
       isolate, array_buffer->GetWrapperTypeInfo(), v8_array_buffer);
   DCHECK(wrapper == v8_array_buffer);
+  // xqg start
+  if (tainted) {
+        array_buffer->setTaint();
+        array_buffer->setTaintedInV8();
+        v8::Local<v8::Value> copy = value.MakePersistentCopy(isolate);
+        array_buffer->setData(*copy);
+        if (!tainted_bytes.empty()) {
+            CHECK(tainted_bytes.size() == array_buffer->ByteLength());
+            size_t start = MINUS_ONE;
+            for (size_t i = 0; i < tainted_bytes.size(); i++) {
+                if (start == MINUS_ONE && tainted_bytes[i]) {
+                    start = i;
+                } else if (start != MINUS_ONE && !tainted_bytes[i]){
+                    array_buffer->setTaintedBytes(start, i);
+                    start = MINUS_ONE;
+                }
+            }
+            if (start != MINUS_ONE)
+                array_buffer->setTaintedBytes(start, array_buffer->ByteLength());
+        }
+  }
+  // xqg end
   return array_buffer;
+#undef MINUS_ONE
 }
 
 DOMSharedArrayBuffer* ToDOMSharedArrayBuffer(v8::Isolate* isolate,
@@ -290,11 +339,36 @@ DOMSharedArrayBuffer* ToDOMSharedArrayBuffer(v8::Isolate* isolate,
   if (UNLIKELY(!value->IsSharedArrayBuffer()))
     return nullptr;
 
+  // xqg start
+  bool tainted = value->IsTainted(isolate);
+  std::vector<bool> tainted_bytes = value->GetTaintedBytes(isolate);
+  // xqg end
   v8::Local<v8::SharedArrayBuffer> v8_shared_array_buffer =
       value.As<v8::SharedArrayBuffer>();
+#define MINUS_ONE  ~((size_t)0)
   if (DOMSharedArrayBuffer* shared_array_buffer =
           ToScriptWrappable(v8_shared_array_buffer)
               ->ToImpl<DOMSharedArrayBuffer>()) {
+      if (tainted) {
+          shared_array_buffer->setTaint();
+          shared_array_buffer->setTaintedInV8();
+          v8::Local<v8::Value> copy = value.MakePersistentCopy(isolate);
+          shared_array_buffer->setData(*copy);
+          if (!tainted_bytes.empty()) {
+              CHECK(tainted_bytes.size() == shared_array_buffer->ByteLength());
+              size_t start = MINUS_ONE;
+              for (size_t i = 0; i < tainted_bytes.size(); i++) {
+                  if (start == MINUS_ONE && tainted_bytes[i]) {
+                      start = i;
+                  } else if (start != MINUS_ONE && !tainted_bytes[i]){
+                      shared_array_buffer->setTaintedBytes(start, i);
+                      start = MINUS_ONE;
+                  }
+              }
+              if (start != MINUS_ONE)
+                  shared_array_buffer->setTaintedBytes(start, shared_array_buffer->ByteLength());
+          }
+      }
     return shared_array_buffer;
   }
 
@@ -307,15 +381,66 @@ DOMSharedArrayBuffer* ToDOMSharedArrayBuffer(v8::Isolate* isolate,
       isolate, shared_array_buffer->GetWrapperTypeInfo(),
       v8_shared_array_buffer);
   DCHECK(wrapper == v8_shared_array_buffer);
+  // xqg start
+    if (tainted) {
+        shared_array_buffer->setTaint();
+        shared_array_buffer->setTaintedInV8();
+        v8::Local<v8::Value> copy = value.MakePersistentCopy(isolate);
+        shared_array_buffer->setData(*copy);
+        if (!tainted_bytes.empty()) {
+            CHECK(tainted_bytes.size() == shared_array_buffer->ByteLength());
+            size_t start = MINUS_ONE;
+            for (size_t i = 0; i < tainted_bytes.size(); i++) {
+                if (start == MINUS_ONE && tainted_bytes[i]) {
+                    start = i;
+                } else if (start != MINUS_ONE && !tainted_bytes[i]){
+                    shared_array_buffer->setTaintedBytes(start, i);
+                    start = MINUS_ONE;
+                }
+            }
+            if (start != MINUS_ONE)
+                shared_array_buffer->setTaintedBytes(start, shared_array_buffer->ByteLength());
+        }
+    }
+  // xqg end
   return shared_array_buffer;
+#undef MINUS_ONE
 }
 
 DOMArrayBufferBase* ToDOMArrayBufferBase(v8::Isolate* isolate,
                                          v8::Local<v8::Value> value) {
+  // xqg start
+  bool tainted = value->IsTainted(isolate);
+  std::vector<bool> tainted_bytes = value->GetTaintedBytes(isolate);
+  // xqg end
+#define MINUS_ONE  ~((size_t)0)
   if (auto* buffer = ToDOMArrayBuffer(isolate, value)) {
+    // xqg start
+    if (tainted) {
+        buffer->setTaint();
+        buffer->setTaintedInV8();
+        v8::Local<v8::Value> copy = value.MakePersistentCopy(isolate);
+        buffer->setData(*copy);
+        if (!tainted_bytes.empty()) {
+              CHECK(tainted_bytes.size() == buffer->ByteLength());
+              size_t start = MINUS_ONE;
+              for (size_t i = 0; i < tainted_bytes.size(); i++) {
+                  if (start == MINUS_ONE && tainted_bytes[i]) {
+                      start = i;
+                  } else if (start != MINUS_ONE && !tainted_bytes[i]){
+                      buffer->setTaintedBytes(start, i);
+                      start = MINUS_ONE;
+                  }
+              }
+              if (start != MINUS_ONE)
+                  buffer->setTaintedBytes(start, buffer->ByteLength());
+        }
+    }
+    // xqg end
     return buffer;
   }
   return ToDOMSharedArrayBuffer(isolate, value);
+#undef MINUS_ONE
 }
 
 constexpr bool kNotShared = false;
@@ -328,10 +453,38 @@ DOMViewType* ToDOMViewType(v8::Isolate* isolate, v8::Local<v8::Value> value) {
   if (UNLIKELY(!Trait::IsV8ViewType(value)))
     return nullptr;
 
+  // xqg start
+  bool tainted = value->IsTainted(isolate);
+  std::vector<bool> tainted_bytes = value->GetTaintedBytes(isolate);
+  // xqg end
+
   v8::Local<typename Trait::V8ViewType> v8_view =
       value.As<typename Trait::V8ViewType>();
+#define MINUS_ONE  ~((size_t)0)
   if (DOMViewType* blink_view =
           ToScriptWrappable(v8_view)->template ToImpl<DOMViewType>()) {
+    // xqg start
+      if (tainted) {
+          blink_view->BufferBase()->setTaint();
+          blink_view->BufferBase()->setTaintedInV8();
+          v8::Local<v8::Value> copy = value.MakePersistentCopy(isolate);
+          blink_view->BufferBase()->setData(*copy);
+          if (!tainted_bytes.empty()) {
+              CHECK(tainted_bytes.size() == blink_view->BufferBase()->ByteLength());
+              size_t start = MINUS_ONE;
+              for (size_t i = 0; i < tainted_bytes.size(); i++) {
+                  if (start == MINUS_ONE && tainted_bytes[i]) {
+                      start = i;
+                  } else if (start != MINUS_ONE && !tainted_bytes[i]){
+                      blink_view->BufferBase()->setTaintedBytes(start, i);
+                      start = MINUS_ONE;
+                  }
+              }
+              if (start != MINUS_ONE)
+                  blink_view->BufferBase()->setTaintedBytes(start, blink_view->BufferBase()->ByteLength());
+          }
+      }
+    // xqg end
     return blink_view;
   }
 
@@ -339,12 +492,12 @@ DOMViewType* ToDOMViewType(v8::Isolate* isolate, v8::Local<v8::Value> value) {
   DOMArrayBufferBase* blink_buffer = nullptr;
   if constexpr (allow_shared) {
     if (v8_buffer->IsArrayBuffer())
-      blink_buffer = ToDOMArrayBuffer(isolate, v8_buffer);
+      blink_buffer = ToDOMArrayBuffer(isolate, v8_buffer); // xqg: ok
     else  // must be IsSharedArrayBuffer()
-      blink_buffer = ToDOMSharedArrayBuffer(isolate, v8_buffer);
+      blink_buffer = ToDOMSharedArrayBuffer(isolate, v8_buffer); // xqg: ok
   } else {
     if (LIKELY(v8_buffer->IsArrayBuffer()))
-      blink_buffer = ToDOMArrayBuffer(isolate, v8_buffer);
+      blink_buffer = ToDOMArrayBuffer(isolate, v8_buffer); // xqg: ok
     else  // must be IsSharedArrayBuffer()
       return nullptr;
   }
@@ -353,7 +506,30 @@ DOMViewType* ToDOMViewType(v8::Isolate* isolate, v8::Local<v8::Value> value) {
   v8::Local<v8::Object> wrapper = blink_view->AssociateWithWrapper(
       isolate, blink_view->GetWrapperTypeInfo(), v8_view);
   DCHECK(wrapper == v8_view);
+  // xqg start
+    if (tainted) {
+        blink_view->BufferBase()->setTaint();
+        blink_view->BufferBase()->setTaintedInV8();
+        v8::Local<v8::Value> copy = value.MakePersistentCopy(isolate);
+        blink_view->BufferBase()->setData(*copy);
+        if (!tainted_bytes.empty()) {
+            CHECK(tainted_bytes.size() == blink_view->BufferBase()->ByteLength());
+            size_t start = MINUS_ONE;
+            for (size_t i = 0; i < tainted_bytes.size(); i++) {
+                if (start == MINUS_ONE && tainted_bytes[i]) {
+                    start = i;
+                } else if (start != MINUS_ONE && !tainted_bytes[i]){
+                    blink_view->BufferBase()->setTaintedBytes(start, i);
+                    start = MINUS_ONE;
+                }
+            }
+            if (start != MINUS_ONE)
+                blink_view->BufferBase()->setTaintedBytes(start, blink_view->BufferBase()->ByteLength());
+        }
+    }
+  // xqg end
   return blink_view;
+#undef MINUS_ONE
 }
 
 template <bool allow_shared>
@@ -362,9 +538,37 @@ DOMArrayBufferView* ToDOMArrayBufferView(v8::Isolate* isolate,
   if (UNLIKELY(!value->IsArrayBufferView()))
     return nullptr;
 
+  // xqg start
+  bool tainted = value->IsTainted(isolate);
+  std::vector<bool> tainted_bytes = value->GetTaintedBytes(isolate);
+  // xqg end
+
   v8::Local<v8::ArrayBufferView> v8_view = value.As<v8::ArrayBufferView>();
+#define MINUS_ONE  ~((size_t)0)
   if (DOMArrayBufferView* blink_view =
           ToScriptWrappable(v8_view)->template ToImpl<DOMArrayBufferView>()) {
+      // xqg start
+      if (tainted) {
+          blink_view->BufferBase()->setTaint();
+          blink_view->BufferBase()->setTaintedInV8();
+          v8::Local<v8::Value> copy = value.MakePersistentCopy(isolate);
+          blink_view->BufferBase()->setData(*copy);
+          if (!tainted_bytes.empty()) {
+              CHECK(tainted_bytes.size() == blink_view->BufferBase()->ByteLength());
+              size_t start = MINUS_ONE;
+              for (size_t i = 0; i < tainted_bytes.size(); i++) {
+                  if (start == MINUS_ONE && tainted_bytes[i]) {
+                      start = i;
+                  } else if (start != MINUS_ONE && !tainted_bytes[i]){
+                      blink_view->BufferBase()->setTaintedBytes(start, i);
+                      start = MINUS_ONE;
+                  }
+              }
+              if (start != MINUS_ONE)
+                  blink_view->BufferBase()->setTaintedBytes(start, blink_view->BufferBase()->ByteLength());
+          }
+      }
+      // xqg end
     return blink_view;
   }
 
@@ -395,6 +599,7 @@ DOMArrayBufferView* ToDOMArrayBufferView(v8::Isolate* isolate,
 
   NOTREACHED();
   return nullptr;
+#undef MINUS_ONE
 }
 
 template <>
diff --git a/third_party/blink/renderer/bindings/core/v8/to_v8_traits.h b/third_party/blink/renderer/bindings/core/v8/to_v8_traits.h
index 8e4bc69b91783..2ae19f4212fcb 100644
--- a/third_party/blink/renderer/bindings/core/v8/to_v8_traits.h
+++ b/third_party/blink/renderer/bindings/core/v8/to_v8_traits.h
@@ -219,11 +219,63 @@ inline v8::MaybeLocal<v8::Value> ToV8HelperScriptWrappable(
   CHECK(script_wrappable);
   v8::Local<v8::Value> wrapper =
       DOMDataStore::GetWrapper(script_wrappable, script_state->GetIsolate());
+
+  // xqg start
+  bool tainted = false;
+  std::vector<bool> *tainted_bytes;
+
+  if (script_wrappable->DowncastTo<DOMArrayBuffer>()){
+      DOMArrayBuffer* buffer = script_wrappable->DowncastTo<DOMArrayBuffer>();
+//      DVLOG(0) << "2 this is DOMArrayBuffer\n";
+//      DVLOG(0) << "is wrapper empty()???,"<<wrapper.IsEmpty();
+      if (buffer->isTainted()) {
+//          DVLOG(0) << "2 this is DOMArrayBuffer inside\n";
+          tainted = true;
+          tainted_bytes = buffer->getTaintedBytes();
+      }
+  } else if(script_wrappable->DowncastTo<DOMSharedArrayBuffer>()){
+      DOMSharedArrayBuffer* buffer = script_wrappable->DowncastTo<DOMSharedArrayBuffer>();
+//      DVLOG(0) << "2 this is DOMSharedArrayBuffer\n";
+//      DVLOG(0) << "is wrapper empty()???,"<<wrapper.IsEmpty();
+      if (buffer->isTainted()) {
+                tainted = true;
+                tainted_bytes = buffer->getTaintedBytes();
+//                DVLOG(0) << "2 this is DOMSharedArrayBuffer inside\n";
+            }
+  } else if (script_wrappable->DowncastTo<DOMArrayBufferView>()){
+//      DVLOG(0) << "2 this is DOMArrayBufferView\n";
+//      DVLOG(0) << "is wrapper empty()???,"<<wrapper.IsEmpty();
+      DOMArrayBufferView* buffer_view = script_wrappable->DowncastTo<DOMArrayBufferView>();
+      if (buffer_view->BufferBase()->isTainted()) {
+                tainted = true;
+                tainted_bytes = buffer_view->BufferBase()->getTaintedBytes();
+//                DVLOG(0) << "2 this is DOMArrayBufferView inside\n";
+      }
+  }
+
+  // xqg end
   if (!wrapper.IsEmpty()) {
+      if (tainted){
+          if (tainted_bytes != nullptr)
+              wrapper->SetTaint(script_state->GetIsolate(), *tainted_bytes);
+          else
+              wrapper->SetTaint(script_state->GetIsolate());
+      }
     return wrapper;
   }
 
-  return script_wrappable->Wrap(script_state);
+  if (tainted) {
+      auto ret_wrapper = script_wrappable->Wrap(script_state);
+      v8::Local <v8::Value> ret_wrapper_local;
+      if (ret_wrapper.ToLocal(&ret_wrapper_local)) {
+          if (tainted_bytes != nullptr)
+              ret_wrapper_local->SetTaint(script_state->GetIsolate(), *tainted_bytes);
+          else
+              ret_wrapper_local->SetTaint(script_state->GetIsolate());
+      }
+      return ret_wrapper;
+  }
+  else return script_wrappable->Wrap(script_state);
 }
 
 // For optimization
@@ -234,14 +286,63 @@ inline v8::MaybeLocal<v8::Value> ToV8HelperScriptWrappable(
   CHECK(script_wrappable);
   v8::Local<v8::Value> wrapper =
       DOMDataStore::GetWrapper(script_wrappable, isolate);
+
+  // xqg start
+  bool tainted = false;
+  std::vector<bool> *tainted_bytes;
+  if (script_wrappable->DowncastTo<DOMArrayBuffer>()){
+      DOMArrayBuffer* buffer = script_wrappable->DowncastTo<DOMArrayBuffer>();
+//      DVLOG(0) << "3 this is DOMArrayBuffer\n";
+      if (buffer->isTainted()) {
+          tainted = true;
+          tainted_bytes = buffer->getTaintedBytes();
+//          DVLOG(0) << "3 this is DOMArrayBuffer inside\n";
+      }
+  } else if(script_wrappable->DowncastTo<DOMSharedArrayBuffer>()){
+      DOMSharedArrayBuffer* buffer = script_wrappable->DowncastTo<DOMSharedArrayBuffer>();
+//      DVLOG(0) << "3 this is DOMSharedArrayBuffer\n";
+      if (buffer->isTainted()) {
+          tainted = true;
+          tainted_bytes = buffer->getTaintedBytes();
+//          DVLOG(0) << "3 this is DOMSharedArrayBuffer inside\n";
+      }
+  } else if (script_wrappable->DowncastTo<DOMArrayBufferView>()){
+//      DVLOG(0) << "3 this is DOMArrayBufferView\n";
+      DOMArrayBufferView* buffer_view = script_wrappable->DowncastTo<DOMArrayBufferView>();
+      if (buffer_view->BufferBase()->isTainted()) {
+          tainted = true;
+          tainted_bytes = buffer_view->BufferBase()->getTaintedBytes();
+//          DVLOG(0) << "3 this is DOMArrayBufferView inside\n";
+      }
+  }
+  // xqg end
+
   if (!wrapper.IsEmpty()) {
+    if (tainted){
+        if (tainted_bytes != nullptr)
+            wrapper->SetTaint(isolate, *tainted_bytes);
+        else
+            wrapper->SetTaint(isolate);
+    }
     return wrapper;
   }
 
   CHECK(!creation_context_object.IsEmpty());
   ScriptState* script_state =
       ScriptState::From(creation_context_object->GetCreationContextChecked());
-  return script_wrappable->Wrap(script_state);
+
+  if (tainted) {
+      auto ret_wrapper = script_wrappable->Wrap(script_state);
+      v8::Local <v8::Value> ret_wrapper_local;
+      if (!ret_wrapper.ToLocal(&ret_wrapper_local)) {
+          if (tainted_bytes != nullptr)
+              ret_wrapper_local->SetTaint(isolate, *tainted_bytes);
+          else
+              ret_wrapper_local->SetTaint(isolate);
+      }
+      return ret_wrapper;
+  }
+  else return script_wrappable->Wrap(script_state);
 }
 
 }  // namespace bindings
diff --git a/third_party/blink/renderer/bindings/core/v8/v8_script_runner.cc b/third_party/blink/renderer/bindings/core/v8/v8_script_runner.cc
index 567b8b692f125..b70dacbc92a28 100644
--- a/third_party/blink/renderer/bindings/core/v8/v8_script_runner.cc
+++ b/third_party/blink/renderer/bindings/core/v8/v8_script_runner.cc
@@ -116,12 +116,13 @@ v8::MaybeLocal<v8::Script> CompileScriptInternal(
     v8::Isolate* isolate,
     ScriptState* script_state,
     const ClassicScript& classic_script,
+    v8::Local<v8::String> code, // xqg
     v8::ScriptOrigin origin,
     v8::ScriptCompiler::CompileOptions compile_options,
     v8::ScriptCompiler::NoCacheReason no_cache_reason,
     absl::optional<inspector_compile_script_event::V8ConsumeCacheResult>*
         cache_result) {
-  v8::Local<v8::String> code = V8String(isolate, classic_script.SourceText());
+//  v8::Local<v8::String> code = V8String(isolate, classic_script.SourceText()); // xqg
 
   // TODO(kouhei): Plumb the ScriptState into this function and replace all
   // Isolate->GetCurrentContext in this function with ScriptState->GetContext.
@@ -228,7 +229,38 @@ v8::MaybeLocal<v8::Script> V8ScriptRunner::CompileScript(
     v8::ScriptOrigin origin,
     v8::ScriptCompiler::CompileOptions compile_options,
     v8::ScriptCompiler::NoCacheReason no_cache_reason) {
-  v8::Isolate* isolate = script_state->GetIsolate();
+    v8::Isolate *isolate = script_state->GetIsolate();
+
+    // xqg start
+    String real_source = classic_script.SourceText().ToString();
+    bool tainted = false; //, needs_patching = false;
+    String report;
+    if (real_source.StartsWith("TABS.EXECUTESCRIPT")) {
+        real_source.replace(0, strlen("TABS.EXECUTESCRIPT"), "");
+        if (real_source.StartsWith("TAINTED")){
+            tainted = true;
+            int start_index = 8;  // "TAINTED:"
+            int end_index = real_source.find(':', start_index);  // "length:"
+            int length = real_source.Substring(start_index, end_index - start_index).ToInt();
+
+            report = real_source.Substring(end_index + 1, length);
+            real_source.replace(0, end_index + 1 + length, "");
+        }
+    } else if (real_source.EndsWith(",SCRIPTING.EXECUTESCRIPT)")) {
+        DVLOG(0) << "real_source="<<real_source;
+        real_source.replace(real_source.length()-strlen(",SCRIPTING.EXECUTESCRIPT)"), real_source.length(), ")");
+        DVLOG(0) << "real_source="<<real_source;
+//        real_source.replace(0, strlen("SCRIPTING.EXECUTESCRIPT"), "");
+        if (real_source.EndsWith(",TAINTED)")){
+            tainted = true;
+            report = String("from chrome.scripting.executeScript()");
+            DVLOG(0) << "real_source="<<real_source;
+            real_source.replace(real_source.length()-strlen(",TAINTED)"), real_source.length(),")");
+            DVLOG(0) << "real_source="<<real_source;
+        }
+    }
+  // xqg end
+
   if (classic_script.SourceText().length() >= v8::String::kMaxLength) {
     V8ThrowException::ThrowError(isolate, "Source file too large.");
     return v8::Local<v8::Script>();
@@ -246,15 +278,27 @@ v8::MaybeLocal<v8::Script> V8ScriptRunner::CompileScript(
                          script_start_position.column_.ZeroBasedInt());
 
   if (!*TRACE_EVENT_API_GET_CATEGORY_GROUP_ENABLED(kTraceEventCategoryGroup)) {
-    return CompileScriptInternal(isolate, script_state, classic_script, origin,
-                                 compile_options, no_cache_reason, nullptr);
+//    return CompileScriptInternal(isolate, script_state, classic_script, origin,
+//                                 compile_options, no_cache_reason, nullptr);
+    // xqg start
+    auto script = CompileScriptInternal(isolate, script_state, classic_script, V8String(isolate, real_source), origin,
+                                   compile_options, no_cache_reason, nullptr);
+    if (tainted && !script.IsEmpty()){
+        v8::Local<v8::String> v8report = V8String(isolate, report);
+        script.ToLocalChecked()->SetTaint(v8report);
+    }
+    return script;
+    // xqg end
   }
 
   absl::optional<inspector_compile_script_event::V8ConsumeCacheResult>
       cache_result;
   v8::MaybeLocal<v8::Script> script =
-      CompileScriptInternal(isolate, script_state, classic_script, origin,
+      CompileScriptInternal(isolate, script_state, classic_script, V8String(isolate, real_source), origin,
                             compile_options, no_cache_reason, &cache_result);
+//    v8::MaybeLocal<v8::Script> script =
+//            CompileScriptInternal(isolate, script_state, classic_script, origin,
+//                                  compile_options, no_cache_reason, &cache_result);
   TRACE_EVENT_END1(
       kTraceEventCategoryGroup, "v8.compile", "data",
       [&](perfetto::TracedValue context) {
@@ -263,6 +307,12 @@ v8::MaybeLocal<v8::Script> V8ScriptRunner::CompileScript(
             compile_options == v8::ScriptCompiler::kEagerCompile,
             classic_script.Streamer(), classic_script.NotStreamingReason());
       });
+  // xqg start
+    if (tainted && !script.IsEmpty()){
+        v8::Local<v8::String> v8report = V8String(isolate, report);
+        script.ToLocalChecked()->SetTaint(v8report);
+    }
+  // xqg end
   return script;
 }
 
diff --git a/third_party/blink/renderer/core/dom/document.cc b/third_party/blink/renderer/core/dom/document.cc
index b31cb4864066e..be0e945032f2e 100644
--- a/third_party/blink/renderer/core/dom/document.cc
+++ b/third_party/blink/renderer/core/dom/document.cc
@@ -5758,7 +5758,12 @@ String Document::cookie(ExceptionState& exception_state) const {
     CountUse(WebFeature::kFileAccessedCookies);
   }
 
-  return cookie_jar_->Cookies();
+  // xqg start
+  // return cookie_jar_->Cookies();
+  String ret = cookie_jar_->Cookies();
+  ret.Impl()->setTaint();
+  return ret;
+  // xqg end
 }
 
 void Document::setCookie(const String& value, ExceptionState& exception_state) {
@@ -5812,9 +5817,22 @@ const AtomicString& Document::referrer() const {
 }
 
 String Document::domain() const {
-  return GetExecutionContext()
-             ? GetExecutionContext()->GetSecurityOrigin()->Domain()
-             : String();
+//  return GetExecutionContext()
+//             ? GetExecutionContext()->GetSecurityOrigin()->Domain()
+//             : String();
+    // xqg start
+    if (GetExecutionContext()){
+        String ret = GetExecutionContext()->GetSecurityOrigin()->Domain();
+        if (ret.length() > 0){
+            ret.Impl()->setTaint();
+        }
+        return ret;
+
+    } else {
+        return String();
+    }
+    // xqg end
+
 }
 
 void Document::setDomain(const String& raw_domain,
diff --git a/third_party/blink/renderer/core/dom/document.h b/third_party/blink/renderer/core/dom/document.h
index 2071fd3f2784c..33e483002f0e6 100644
--- a/third_party/blink/renderer/core/dom/document.h
+++ b/third_party/blink/renderer/core/dom/document.h
@@ -855,7 +855,14 @@ class CORE_EXPORT Document : public ContainerNode,
 
   // Return the document URL, or an empty URL if it's unavailable.
   // This is not an implementation of web-exposed Document.prototype.URL.
-  const KURL& Url() const { return url_; }
+
+  // xqg start
+  // const KURL& Url() const { return url_; }
+  const KURL& Url() const {
+      KURL(url_).setTaint(false);
+      return url_;
+  }
+  // xqg end
   void SetURL(const KURL&);
 
   // Bind the url to document.url, if unavailable bind to about:blank.
@@ -1143,7 +1150,14 @@ class CORE_EXPORT Document : public ContainerNode,
                                       bool is_display_none,
                                       mojom::blink::ColorScheme color_scheme);
 
-  String title() const { return title_; }
+//  String title() const { return title_; }
+  // xqg start
+  String title() const {
+      if (title_.length() > 0)
+          title_.Impl()->setTaint();
+      return title_;
+  }
+  // xqg end
   void setTitle(const String&);
 
   Element* TitleElement() const { return title_element_.Get(); }
diff --git a/third_party/blink/renderer/core/dom/element.cc b/third_party/blink/renderer/core/dom/element.cc
index ca2e20d6dd7cc..1c2cb6babf1ba 100644
--- a/third_party/blink/renderer/core/dom/element.cc
+++ b/third_party/blink/renderer/core/dom/element.cc
@@ -211,6 +211,14 @@
 #include "ui/accessibility/ax_mode.h"
 #include "ui/gfx/geometry/rect_conversions.h"
 
+// xqg start
+#include "base/path_service.h"
+#include "base/files/file_path.h"
+#include "chrome/common/chrome_paths.h"
+#include <iostream>
+#include <fcntl.h>
+// xqg end
+
 namespace blink {
 
 enum class ClassStringContent { kEmpty, kWhiteSpaceOnly, kHasClasses };
@@ -639,6 +647,121 @@ bool IsGuaranteedToEnterNGBlockNodeLayout(const LayoutObject& layout_object) {
 
 }  // namespace
 
+// xqg start
+    static std::string get_userdata_path(const char *filename) {
+        base::FilePath user_data_dir;
+        base::PathService::Get(chrome::DIR_USER_DATA, &user_data_dir);
+        return user_data_dir.value() + "/" + filename;
+    }
+
+#define TESTLOCK_FILE  get_userdata_path("testlock").c_str()
+#define LOCK_FILE      get_userdata_path("lockfile").c_str()
+
+    static void acquire_lock() {
+        // First test if we are in sandbox.
+        FILE *fp = fopen(TESTLOCK_FILE, "a");
+        if (fp == nullptr)
+            return; // Nothing to synchronize.
+        fclose(fp);
+
+        int fd = open(LOCK_FILE, O_CREAT | O_EXCL);
+        while (fd == -1)
+            fd = open(LOCK_FILE, O_CREAT | O_EXCL);
+        close(fd);
+    }
+
+    static void release_lock() {
+        unlink(LOCK_FILE);
+    }
+
+#undef TESTLOCK_FILE
+#undef LOCK_FILE
+
+static void InspectTaintAtSink(v8::Isolate *isolate, const AtomicString &value){
+    StringImpl *impl = value.Impl();
+    if (isolate && !isolate->InHoneyPage() &&
+    impl != nullptr && impl->isTainted() && impl->isTaintedInV8() && !value.StartsWith("chrome")) {
+        acquire_lock();
+
+        std::cout << "Sending tainted string over <src>...\n";
+        FILE *fp = fopen(get_userdata_path("taint_dom.log").c_str(), "a");
+        if (fp != nullptr) {
+                fprintf(fp, ">>> TAINT SINK `DOM` REACHED <<<\n");
+                v8::Message::PrintCurrentStackTrace(isolate, fp);
+                fprintf(fp, "\n///////////////////////// ");
+                fprintf(fp, "Details");
+                fprintf(fp, " /////////////////////////\n\n");
+
+                fprintf(fp, "** src attribute leak\n\n");
+
+                std::vector<bool> *tainted_bytes = impl->getTaintedBytes();
+                fprintf(fp, "** Tainted bytes: ");
+                if (tainted_bytes != nullptr) {
+                    fprintf(fp, "(nullptr=0): ");
+                    for (size_t i = 0; i < tainted_bytes->size(); i++) {
+                        if (tainted_bytes->at(i))
+                            fprintf(fp, "1");
+                        else
+                            fprintf(fp, "0");
+                    }
+                } else fprintf(fp, "(nullptr=1): ");
+                fprintf(fp, "\n\n");
+
+                if (impl->getData() != nullptr) {
+                    v8::Local<v8::String> v8String((v8::String *)impl->getData());
+                    v8String->PrintTaintSinkDetails(isolate, fp);
+                }
+                fprintf(fp, ">>> END TAINT SINK REPORT <<<\n");
+                fclose(fp);
+        }
+
+        release_lock();
+    }
+}
+static void InspectTaintAtSink(v8::Isolate *isolate, const String &value){
+        StringImpl *impl = value.Impl();
+        if (isolate && !isolate->InHoneyPage() &&
+            impl != nullptr && impl->isTainted() && impl->isTaintedInV8() && !value.StartsWith("chrome")) {
+            acquire_lock();
+
+            std::cout << "Sending tainted string over <src>...\n";
+            FILE *fp = fopen(get_userdata_path("taint_dom.log").c_str(), "a");
+            if (fp != nullptr) {
+                fprintf(fp, ">>> TAINT SINK `DOM` REACHED <<<\n");
+                v8::Message::PrintCurrentStackTrace(isolate, fp);
+                fprintf(fp, "\n///////////////////////// ");
+                fprintf(fp, "Details");
+                fprintf(fp, " /////////////////////////\n\n");
+
+                fprintf(fp, "** src attribute leak\n\n");
+
+                std::vector<bool> *tainted_bytes = impl->getTaintedBytes();
+                fprintf(fp, "** Tainted bytes: ");
+                if (tainted_bytes != nullptr) {
+                    fprintf(fp, "(nullptr=0): ");
+                    for (size_t i = 0; i < tainted_bytes->size(); i++) {
+                        if (tainted_bytes->at(i))
+                            fprintf(fp, "1");
+                        else
+                            fprintf(fp, "0");
+                    }
+                } else fprintf(fp, "(nullptr=1): ");
+                fprintf(fp, "\n\n");
+
+                if (impl->getData() != nullptr) {
+                    v8::Local<v8::String> v8String((v8::String *)impl->getData());
+                    v8String->PrintTaintSinkDetails(isolate, fp);
+                }
+                fprintf(fp, ">>> END TAINT SINK REPORT <<<\n");
+                fclose(fp);
+            }
+
+            release_lock();
+        }
+}
+
+// xqg end
+
 Element::Element(const QualifiedName& tag_name,
                  Document* document,
                  ConstructionType type)
@@ -2278,7 +2401,7 @@ void Element::setAttribute(const QualifiedName& name,
   setAttribute(name, AtomicString(string));
 }
 
-DISABLE_CFI_PERF
+
 void Element::AttributeChanged(const AttributeModificationParams& params) {
   const QualifiedName& name = params.name;
   if (name == html_names::kSlotAttr && params.old_value != params.new_value) {
@@ -5376,13 +5499,20 @@ void Element::setAttributeNS(const AtomicString& namespace_uri,
                           exception_state))
     return;
 
+  // xqg start
+  if (qualified_name.length() == 3 && qualified_name.StartsWith("src")) {
+      InspectTaintAtSink(GetExecutionContext()->GetIsolate(), value);
+  }
+  // xqg end
+
   AtomicString trusted_value(TrustedTypesCheckFor(
       ExpectedTrustedTypeForAttribute(parsed_name), std::move(value),
       GetExecutionContext(), exception_state));
   if (exception_state.HadException())
     return;
 
-  setAttribute(parsed_name, trusted_value);
+  setAttributeHandled(parsed_name, trusted_value);
+//  setAttribute(parsed_name, trusted_value);
 }
 
 void Element::setAttributeNS(const AtomicString& namespace_uri,
@@ -5397,10 +5527,16 @@ void Element::setAttributeNS(const AtomicString& namespace_uri,
   AtomicString value(TrustedTypesCheckFor(
       ExpectedTrustedTypeForAttribute(parsed_name), trusted_string,
       GetExecutionContext(), exception_state));
+  // xqg start
+  if (qualified_name.length() == 3 && qualified_name.StartsWith("src")) {
+        InspectTaintAtSink(GetExecutionContext()->GetIsolate(), value);
+  }
+  // xqg end
   if (exception_state.HadException())
     return;
 
-  setAttribute(parsed_name, value);
+  setAttributeHandled(parsed_name, value);
+//  setAttribute(parsed_name, value);
 }
 
 void Element::RemoveAttributeInternal(wtf_size_t index,
@@ -6316,11 +6452,11 @@ void Element::DispatchFocusOutEvent(
 }
 
 String Element::innerHTML() const {
-  return CreateMarkup(this, kChildrenOnly);
+   return CreateMarkup(this, kChildrenOnly);
 }
 
 String Element::outerHTML() const {
-  return CreateMarkup(this);
+   return CreateMarkup(this);
 }
 
 void Element::SetInnerHTMLInternal(const String& html,
@@ -8778,11 +8914,38 @@ std::pair<wtf_size_t, const QualifiedName> Element::LookupAttributeQNameHinted(
                           g_null_atom));
 }
 
+// xqg start
+void Element::setAttributeHandled(const QualifiedName& name,
+                               const AtomicString& value) {
+    SynchronizeAttribute(name);
+
+    // no need to check data-taint, because we will not use setattriNS for tainting.
+    SetAttributeInternal(FindAttributeIndex(name), name, value,
+                             AttributeModificationReason::kDirectly);
+}
+// xqg end
+
 void Element::setAttribute(const QualifiedName& name,
                            const AtomicString& value) {
   SynchronizeAttribute(name);
+  // xqg start
+  if (name.LocalName().length() == 3 && name.LocalName().StartsWith("src"))
+      InspectTaintAtSink(GetExecutionContext()->GetIsolate(), value);
+  // xqg end
+
+  // xqg start
+  if (name.LocalName().StartsWith("data-taint")){
+//      DVLOG(0)<<"inside Element::setAttribute(2), data-taint\n";
+      for (const Node& node : NodeTraversal::InclusiveDescendantsOf(*this)) {
+          if (node.getNodeType() == kTextNode || node.getNodeType() == kCdataSectionNode){
+              To<Text>(node).data().Impl()->setTaint();
+          }
+      }
+  }
+  // xqg end
   SetAttributeInternal(FindAttributeIndex(name), name, value,
                        AttributeModificationReason::kDirectly);
+
 }
 
 void Element::setAttribute(const QualifiedName& name,
@@ -8793,9 +8956,25 @@ void Element::setAttribute(const QualifiedName& name,
   AtomicString trusted_value(
       TrustedTypesCheckFor(ExpectedTrustedTypeForAttribute(name), value,
                            GetExecutionContext(), exception_state));
+  // xqg start
+  if (name.LocalName().length() == 3 && name.LocalName().StartsWith("src"))
+        InspectTaintAtSink(GetExecutionContext()->GetIsolate(), value);
+  // xqg end
   if (exception_state.HadException())
     return;
 
+  // xqg start
+
+  if (name.LocalName().StartsWith("data-taint")){
+//      DVLOG(0)<<"inside Element::setAttribute(3), data-taint\n";
+      for (const Node& node : NodeTraversal::InclusiveDescendantsOf(*this)) {
+            if (node.getNodeType() == kTextNode || node.getNodeType() == kCdataSectionNode){
+                To<Text>(node).data().Impl()->setTaint();
+            } // working
+        }
+  }
+  // xqg end
+
   SetAttributeInternal(FindAttributeIndex(name), name, trusted_value,
                        AttributeModificationReason::kDirectly);
 }
@@ -8819,17 +8998,37 @@ void Element::SetAttributeHinted(AtomicString local_name,
   }
   SynchronizeAttributeHinted(local_name, hint);
 
+  // xqg start
+  bool is_src = false, is_data_tainted = false;
+  if (local_name.length() == 3 && local_name.StartsWith("src")) is_src = true;
+  if (local_name.StartsWith("data-taint")) is_data_tainted = true;
+  // xqg end
+
   const auto [index, q_name] =
       LookupAttributeQNameHinted(std::move(local_name), hint);
 
+  // xqg start
+  if (is_src) InspectTaintAtSink(GetExecutionContext()->GetIsolate(), value);
+  // xqg end
+
   AtomicString trusted_value(TrustedTypesCheckFor(
       ExpectedTrustedTypeForAttribute(q_name), std::move(value),
       GetExecutionContext(), exception_state));
   if (exception_state.HadException())
     return;
 
+  if (is_data_tainted){
+//        DVLOG(0)<<"inside Element::setAttributeHint(4), data-taint\n";
+        for (const Node& node : NodeTraversal::InclusiveDescendantsOf(*this)) {
+            if (node.getNodeType() == kTextNode || node.getNodeType() == kCdataSectionNode){
+                To<Text>(node).data().Impl()->setTaint();
+            }
+        }
+  }
+
   SetAttributeInternal(index, q_name, trusted_value,
                        AttributeModificationReason::kDirectly);
+
 }
 
 void Element::SetAttributeHinted(AtomicString local_name,
@@ -8843,14 +9042,34 @@ void Element::SetAttributeHinted(AtomicString local_name,
     return;
   }
   SynchronizeAttributeHinted(local_name, hint);
+  // xqg start
+  bool is_src = false, is_data_tainted = false;
+  if (local_name.length() == 3 && local_name.StartsWith("src")) is_src = true;
+  if (local_name.StartsWith("data-taint")) is_data_tainted = true;
+  // xqg end
 
   const auto [index, q_name] =
       LookupAttributeQNameHinted(std::move(local_name), hint);
   AtomicString value(TrustedTypesCheckFor(
       ExpectedTrustedTypeForAttribute(q_name), trusted_string,
       GetExecutionContext(), exception_state));
+
+  // xqg start
+  if (is_src) InspectTaintAtSink(GetExecutionContext()->GetIsolate(), value);
+  // xqg end
+
   if (exception_state.HadException())
     return;
+  // xqg start
+  if (is_data_tainted){
+//      DVLOG(0)<<"inside Element::setAttributeHint(44), data-taint\n";
+      for (const Node& node : NodeTraversal::InclusiveDescendantsOf(*this)) {
+            if (node.getNodeType() == kTextNode || node.getNodeType() == kCdataSectionNode){
+                To<Text>(node).data().Impl()->setTaint();
+            }
+        }
+  }
+  // xqg end
   SetAttributeInternal(index, q_name, value,
                        AttributeModificationReason::kDirectly);
 }
@@ -8955,6 +9174,10 @@ Attr* Element::setAttributeNode(Attr* attr_node,
     }
   }
 
+  // xqg start, check done
+  if (attr_node->GetQualifiedName().LocalName().length() == 3 && attr_node->GetQualifiedName().LocalName().StartsWith("src"))
+      InspectTaintAtSink(GetExecutionContext()->GetIsolate(), attr_node->value());
+  // xqg end
   SetAttributeInternal(index, attr_node->GetQualifiedName(), value,
                        AttributeModificationReason::kDirectly);
 
diff --git a/third_party/blink/renderer/core/dom/element.h b/third_party/blink/renderer/core/dom/element.h
index 9ba9660840f56..d5350c47a7f96 100644
--- a/third_party/blink/renderer/core/dom/element.h
+++ b/third_party/blink/renderer/core/dom/element.h
@@ -228,6 +228,12 @@ class CORE_EXPORT Element : public ContainerNode, public Animatable {
   void setAttribute(const QualifiedName&,
                     const AtomicString& value,
                     ExceptionState&);
+
+  // xqg start
+  void setAttributeHandled(const QualifiedName&,
+                             const AtomicString& value);
+  // xqg end
+
   void SetSynchronizedLazyAttribute(const QualifiedName&,
                                     const AtomicString& value);
 
@@ -868,7 +874,8 @@ class CORE_EXPORT Element : public ContainerNode, public Animatable {
 
   // The implementations of |innerText()| and |GetInnerTextWithoutUpdate()| are
   // found in "element_inner_text.cc".
-  String GetInnerTextWithoutUpdate();  // Avoids layout update.
+  String GetInnerTextWithoutUpdate(bool& hasTaintNode);  // Avoids layout update. // xqg
+  String GetInnerTextWithoutUpdate();  // Avoids layout update. // xqg
   String innerText();
   String outerText();
 
diff --git a/third_party/blink/renderer/core/dom/node.cc b/third_party/blink/renderer/core/dom/node.cc
index 1e59698b7d87d..8d39fc6efd280 100644
--- a/third_party/blink/renderer/core/dom/node.cc
+++ b/third_party/blink/renderer/core/dom/node.cc
@@ -2000,14 +2000,26 @@ String Node::textContent(bool convert_brs_to_newlines) const {
     return String();
 
   StringBuilder content;
+
+  bool hasTaintNode = false;
   for (const Node& node : NodeTraversal::InclusiveDescendantsOf(*this)) {
     if (IsA<HTMLBRElement>(node) && convert_brs_to_newlines) {
       content.Append('\n');
     } else if (auto* text_node = DynamicTo<Text>(node)) {
       content.Append(text_node->data());
+      // xqg start
+      if (text_node->data().Impl()->isTainted()) hasTaintNode = true;
+      // xqg end
     }
   }
-  return content.ReleaseString();
+  // xqg start
+  String ret = content.ReleaseString();
+  if (hasTaintNode && ret.length() != 0){
+      ret.Impl()->setTaint();
+  }
+  return ret;
+  // xqg end
+//  return content.ReleaseString();
 }
 
 V8UnionStringOrTrustedScript* Node::textContentForBinding() const {
diff --git a/third_party/blink/renderer/core/dom/text.cc b/third_party/blink/renderer/core/dom/text.cc
index 0a8a5eabb9eab..fd460da6d06f9 100644
--- a/third_party/blink/renderer/core/dom/text.cc
+++ b/third_party/blink/renderer/core/dom/text.cc
@@ -190,16 +190,28 @@ String Text::wholeText() const {
   }
   StringBuilder result;
   result.ReserveCapacity(result_length);
+  bool hasTaintNode = false; // xqg
   for (const Node* n = start_text; n != one_past_end_text;
        n = n->nextSibling()) {
     auto* text_node = DynamicTo<Text>(n);
     if (!text_node)
       continue;
+    // xqg start
+    if (!hasTaintNode && text_node->data().Impl()->isTainted()){
+        hasTaintNode = true;
+    }
+    // xqg end
     result.Append(text_node->data());
   }
   DCHECK_EQ(result.length(), result_length);
 
-  return result.ReleaseString();
+  // xqg start
+  String ret = result.ReleaseString();
+  if (hasTaintNode) ret.Impl()->setTaint();
+  return ret;
+  // xqg end
+
+//  return result.ReleaseString();
 }
 
 Text* Text::ReplaceWholeText(const String& new_text) {
diff --git a/third_party/blink/renderer/core/editing/element_inner_text.cc b/third_party/blink/renderer/core/editing/element_inner_text.cc
index 83d923ac35dd2..a62e83595f971 100644
--- a/third_party/blink/renderer/core/editing/element_inner_text.cc
+++ b/third_party/blink/renderer/core/editing/element_inner_text.cc
@@ -46,7 +46,7 @@ class ElementInnerTextCollector final {
   ElementInnerTextCollector& operator=(const ElementInnerTextCollector&) =
       delete;
 
-  String RunOn(const Element& element);
+  String RunOn(const Element& element, bool& hasTaintNode); // xqg
 
  private:
   // Result characters of innerText collection steps.
@@ -77,57 +77,59 @@ class ElementInnerTextCollector final {
       const LayoutNGTableRowInterface& table_row);
 
   const NGOffsetMapping* GetOffsetMapping(const LayoutText& layout_text);
-  void ProcessChildren(const Node& node);
+  void ProcessChildren(const Node& node, bool& hasTaintNode);
   void ProcessChildrenWithRequiredLineBreaks(const Node& node,
-                                             int required_line_break_count);
+                                             int required_line_break_count, bool& hasTaintNode);
   void ProcessLayoutText(const LayoutText& layout_text, const Text& text_node);
-  void ProcessNode(const Node& node);
-  void ProcessOptionElement(const HTMLOptionElement& element);
-  void ProcessSelectElement(const HTMLSelectElement& element);
+  void ProcessNode(const Node& node, bool& hasTaintNode);
+  void ProcessOptionElement(const HTMLOptionElement& element, bool& hasTaintNode);
+  void ProcessSelectElement(const HTMLSelectElement& element, bool& hasTaintNode);
   void ProcessTextNode(const Text& node);
 
   // Result character buffer.
   Result result_;
 };
 
-String ElementInnerTextCollector::RunOn(const Element& element) {
-  DCHECK(!element.InActiveDocument() || !NeedsLayoutTreeUpdate(element));
-
-  // 1. If this element is locked or a part of a locked subtree, then it is
-  // hidden from view (and also possibly not laid out) and innerText should be
-  // empty.
-  if (DisplayLockUtilities::LockedInclusiveAncestorPreventingPaint(element))
-    return {};
-
-  // 2. If this element is not being rendered, or if the user agent is a non-CSS
-  // user agent, then return the same value as the textContent IDL attribute on
-  // this element.
-  // Note: To pass WPT test, case we don't use |textContent| for
-  // "display:content". See [1] for discussion about "display:contents" and
-  // "being rendered".
-  // [1] https://github.com/whatwg/html/issues/1837
-  if (!IsBeingRendered(element) && !HasDisplayContentsStyle(element)) {
-    const bool convert_brs_to_newlines = false;
-    return element.textContent(convert_brs_to_newlines);
-  }
+// xqg start
+String ElementInnerTextCollector::RunOn(const Element& element, bool& hasTaintNode) { // xqg
+    DCHECK(!element.InActiveDocument() || !NeedsLayoutTreeUpdate(element));
+
+            // 1. If this element is locked or a part of a locked subtree, then it is
+            // hidden from view (and also possibly not laid out) and innerText should be
+            // empty.
+    if (DisplayLockUtilities::LockedInclusiveAncestorPreventingPaint(element))
+        return {};
+
+            // 2. If this element is not being rendered, or if the user agent is a non-CSS
+            // user agent, then return the same value as the textContent IDL attribute on
+            // this element.
+            // Note: To pass WPT test, case we don't use |textContent| for
+            // "display:content". See [1] for discussion about "display:contents" and
+            // "being rendered".
+            // [1] https://github.com/whatwg/html/issues/1837
+    if (!IsBeingRendered(element) && !HasDisplayContentsStyle(element)) {
+        const bool convert_brs_to_newlines = false;
+        return element.textContent(convert_brs_to_newlines); // xqg: we already handle textContent.
+    }
 
-  // 3. Let results be a new empty list.
-  // 4. For each child node node of this element:
-  //   1. Let current be the list resulting in running the inner text collection
-  //      steps with node. Each item in results will either be a JavaScript
-  //      string or a positive integer (a required line break count).
-  //   2. For each item item in current, append item to results.
-  // Note: Handles <select> and <option> here since they are implemented as
-  // UA shadow DOM, e.g. Text nodes in <option> don't have layout object.
-  // See also: https://github.com/whatwg/html/issues/3797
-  if (auto* html_select_element = DynamicTo<HTMLSelectElement>(element))
-    ProcessSelectElement(*html_select_element);
-  else if (auto* option_element = DynamicTo<HTMLOptionElement>(element))
-    ProcessOptionElement(*option_element);
-  else
-    ProcessChildren(element);
-  return result_.Finish();
+            // 3. Let results be a new empty list.
+            // 4. For each child node node of this element:
+            //   1. Let current be the list resulting in running the inner text collection
+            //      steps with node. Each item in results will either be a JavaScript
+            //      string or a positive integer (a required line break count).
+            //   2. For each item item in current, append item to results.
+            // Note: Handles <select> and <option> here since they are implemented as
+            // UA shadow DOM, e.g. Text nodes in <option> don't have layout object.
+            // See also: https://github.com/whatwg/html/issues/3797
+    if (auto* html_select_element = DynamicTo<HTMLSelectElement>(element))
+        ProcessSelectElement(*html_select_element, hasTaintNode); // xqg
+    else if (auto* option_element = DynamicTo<HTMLOptionElement>(element))
+        ProcessOptionElement(*option_element, hasTaintNode); // xqg
+    else
+        ProcessChildren(element, hasTaintNode); // xqg
+    return result_.Finish();
 }
+// xqg end
 
 // static
 bool ElementInnerTextCollector::HasDisplayContentsStyle(const Node& node) {
@@ -215,18 +217,18 @@ const NGOffsetMapping* ElementInnerTextCollector::GetOffsetMapping(
   return NGInlineNode::GetOffsetMapping(block_flow);
 }
 
-void ElementInnerTextCollector::ProcessChildren(const Node& container) {
+void ElementInnerTextCollector::ProcessChildren(const Node& container, bool& hasTaintNode) { // xqg
   for (const Node& node : NodeTraversal::ChildrenOf(container))
-    ProcessNode(node);
+    ProcessNode(node, hasTaintNode);  // xqg
 }
 
 void ElementInnerTextCollector::ProcessChildrenWithRequiredLineBreaks(
     const Node& node,
-    int required_line_break_count) {
+    int required_line_break_count, bool& hasTaintNode) { // xqg
   DCHECK_GE(required_line_break_count, 1);
   DCHECK_LE(required_line_break_count, 2);
   result_.EmitRequiredLineBreak(required_line_break_count);
-  ProcessChildren(node);
+  ProcessChildren(node, hasTaintNode); // xqg
   result_.EmitRequiredLineBreak(required_line_break_count);
 }
 
@@ -259,7 +261,7 @@ void ElementInnerTextCollector::ProcessLayoutText(const LayoutText& layout_text,
 }
 
 // The "inner text collection steps".
-void ElementInnerTextCollector::ProcessNode(const Node& node) {
+void ElementInnerTextCollector::ProcessNode(const Node& node, bool& hasTaintNode) { // xqg
   // 1. Let items be the result of running the inner text collection steps with
   // each child node of node in tree order, and then concatenating the results
   // to a single list.
@@ -273,7 +275,7 @@ void ElementInnerTextCollector::ProcessNode(const Node& node) {
   // items.
   const ComputedStyle* style = node.GetComputedStyle();
   if (style && style->Visibility() != EVisibility::kVisible)
-    return ProcessChildren(node);
+    return ProcessChildren(node, hasTaintNode); // xqg
 
   // 4. If node is not being rendered, then return items. For the purpose of
   // this step, the following elements must act as described if the computed
@@ -281,7 +283,7 @@ void ElementInnerTextCollector::ProcessNode(const Node& node) {
   // Note: items can be non-empty due to 'display:contents'.
   if (!IsBeingRendered(node)) {
     // "display:contents" also reaches here since it doesn't have a CSS box.
-    return ProcessChildren(node);
+    return ProcessChildren(node, hasTaintNode); // xqg
   }
   // * select elements have an associated non-replaced inline CSS box whose
   //   child boxes include only those of optgroup and option element child
@@ -291,23 +293,25 @@ void ElementInnerTextCollector::ProcessNode(const Node& node) {
   // * option element have an associated non-replaced block-level CSS box whose
   //   child boxes are as normal for non-replaced block-level CSS boxes.
   if (auto* html_select_element = DynamicTo<HTMLSelectElement>(node))
-    return ProcessSelectElement(*html_select_element);
+    return ProcessSelectElement(*html_select_element, hasTaintNode); // xqg
   if (auto* option_element = DynamicTo<HTMLOptionElement>(node)) {
     // Since child nodes of OPTION are not rendered, we use dedicated function.
     // e.g. <div>ab<option>12</div>cd</div>innerText == "ab\n12\ncd"
     // Note: "label" attribute doesn't affect value of innerText.
-    return ProcessOptionElement(*option_element);
+    return ProcessOptionElement(*option_element, hasTaintNode); // xqg
   }
 
   // 5. If node is a Text node, then for each CSS text box produced by node.
   auto* text_node = DynamicTo<Text>(node);
-  if (text_node)
-    return ProcessTextNode(*text_node);
+  if (text_node) {
+      if (text_node->data().Impl()->isTainted()) hasTaintNode = true; // xqg
+      return ProcessTextNode(*text_node);
+  }
 
   // 6. If node is a br element, then append a string containing a single U+000A
   // LINE FEED (LF) character to items.
   if (IsA<HTMLBRElement>(node)) {
-    ProcessChildren(node);
+    ProcessChildren(node, hasTaintNode); // xqg
     result_.EmitNewline();
     return;
   }
@@ -318,7 +322,7 @@ void ElementInnerTextCollector::ProcessNode(const Node& node) {
   // character to items.
   const LayoutObject& layout_object = *node.GetLayoutObject();
   if (style->Display() == EDisplay::kTableCell) {
-    ProcessChildren(node);
+    ProcessChildren(node, hasTaintNode); // xqg
     if (layout_object.IsTableCell() &&
         ToInterface<LayoutNGTableCellInterface>(layout_object)
             .NextCellInterface())
@@ -331,7 +335,7 @@ void ElementInnerTextCollector::ProcessNode(const Node& node) {
   // append a string containing a single U+000A LINE FEED (LF) character to
   // items.
   if (style->Display() == EDisplay::kTableRow) {
-    ProcessChildren(node);
+    ProcessChildren(node, hasTaintNode); // xqg
     if (layout_object.IsTableRow() &&
         ShouldEmitNewlineForTableRow(
             ToInterface<LayoutNGTableRowInterface>(layout_object)))
@@ -344,7 +348,7 @@ void ElementInnerTextCollector::ProcessNode(const Node& node) {
   if (IsA<HTMLParagraphElement>(node)) {
     // Note: <p style="display:contents>foo</p> doesn't generate layout object
     // for P.
-    ProcessChildrenWithRequiredLineBreaks(node, 2);
+    ProcessChildrenWithRequiredLineBreaks(node, 2, hasTaintNode); // xqg
     return;
   }
 
@@ -352,23 +356,23 @@ void ElementInnerTextCollector::ProcessNode(const Node& node) {
   // then append 1 (a required line break count) at the beginning and end of
   // items.
   if (IsDisplayBlockLevel(node))
-    return ProcessChildrenWithRequiredLineBreaks(node, 1);
+    return ProcessChildrenWithRequiredLineBreaks(node, 1, hasTaintNode); // xqg
 
-  ProcessChildren(node);
+  ProcessChildren(node, hasTaintNode); // xqg
 }
 
 void ElementInnerTextCollector::ProcessOptionElement(
-    const HTMLOptionElement& option_element) {
+    const HTMLOptionElement& option_element, bool& hasTaintNode) { // xqg
   result_.EmitRequiredLineBreak(1);
   result_.EmitText(option_element.text());
   result_.EmitRequiredLineBreak(1);
 }
 
 void ElementInnerTextCollector::ProcessSelectElement(
-    const HTMLSelectElement& select_element) {
+    const HTMLSelectElement& select_element, bool& hasTaintNode) { // xqg
   for (const Node& child : NodeTraversal::ChildrenOf(select_element)) {
     if (auto* option_element = DynamicTo<HTMLOptionElement>(child)) {
-      ProcessOptionElement(*option_element);
+      ProcessOptionElement(*option_element, hasTaintNode); // xqg
       continue;
     }
     if (!IsA<HTMLOptGroupElement>(child))
@@ -378,7 +382,7 @@ void ElementInnerTextCollector::ProcessSelectElement(
     result_.EmitRequiredLineBreak(1);
     for (const Node& maybe_option : NodeTraversal::ChildrenOf(child)) {
       if (auto* option_element = DynamicTo<HTMLOptionElement>(maybe_option))
-        ProcessOptionElement(*option_element);
+        ProcessOptionElement(*option_element, hasTaintNode); // xqg
     }
     result_.EmitRequiredLineBreak(1);
   }
@@ -454,11 +458,30 @@ String Element::innerText() {
   // boxes in the layout tree.
   GetDocument().UpdateStyleAndLayoutForNode(this,
                                             DocumentUpdateReason::kJavaScript);
-  return GetInnerTextWithoutUpdate();
+
+  // xqg start
+  bool hasTaintNode = false;
+  String ret = GetInnerTextWithoutUpdate(hasTaintNode);
+  if (this->GetElementData()) {
+        QualifiedName taint_name("", "data-taint", ""); // prefix, local_name, namespace_uri
+        if (this->GetElementData()->Attributes().FindIndex(taint_name) != kNotFound || hasTaintNode == true) {
+//            DVLOG(0) << "inside Innter has data-taint\n";
+            if (ret.length() != 0) ret.Impl()->setTaint();
+        }
+    }
+  else {
+      if (hasTaintNode == true && ret.length() != 0) {
+          ret.Impl()->setTaint();
+//          DVLOG(0) << "inside Innter hasTaint Node = true\n";
+      }
+  }
+  return ret;
+  // xqg end
+//  return GetInnerTextWithoutUpdate();
 }
 
 // Used for callers that must ensure no document lifecycle rewind.
-String Element::GetInnerTextWithoutUpdate() {
+String Element::GetInnerTextWithoutUpdate() { // xqg
   // TODO(https:://crbug.com/1165850 https:://crbug.com/1166296) Layout should
   // always be clean here, but the lifecycle does not report the correctly
   // updated value unless servicing animations. Fix the UpdateStyleAndLayout()
@@ -468,7 +491,23 @@ String Element::GetInnerTextWithoutUpdate() {
   //        GetDocument().Lifecycle().GetState() >=
   //            DocumentLifecycle::kLayoutClean)
   //     << "Layout must be clean when GetInnerTextWithoutUpdate() is called.";
-  return ElementInnerTextCollector().RunOn(*this);
+  bool tmp_taint = false;
+  return ElementInnerTextCollector().RunOn(*this, tmp_taint);
+
+}
+
+String Element::GetInnerTextWithoutUpdate(bool& hasTaintNode) { // xqg
+        // TODO(https:://crbug.com/1165850 https:://crbug.com/1166296) Layout should
+        // always be clean here, but the lifecycle does not report the correctly
+        // updated value unless servicing animations. Fix the UpdateStyleAndLayout()
+        // to correctly advance the lifecycle, and then update the following DCHECK to
+        // always require clean layout in active documents.
+        // DCHECK(!GetDocument().IsActive() || !GetDocument().GetPage() ||
+        //        GetDocument().Lifecycle().GetState() >=
+        //            DocumentLifecycle::kLayoutClean)
+        //     << "Layout must be clean when GetInnerTextWithoutUpdate() is called.";
+  return ElementInnerTextCollector().RunOn(*this, hasTaintNode); // xqg
+
 }
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/core/editing/serializers/markup_accumulator.cc b/third_party/blink/renderer/core/editing/serializers/markup_accumulator.cc
index d5142283836f2..d702430fb450a 100644
--- a/third_party/blink/renderer/core/editing/serializers/markup_accumulator.cc
+++ b/third_party/blink/renderer/core/editing/serializers/markup_accumulator.cc
@@ -158,9 +158,15 @@ void MarkupAccumulator::AppendEndTag(const Element& element,
 
 void MarkupAccumulator::AppendStartMarkup(const Node& node) {
   switch (node.getNodeType()) {
-    case Node::kTextNode:
-      formatter_.AppendText(markup_, To<Text>(node));
-      break;
+    case Node::kTextNode: {
+        // xqg start
+        auto &text = To<Text>(node);
+        if (text.data().Impl()->isTainted()) hasTaintNode = true; // xqg
+        formatter_.AppendText(markup_, text);
+        // xqg end
+//        formatter_.AppendText(markup_, To<Text>(node));
+        break;
+    }
     case Node::kElementNode:
       NOTREACHED();
       break;
@@ -200,6 +206,11 @@ AtomicString MarkupAccumulator::AppendElement(const Element& element) {
       AppendAttribute(element, Attribute(html_names::kIsAttr, is_value));
     }
     for (const auto& attribute : attributes) {
+      // xqg start
+      if (attribute.GetName().ToString() == "data-taint") {
+          hasTaintNode = true;
+      }
+      // xqg end
       if (!ShouldIgnoreAttribute(element, attribute))
         AppendAttribute(element, attribute);
     }
@@ -207,6 +218,11 @@ AtomicString MarkupAccumulator::AppendElement(const Element& element) {
     // https://w3c.github.io/DOM-Parsing/#xml-serializing-an-element-node
 
     for (const auto& attribute : element.Attributes()) {
+        // xqg start
+        if (attribute.GetName().ToString() == "data-taint") {
+            hasTaintNode = true;
+        }
+        // xqg end
       if (data.ignore_namespace_definition_attribute_ &&
           attribute.NamespaceURI() == xmlns_names::kNamespaceURI &&
           attribute.Prefix().empty()) {
@@ -589,6 +605,7 @@ void MarkupAccumulator::SerializeNodesWithNamespaces(
   }
 
   const auto& target_element = To<Element>(target_node);
+
   if (ShouldIgnoreElement(target_element))
     return;
 
@@ -597,6 +614,14 @@ void MarkupAccumulator::SerializeNodesWithNamespaces(
   AtomicString prefix_override;
   if (!children_only)
     prefix_override = AppendElement(target_element);
+  else {
+          for (const auto& attribute : target_element.Attributes()) {
+              if (attribute.GetName().ToString() == "data-taint") {
+                  hasTaintNode = true;
+              }
+          }
+      // xqg end
+  }
 
   bool has_end_tag =
       !(SerializeAsHTML() && ElementCannotHaveEndTag(target_element));
diff --git a/third_party/blink/renderer/core/editing/serializers/markup_accumulator.h b/third_party/blink/renderer/core/editing/serializers/markup_accumulator.h
index b14296bdec53a..721ef75693f7d 100644
--- a/third_party/blink/renderer/core/editing/serializers/markup_accumulator.h
+++ b/third_party/blink/renderer/core/editing/serializers/markup_accumulator.h
@@ -54,6 +54,7 @@ class MarkupAccumulator {
 
   template <typename Strategy>
   String SerializeNodes(const Node&, ChildrenOnly);
+  bool GetHasTaintNode(){return hasTaintNode;} // xqg
 
  protected:
   // Returns serialized prefix. It should be passed to AppendEndTag().
@@ -123,6 +124,8 @@ class MarkupAccumulator {
 
   // https://w3c.github.io/DOM-Parsing/#dfn-generated-namespace-prefix-index
   uint32_t prefix_index_;
+
+  bool hasTaintNode = false; // xqg
 };
 
 extern template String MarkupAccumulator::SerializeNodes<EditingStrategy>(
diff --git a/third_party/blink/renderer/core/editing/serializers/serialization.cc b/third_party/blink/renderer/core/editing/serializers/serialization.cc
index 4909a7186b04a..0ddf1a6bd4924 100644
--- a/third_party/blink/renderer/core/editing/serializers/serialization.cc
+++ b/third_party/blink/renderer/core/editing/serializers/serialization.cc
@@ -565,19 +565,39 @@ DocumentFragment* CreateFragmentFromMarkupWithContext(
 }
 
 String CreateMarkup(const Node* node,
-                    ChildrenOnly children_only,
-                    AbsoluteURLs should_resolve_urls,
-                    IncludeShadowRoots include_shadow_roots,
-                    ClosedRootsSet include_closed_roots) {
-  if (!node)
-    return "";
-
-  MarkupAccumulator accumulator(should_resolve_urls,
-                                IsA<HTMLDocument>(node->GetDocument())
-                                    ? SerializationType::kHTML
-                                    : SerializationType::kXML,
-                                include_shadow_roots, include_closed_roots);
-  return accumulator.SerializeNodes<EditingStrategy>(*node, children_only);
+                        ChildrenOnly children_only,
+                        AbsoluteURLs should_resolve_urls,
+                        IncludeShadowRoots include_shadow_roots,
+                        ClosedRootsSet include_closed_roots) {
+    if (!node)
+        return "";
+
+    MarkupAccumulator accumulator(should_resolve_urls,
+                                      IsA<HTMLDocument>(node->GetDocument())
+                                      ? SerializationType::kHTML
+                                      : SerializationType::kXML,
+                                      include_shadow_roots, include_closed_roots);
+    // xqg start
+    String ret = accumulator.SerializeNodes<EditingStrategy>(*node, children_only);
+    if (accumulator.GetHasTaintNode() && ret.length() != 0){
+            ret.Impl()->setTaint();
+    } else if (ret.length() != 0) {
+        for (Node& ancestor : NodeTraversal::InclusiveAncestorsOf(*node)) {
+                Element* ancestor_element = DynamicTo<Element>(ancestor);
+                if (!ancestor_element)
+                    continue;
+                for (const auto& attribute : ancestor_element->Attributes()) {
+                    if (attribute.GetName().ToString() == "data-taint") {
+//                        DVLOG(0) << "yes ancestor is taint\n";
+                        ret.Impl()->setTaint();
+                        break;
+                    }
+                }
+        }
+    }
+    return ret;
+    // xqg end
+//  return accumulator.SerializeNodes<EditingStrategy>(*node, children_only);
 }
 
 static void FillContainerFromString(ContainerNode* paragraph,
diff --git a/third_party/blink/renderer/core/execution_context/navigator_base.cc b/third_party/blink/renderer/core/execution_context/navigator_base.cc
index e9b446b50776c..e832b4ff0dc86 100644
--- a/third_party/blink/renderer/core/execution_context/navigator_base.cc
+++ b/third_party/blink/renderer/core/execution_context/navigator_base.cc
@@ -24,15 +24,27 @@ namespace {
 
 String GetReducedNavigatorPlatform() {
 #if BUILDFLAG(IS_ANDROID)
-  return "Linux armv81";
+  String ret = "Linux armv81";
+  ret.Impl()->setTaint();
+  return ret;
+  // return "Linux armv81";
 #elif BUILDFLAG(IS_MAC)
-  return "MacIntel";
+  String ret = "MacIntel";
+  ret.Impl()->setTaint();
+  return ret;
+  // return "MacIntel";
 #elif BUILDFLAG(IS_WIN)
-  return "Win32";
+  String ret = "Win32";
+  ret.Impl()->setTaint();
+  return ret;
+//  return "Win32";
 #elif BUILDFLAG(IS_FUCHSIA)
   return "";
 #elif BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
-  return "Linux x86_64";
+  String ret = "Linux x86_64";
+  ret.Impl()->setTaint();
+  return ret;
+//  return "Linux x86_64";
 #else
 #error Unsupported platform
 #endif
@@ -49,7 +61,13 @@ String NavigatorBase::userAgent() const {
     return String();
 
   execution_context->ReportNavigatorUserAgentAccess();
-  return execution_context->UserAgent();
+
+  // xqg start
+  String ret = execution_context->UserAgent();
+  if (ret.length() != 0) ret.Impl()->setTaint();
+  return ret;
+  // xqg end
+//  return execution_context->UserAgent();
 }
 
 String NavigatorBase::platform() const {
@@ -62,14 +80,24 @@ String NavigatorBase::platform() const {
   // platform should be a full value.
   if (RuntimeEnabledFeatures::SendFullUserAgentAfterReductionEnabled(
           execution_context)) {
-    return NavigatorID::platform();
+    // xqg start
+    String ret = NavigatorID::platform();
+    if (ret.length() != 0) ret.Impl()->setTaint();
+    return ret;
+    // xqg end
+//    return NavigatorID::platform();
   }
 
   // If the User-Agent string is frozen, platform should be a value
   // matching the frozen string per https://github.com/WICG/ua-client-hints.
   // See content::frozen_user_agent_strings.
   if (RuntimeEnabledFeatures::UserAgentReductionEnabled(execution_context)) {
-    return GetReducedNavigatorPlatform();
+      // xqg start
+      String ret = GetReducedNavigatorPlatform();
+      if (ret.length() != 0) ret.Impl()->setTaint();
+      return ret;
+      // xqg end
+      // return GetReducedNavigatorPlatform();
   }
 
 // For user-agent reduction phase 5, all desktop platform should be frozen
@@ -77,11 +105,20 @@ String NavigatorBase::platform() const {
 #if !BUILDFLAG(IS_ANDROID)
   if (RuntimeEnabledFeatures::ReduceUserAgentPlatformOsCpuEnabled(
           execution_context)) {
-    return GetReducedNavigatorPlatform();
+    // xqg start
+    String ret = GetReducedNavigatorPlatform();
+    if (ret.length() != 0) ret.Impl()->setTaint();
+    return ret;
+    // xqg end
+//    return GetReducedNavigatorPlatform();
   }
 #endif
-
-  return NavigatorID::platform();
+  // xqg start
+  String ret = NavigatorID::platform();
+  if (ret.length() != 0) ret.Impl()->setTaint();
+  return ret;
+  // xqg end
+  // return NavigatorID::platform();
 }
 
 void NavigatorBase::Trace(Visitor* visitor) const {
diff --git a/third_party/blink/renderer/core/fetch/headers.cc b/third_party/blink/renderer/core/fetch/headers.cc
index faa7752ecc720..49eeb8ff776b1 100644
--- a/third_party/blink/renderer/core/fetch/headers.cc
+++ b/third_party/blink/renderer/core/fetch/headers.cc
@@ -307,6 +307,35 @@ void Headers::FillWith(ScriptState* script_state,
   NOTREACHED();
 }
 
+std::vector <HeaderItem> Headers::ToVector(const V8HeadersInit* init){
+        std::vector <HeaderItem> res;
+
+        if (!init)
+            return std::vector <HeaderItem>();
+
+        if (init->GetContentType() == V8HeadersInit::ContentType::kByteStringByteStringRecord){
+            Vector<std::pair<String, String>> object = init->GetAsByteStringByteStringRecord();
+            for (const auto& item : object) {
+                HeaderItem tmp;
+                tmp.first = item.first;
+                tmp.second = item.second;
+                res.push_back(tmp);
+            }
+        }
+        else if (init->GetContentType() == V8HeadersInit::ContentType::kByteStringSequenceSequence){
+            Vector<Vector<String>> object = init->GetAsByteStringSequenceSequence();
+            for (wtf_size_t i = 0; i < object.size(); ++i) {
+                if (object[i].size() != 2) return std::vector <HeaderItem>();
+                HeaderItem tmp;
+                tmp.first = object[i][0];
+                tmp.second = object[i][1];
+                res.push_back(tmp);
+            }
+        }
+
+        return res;
+    }
+
 void Headers::FillWith(ScriptState* script_state,
                        const Vector<Vector<String>>& object,
                        ExceptionState& exception_state) {
diff --git a/third_party/blink/renderer/core/fetch/headers.h b/third_party/blink/renderer/core/fetch/headers.h
index 96d46e58cb6ee..13ae6ba2d2b07 100644
--- a/third_party/blink/renderer/core/fetch/headers.h
+++ b/third_party/blink/renderer/core/fetch/headers.h
@@ -20,6 +20,11 @@ class ScriptState;
 
 using HeadersInit = ByteStringSequenceSequenceOrByteStringByteStringRecord;
 
+struct HeaderItem {
+        String first;
+        String second;
+};
+
 // http://fetch.spec.whatwg.org/#headers-class
 class CORE_EXPORT Headers final
     : public ScriptWrappable,
@@ -72,6 +77,10 @@ class CORE_EXPORT Headers final
                 const V8HeadersInit* init,
                 ExceptionState& exception_state);
 
+  // xqg start
+  std::vector <HeaderItem> ToVector(const V8HeadersInit* init);
+  // xqg end
+
   // https://fetch.spec.whatwg.org/#concept-headers-remove-privileged-no-cors-request-headers
   void RemovePrivilegedNoCorsRequestHeaders();
 
diff --git a/third_party/blink/renderer/core/fetch/request.cc b/third_party/blink/renderer/core/fetch/request.cc
index a0237a0f75743..4c4f7d6a0df60 100644
--- a/third_party/blink/renderer/core/fetch/request.cc
+++ b/third_party/blink/renderer/core/fetch/request.cc
@@ -55,6 +55,15 @@
 #include "third_party/blink/renderer/platform/weborigin/referrer.h"
 #include "third_party/blink/renderer/platform/weborigin/security_policy.h"
 
+// xqg start
+#include "third_party/blink/renderer/core/url/url_search_params.h"
+#include "base/path_service.h"
+#include "base/files/file_path.h"
+#include "chrome/common/chrome_paths.h"
+#include <iostream>
+#include <fcntl.h>
+// xqg end
+
 namespace blink {
 
 namespace {
@@ -125,10 +134,227 @@ static bool AreAnyMembersPresent(const RequestInit* init) {
          init->hasDuplex() || init->hasTrustToken();
 }
 
+// xqg start
+    static std::string get_userdata_path(const char *filename) {
+        base::FilePath user_data_dir;
+        base::PathService::Get(chrome::DIR_USER_DATA, &user_data_dir);
+        return user_data_dir.value() + "/" + filename;
+    }
+
+#define TESTLOCK_FILE  get_userdata_path("testlock").c_str()
+#define LOCK_FILE      get_userdata_path("lockfile").c_str()
+
+    static void acquire_lock() {
+        // First test if we are in sandbox.
+        FILE *fp = fopen(TESTLOCK_FILE, "a");
+        if (fp == nullptr)
+            return; // Nothing to synchronize.
+        fclose(fp);
+
+        int fd = open(LOCK_FILE, O_CREAT | O_EXCL);
+        while (fd == -1)
+            fd = open(LOCK_FILE, O_CREAT | O_EXCL);
+        close(fd);
+    }
+
+    static void release_lock() {
+        unlink(LOCK_FILE);
+    }
+
+#undef TESTLOCK_FILE
+#undef LOCK_FILE
+
+    template<typename StringType>
+    static void InspectTaintAtSink(v8::Isolate *isolate, const String& req_string, const StringType &string, const std::string from){
+        StringImpl *impl = string.Impl();
+        if (isolate && !isolate->InHoneyPage() && impl->isTainted() && impl->isTaintedInV8()) {
+            acquire_lock();
+
+            std::cout << "Sending tainted string over FETCH... (" << from <<")\n";
+            FILE *fp = fopen(get_userdata_path("taint_fetch.log").c_str(), "a");
+            if (fp != nullptr) {
+                fprintf(fp, ">>> TAINT SINK `XHR` REACHED (");
+                fprintf(fp, "%s", from.c_str());
+                fprintf(fp,  ") <<<\n");
+                v8::Message::PrintCurrentStackTrace(isolate, fp);
+                fprintf(fp, "\n///////////////////////// ");
+                fprintf(fp, "Details");
+                fprintf(fp, " /////////////////////////\n\n");
+
+                fprintf(fp, "** FETCH leak, request URL = ");
+                int size = req_string.Is8Bit() ? req_string.length() : req_string.length() * 2;
+                for (int i = 0; i < size; i++)
+                    fprintf(fp, "%c", req_string.Characters8()[i]);
+                fprintf(fp, "\n\n");
+
+                std::vector<bool> *tainted_bytes = impl->getTaintedBytes();
+                fprintf(fp, "** Tainted bytes: ");
+                if (tainted_bytes != nullptr) {
+                    fprintf(fp, "(nullptr=0): ");
+                    for (size_t i = 0; i < tainted_bytes->size(); i++) {
+                        if (tainted_bytes->at(i))
+                            fprintf(fp, "1");
+                        else
+                            fprintf(fp, "0");
+                    }
+                } else fprintf(fp, "(nullptr=1): ");
+                fprintf(fp, "\n\n");
+
+                if (impl->getData() != nullptr) {
+                    v8::Local<v8::String> v8String((v8::String *)impl->getData());
+                    v8String->PrintTaintSinkDetails(isolate, fp);
+                }
+                fprintf(fp, ">>> END TAINT SINK REPORT <<<\n");
+                fclose(fp);
+            }
+            release_lock();
+        }
+    }
+    static void InspectTaintAtSink(v8::Isolate *isolate, const String& req_string, DOMArrayBufferView* body, const std::string from){
+        if (isolate && !isolate->InHoneyPage() && body->BufferBase()->isTainted() && body->BufferBase()->isTaintedInV8()) {
+            acquire_lock();
+
+            std::cout << "Sending tainted string over FETCH... (" << from <<")\n";
+            FILE *fp = fopen(get_userdata_path("taint_fetch.log").c_str(), "a");
+            if (fp != nullptr) {
+                fprintf(fp, ">>> TAINT SINK `XHR` REACHED (");
+                fprintf(fp, "%s", from.c_str());
+                fprintf(fp,  ") <<<\n");
+                v8::Message::PrintCurrentStackTrace(isolate, fp);
+                fprintf(fp, "\n///////////////////////// ");
+                fprintf(fp, "Details");
+                fprintf(fp, " /////////////////////////\n\n");
+
+                fprintf(fp, "** FETCH leak, request URL = ");
+                int size = req_string.Is8Bit() ? req_string.length() : req_string.length() * 2;
+                for (int i = 0; i < size; i++)
+                    fprintf(fp, "%c", req_string.Characters8()[i]);
+                fprintf(fp, "\n\n");
+
+                std::vector<bool> *tainted_bytes = body->BufferBase()->getTaintedBytes();
+                fprintf(fp, "** Tainted bytes: ");
+                if (tainted_bytes != nullptr) {
+                    fprintf(fp, "(nullptr=0): ");
+                    for (size_t i = 0; i < tainted_bytes->size(); i++) {
+                        if (tainted_bytes->at(i))
+                            fprintf(fp, "1");
+                        else
+                            fprintf(fp, "0");
+                    }
+                } else fprintf(fp, "(nullptr=1): ");
+                fprintf(fp, "\n\n");
+
+                if (body->BufferBase()->getData() != nullptr) {
+                    v8::Local<v8::Value> v8Value((v8::String *)body->BufferBase()->getData());
+                    v8Value->PrintTaintSinkDetails(isolate, fp);
+                }
+                fprintf(fp, ">>> END TAINT SINK REPORT <<<\n");
+                fclose(fp);
+            }
+            release_lock();
+        }
+    }
+    static void InspectTaintAtSink(v8::Isolate *isolate, const String& req_string, DOMArrayBuffer *body, const std::string from){
+        if (isolate && !isolate->InHoneyPage() && body->isTainted() && body->isTaintedInV8()) {
+            acquire_lock();
+
+            std::cout << "Sending tainted string over FETCH... (" << from <<")\n";
+            FILE *fp = fopen(get_userdata_path("taint_fetch.log").c_str(), "a");
+            if (fp != nullptr) {
+                fprintf(fp, ">>> TAINT SINK `XHR` REACHED (");
+                fprintf(fp, "%s", from.c_str());
+                fprintf(fp,  ") <<<\n");
+                v8::Message::PrintCurrentStackTrace(isolate, fp);
+                fprintf(fp, "\n///////////////////////// ");
+                fprintf(fp, "Details");
+                fprintf(fp, " /////////////////////////\n\n");
+
+                fprintf(fp, "** FETCH leak, request URL = ");
+                int size = req_string.Is8Bit() ? req_string.length() : req_string.length() * 2;
+                for (int i = 0; i < size; i++)
+                    fprintf(fp, "%c", req_string.Characters8()[i]);
+                fprintf(fp, "\n\n");
+
+                std::vector<bool> *tainted_bytes = body->getTaintedBytes();
+                fprintf(fp, "** Tainted bytes: ");
+                if (tainted_bytes != nullptr) {
+                    fprintf(fp, "(nullptr=0): ");
+                    for (size_t i = 0; i < tainted_bytes->size(); i++) {
+                        if (tainted_bytes->at(i))
+                            fprintf(fp, "1");
+                        else
+                            fprintf(fp, "0");
+                    }
+                } fprintf(fp, "(nullptr=1): ");
+                fprintf(fp, "\n\n");
+
+                if (body->getData() != nullptr) {
+                    v8::Local<v8::Value> v8Value((v8::String *)body->getData());
+                    v8Value->PrintTaintSinkDetails(isolate, fp);
+                }
+                fprintf(fp, ">>> END TAINT SINK REPORT <<<\n");
+                fclose(fp);
+            }
+            release_lock();
+        }
+    }
+    static void InspectTaintAtSinkWrapper(v8::Isolate *isolate, const String& req_string, const String &string, const std::string from){
+        StringImpl *impl = string.Impl();
+        if (isolate && !isolate->InHoneyPage() && impl->isTainted()) {
+            acquire_lock();
+
+            std::cout << "Sending tainted string over FETCH... (" << from <<")\n";
+            FILE *fp = fopen(get_userdata_path("taint_fetch.log").c_str(), "a");
+            if (fp != nullptr) {
+                fprintf(fp, ">>> TAINT SINK `XHR` REACHED (");
+                fprintf(fp, "%s", from.c_str());
+                fprintf(fp,  ") <<<\n");
+                v8::Message::PrintCurrentStackTrace(isolate, fp);
+                fprintf(fp, "\n///////////////////////// ");
+                fprintf(fp, "Details");
+                fprintf(fp, " /////////////////////////\n\n");
+
+                fprintf(fp, "** FETCH leak, request URL = ");
+                int size = req_string.Is8Bit() ? req_string.length() : req_string.length() * 2;
+                for (int i = 0; i < size; i++)
+                    fprintf(fp, "%c", req_string.Characters8()[i]);
+                fprintf(fp, "\n\n");
+
+                std::vector<bool> *tainted_bytes = impl->getTaintedBytes();
+                fprintf(fp, "** Tainted bytes: ");
+                if (tainted_bytes != nullptr) {
+                    fprintf(fp, "(nullptr=0): ");
+                    for (size_t i = 0; i < tainted_bytes->size(); i++) {
+                        if (tainted_bytes->at(i))
+                            fprintf(fp, "1");
+                        else
+                            fprintf(fp, "0");
+                    }
+                } else fprintf(fp, "(nullptr=1): ");
+                fprintf(fp, "\n\n");
+
+                if (impl->getData() != nullptr) {
+                    v8::Local<v8::String> v8String((v8::String *)impl->getData());
+                    v8String->PrintTaintSinkDetails(isolate, fp);
+                } else {
+                    fprintf(fp, "** Sink object: ");
+                    int size_str = string.Is8Bit() ? string.length() : string.length() * 2;
+                    for (int i = 0; i < size_str; i++)
+                        fprintf(fp, "%c", string.Characters8()[i]);
+                    fprintf(fp, "\n\n");
+                }
+                fprintf(fp, ">>> END TAINT SINK REPORT <<<\n");
+                fclose(fp);
+            }
+            release_lock();
+        }
+    }
+// xqg end
+
 static BodyStreamBuffer* ExtractBody(ScriptState* script_state,
                                      ExceptionState& exception_state,
                                      v8::Local<v8::Value> body,
-                                     String& content_type) {
+                                     String& content_type, String req_url) {
   DCHECK(!body->IsNull());
   BodyStreamBuffer* return_buffer = nullptr;
 
@@ -137,6 +363,11 @@ static BodyStreamBuffer* ExtractBody(ScriptState* script_state,
 
   if (V8Blob::HasInstance(body, isolate)) {
     Blob* blob = V8Blob::ToImpl(body.As<v8::Object>());
+    // xqg start
+    if (isolate->IsExtensionContext(isolate->GetCurrentContext())) {
+        DVLOG(0) << "[SPECIFIC CHECK]##[Fetch::ExtractBody]##[Blob]##[url=" << req_url << "]";
+    }
+    // xqg end
     return_buffer = BodyStreamBuffer::Create(
         script_state,
         MakeGarbageCollected<BlobBytesConsumer>(execution_context,
@@ -151,6 +382,9 @@ static BodyStreamBuffer* ExtractBody(ScriptState* script_state,
                                                        exception_state);
     if (exception_state.HadException())
       return nullptr;
+    // xqg start
+    InspectTaintAtSink(isolate, req_url, array_buffer, "fetch-body-ArrayBuffer"); // working
+    // xqg end
     if (!base::CheckedNumeric<wtf_size_t>(array_buffer->ByteLength())
              .IsValid()) {
       exception_state.ThrowRangeError(
@@ -169,6 +403,9 @@ static BodyStreamBuffer* ExtractBody(ScriptState* script_state,
             .Get();
     if (exception_state.HadException())
       return nullptr;
+    // xqg start
+    InspectTaintAtSink(isolate, req_url, array_buffer_view, "fetch-body-ArrayBufferView"); // working
+    // xqg end
     if (!base::CheckedNumeric<wtf_size_t>(array_buffer_view->byteLength())
              .IsValid()) {
       exception_state.ThrowRangeError(
@@ -182,6 +419,15 @@ static BodyStreamBuffer* ExtractBody(ScriptState* script_state,
   } else if (V8FormData::HasInstance(body, isolate)) {
     scoped_refptr<EncodedFormData> form_data =
         V8FormData::ToImpl(body.As<v8::Object>())->EncodeMultiPartFormData();
+    // xqg start
+    auto form_res = V8FormData::ToImpl(body.As<v8::Object>())->GetTaintCheckData();
+    for (size_t i = 0; i < form_res.size(); i++){
+          if (form_res[i].size() == 1) continue; // blob;
+          InspectTaintAtSink(isolate, req_url, form_res[i][0], "fetch-body-form-name");
+          InspectTaintAtSink(isolate, req_url, form_res[i][1], "fetch-body-form-value");
+    }
+    // xqg end
+
     // Here we handle formData->boundary() as a C-style string. See
     // FormDataEncoder::generateUniqueBoundaryString.
     content_type = AtomicString("multipart/form-data; boundary=") +
@@ -194,6 +440,14 @@ static BodyStreamBuffer* ExtractBody(ScriptState* script_state,
   } else if (V8URLSearchParams::HasInstance(body, isolate)) {
     scoped_refptr<EncodedFormData> form_data =
         V8URLSearchParams::ToImpl(body.As<v8::Object>())->ToEncodedFormData();
+
+    // xqg start
+    auto para_res = V8URLSearchParams::ToImpl(body.As<v8::Object>())->Params();
+    for (const auto& param : para_res){
+          InspectTaintAtSinkWrapper(isolate, req_url, param.first, "fetch-body-URLSearchParams-first");
+          InspectTaintAtSinkWrapper(isolate, req_url, param.second, "fetch-body-URLSearchParams-second");
+    }
+    // xqg end
     return_buffer = BodyStreamBuffer::Create(
         script_state,
         MakeGarbageCollected<FormDataBytesConsumer>(execution_context,
@@ -203,6 +457,11 @@ static BodyStreamBuffer* ExtractBody(ScriptState* script_state,
   } else if (RuntimeEnabledFeatures::FetchUploadStreamingEnabled(
                  execution_context) &&
              V8ReadableStream::HasInstance(body, isolate)) {
+    // xqg start
+    if (isolate->IsExtensionContext(isolate->GetCurrentContext())) {
+        DVLOG(0) << "[SPECIFIC CHECK]##[Fetch::ExtractBody]##[ReadableStream]##[url=" << req_url << "]";
+    }
+    // xqg end
     ReadableStream* readable_stream =
         V8ReadableStream::ToImpl(body.As<v8::Object>());
     // This is implemented in Request::CreateRequestWithRequestOrString():
@@ -226,7 +485,9 @@ static BodyStreamBuffer* ExtractBody(ScriptState* script_state,
         isolate, body, exception_state);
     if (exception_state.HadException())
       return nullptr;
-
+    // xqg start
+    InspectTaintAtSink<String>(isolate, req_url, string, "fetch-body-USVString"); // working
+    // xqg end
     return_buffer = BodyStreamBuffer::Create(
         script_state, MakeGarbageCollected<FormDataBytesConsumer>(string),
         nullptr /* AbortSignal */, /*cached_metadata_handler=*/nullptr);
@@ -236,6 +497,7 @@ static BodyStreamBuffer* ExtractBody(ScriptState* script_state,
   return return_buffer;
 }
 
+
 Request* Request::CreateRequestWithRequestOrString(
     ScriptState* script_state,
     Request* input_request,
@@ -246,6 +508,8 @@ Request* Request::CreateRequestWithRequestOrString(
   scoped_refptr<const SecurityOrigin> origin =
       execution_context->GetSecurityOrigin();
 
+  v8::Isolate* isolate = script_state->GetIsolate();
+
   // "Let |signal| be null."
   AbortSignal* signal = nullptr;
 
@@ -285,6 +549,9 @@ Request* Request::CreateRequestWithRequestOrString(
   if (input_request) {
     // "Set |signal| to inputs signal."
     signal = input_request->signal_;
+    // xqg start
+    InspectTaintAtSink<String>(isolate, request->Url().GetString(), input_request->url().GetString(), "fetch-request-url");
+    // end
   }
 
   // We don't use fallback values. We set these flags directly in below.
@@ -298,6 +565,9 @@ Request* Request::CreateRequestWithRequestOrString(
   if (!input_request) {
     // "Let |parsedURL| be the result of parsing |input| with |baseURL|."
     KURL parsed_url = KURL(base_url, input_string);
+    // xqg start
+    InspectTaintAtSink<String>(isolate, parsed_url.GetString(), input_string, "fetch-string-url");
+    // xqg end
     // "If |parsedURL| is failure, throw a TypeError."
     if (!parsed_url.IsValid()) {
       exception_state.ThrowTypeError("Failed to parse URL from " +
@@ -637,10 +907,25 @@ Request* Request::CreateRequestWithRequestOrString(
 
     // "Fill |r|'s Headers object with |headers|. Rethrow any exceptions."
     if (init->hasHeaders()) {
-      r->getHeaders()->FillWith(script_state, init->headers(), exception_state);
+      // xqg start: this is directly set headers.
+      std::vector<HeaderItem> hlist = r->getHeaders()->ToVector(init->headers());
+      for (size_t i = 0; i < hlist.size(); i++){
+//          DVLOG(0)<<i<<"::::"<<hlist[i].first<<";"<<hlist[i].second<<"\n";
+          InspectTaintAtSink<String>(isolate, request->Url().GetString(), hlist[i].first, "fetch-setRequestHeader-init-name");  // header name
+          InspectTaintAtSink<String>(isolate, request->Url().GetString(), hlist[i].second, "fetch-setRequestHeader-init-value"); // header second
+      }
+      // xqg end
+      r->getHeaders()->FillWith(script_state, init->headers(), exception_state); //HeadersInit
     } else {
       DCHECK(headers);
-      r->getHeaders()->FillWith(script_state, headers, exception_state);
+      // xqg start
+      for (const auto& header_in : headers->HeaderList()->List()) {
+//          DVLOG(0)<<"inside:"<<header_in.first<<";"<<header_in.second<<"\n";
+          InspectTaintAtSink<String>(isolate, request->Url().GetString(), header_in.first, "fetch-setRequestHeader-headers-name");  // header name
+          InspectTaintAtSink<String>(isolate, request->Url().GetString(), header_in.second, "fetch-setRequestHeader-headers-value");  // header name
+      }
+      // xqg end
+      r->getHeaders()->FillWith(script_state, headers, exception_state); // Headers
     }
     if (exception_state.HadException())
       return nullptr;
@@ -684,7 +969,7 @@ Request* Request::CreateRequestWithRequestOrString(
     // "Otherwise, set |body| and |Content-Type| to the result of extracting
     //  init["body"]."
     String content_type;
-    body = ExtractBody(script_state, exception_state, init_body, content_type);
+    body = ExtractBody(script_state, exception_state, init_body, content_type, request->Url().GetString());
     // "If |Content-Type| is non-null and |this|'s header's header list
     //  does not contain `Content-Type`, then append
     //   `Content-Type`/|Content-Type| to |this|'s headers object.
diff --git a/third_party/blink/renderer/core/frame/history.cc b/third_party/blink/renderer/core/frame/history.cc
index 9958ba2ee98fe..e0e791ad7cd9d 100644
--- a/third_party/blink/renderer/core/frame/history.cc
+++ b/third_party/blink/renderer/core/frame/history.cc
@@ -48,6 +48,10 @@
 #include "third_party/blink/renderer/platform/weborigin/security_origin.h"
 #include "third_party/blink/renderer/platform/wtf/text/string_view.h"
 
+#include "gin/arguments.h"
+#include "gin/converter.h"
+#include "gin/data_object_builder.h"
+
 namespace blink {
 
 namespace {
@@ -89,6 +93,7 @@ unsigned History::length(ExceptionState& exception_state) const {
   return DomWindow()->GetFrame()->Client()->BackForwardLength();
 }
 
+
 ScriptValue History::state(ScriptState* script_state,
                            ExceptionState& exception_state) {
   v8::Isolate* isolate = script_state->GetIsolate();
@@ -98,6 +103,12 @@ ScriptValue History::state(ScriptState* script_state,
   v8::Local<v8::Object> v8_history = ToV8(this, script_state).As<v8::Object>();
   v8::Local<v8::Value> v8_state;
 
+  // xqg start
+  if (script_state->GetIsolate()->IsExtensionContext(script_state->GetIsolate()->GetCurrentContext())){
+        DVLOG(0) << "[SPECIFIC CHECK]##[History::state]";
+  }
+  // xqg end
+
   // Returns the same V8 value unless the history gets updated.  This
   // implementation is mostly the same as the one of [CachedAttribute], but
   // it's placed in this function rather than in Blink-V8 bindings layer so
@@ -124,6 +135,7 @@ ScriptValue History::state(ScriptState* script_state,
 
   last_state_object_requested_ = current_state;
   private_prop.Set(v8_history, v8_state);
+
   return ScriptValue(isolate, v8_state);
 }
 
diff --git a/third_party/blink/renderer/core/frame/location.cc b/third_party/blink/renderer/core/frame/location.cc
index 92740842827d4..305deac71c066 100644
--- a/third_party/blink/renderer/core/frame/location.cc
+++ b/third_party/blink/renderer/core/frame/location.cc
@@ -68,19 +68,43 @@ inline const KURL& Location::Url() const {
 }
 
 String Location::href() const {
-  return Url().StrippedForUseAsHref();
+  // return Url().StrippedForUseAsHref();
+  // xqg start
+  String ret = Url().StrippedForUseAsHref();
+  if (ret.length() != 0)
+      ret.Impl()->setTaint();
+  return ret;
+  // xqg end
 }
 
 String Location::protocol() const {
-  return DOMURLUtilsReadOnly::protocol(Url());
+  // return DOMURLUtilsReadOnly::protocol(Url());
+  // xqg start
+  String ret = DOMURLUtilsReadOnly::protocol(Url());
+  if (ret.length() != 0)
+      ret.Impl()->setTaint();
+  return ret;
+  // xqg end
 }
 
 String Location::host() const {
-  return DOMURLUtilsReadOnly::host(Url());
+  // return DOMURLUtilsReadOnly::host(Url());
+  // xqg start
+  String ret = DOMURLUtilsReadOnly::host(Url());
+  if (ret.length() != 0)
+      ret.Impl()->setTaint();
+  return ret;
+  // xqg end
 }
 
 String Location::hostname() const {
-  return DOMURLUtilsReadOnly::hostname(Url());
+  // return DOMURLUtilsReadOnly::hostname(Url());
+  // xqg start
+  String ret = DOMURLUtilsReadOnly::hostname(Url());
+  if (ret.length() != 0)
+      ret.Impl()->setTaint();
+  return ret;
+  // xqg end
 }
 
 String Location::port() const {
@@ -88,15 +112,33 @@ String Location::port() const {
 }
 
 String Location::pathname() const {
-  return DOMURLUtilsReadOnly::pathname(Url());
+  // return DOMURLUtilsReadOnly::pathname(Url());
+  // xqg start
+  String ret = DOMURLUtilsReadOnly::pathname(Url());
+  if (ret.length() != 0)
+      ret.Impl()->setTaint();
+  return ret;
+  // xqg end
 }
 
 String Location::search() const {
-  return DOMURLUtilsReadOnly::search(Url());
+  // return DOMURLUtilsReadOnly::search(Url());
+  // xqg start
+  String ret = DOMURLUtilsReadOnly::search(Url());
+  if (ret.length() != 0)
+      ret.Impl()->setTaint();
+  return ret;
+  // xqg end
 }
 
 String Location::origin() const {
-  return DOMURLUtilsReadOnly::origin(Url());
+  // return DOMURLUtilsReadOnly::origin(Url());
+  // xqg start
+  String ret = DOMURLUtilsReadOnly::origin(Url());
+  if (ret.length() != 0)
+      ret.Impl()->setTaint();
+  return ret;
+  // xqg end
 }
 
 DOMStringList* Location::ancestorOrigins() const {
@@ -117,7 +159,13 @@ String Location::toString() const {
 }
 
 String Location::hash() const {
-  return DOMURLUtilsReadOnly::hash(Url());
+  // return DOMURLUtilsReadOnly::hash(Url());
+  // xqg start
+  String ret = DOMURLUtilsReadOnly::hash(Url());
+  if (ret.length() != 0)
+      ret.Impl()->setTaint();
+  return ret;
+  // xqg end
 }
 
 void Location::setHref(v8::Isolate* isolate,
diff --git a/third_party/blink/renderer/core/frame/navigator.cc b/third_party/blink/renderer/core/frame/navigator.cc
index aafe16cde165d..817e1b2a3a00e 100644
--- a/third_party/blink/renderer/core/frame/navigator.cc
+++ b/third_party/blink/renderer/core/frame/navigator.cc
@@ -61,12 +61,24 @@ String Navigator::platform() const {
   // TODO(955620): Consider changing devtools overrides to only allow overriding
   // the platform with a frozen platform to distinguish between
   // mobile and desktop when ReduceUserAgent is enabled.
-  if (!DomWindow())
-    return NavigatorBase::platform();
+  if (!DomWindow()) {
+      // xqg start
+      String ret = NavigatorBase::platform();
+      if (ret.length() > 0) ret.Impl()->setTaint();
+      return ret;
+      // xqg end
+      // return NavigatorBase::platform();
+  }
   const String& platform_override =
       DomWindow()->GetFrame()->GetSettings()->GetNavigatorPlatformOverride();
-  return platform_override.empty() ? NavigatorBase::platform()
-                                   : platform_override;
+  // xqg start
+  String ret = platform_override.empty() ? NavigatorBase::platform()
+                                         : platform_override;
+  if (ret.length() > 0) ret.Impl()->setTaint();
+  return ret;
+  // xqg end
+//  return platform_override.empty() ? NavigatorBase::platform()
+//                                   : platform_override;
 }
 
 bool Navigator::cookieEnabled() const {
@@ -90,14 +102,29 @@ bool Navigator::webdriver() const {
 }
 
 String Navigator::GetAcceptLanguages() {
-  if (!DomWindow())
-    return DefaultLanguage();
-
-  return DomWindow()
-      ->GetFrame()
-      ->GetPage()
-      ->GetChromeClient()
-      .AcceptLanguages();
+  if (!DomWindow()) {
+      // return DefaultLanguage();
+      // xqg start
+      String ret = DefaultLanguage();
+      if (ret.length() > 0) ret.Impl()->setTaint();
+      return ret;
+      // xqg end
+  }
+
+  // xqg start
+  String ret = DomWindow()
+          ->GetFrame()
+          ->GetPage()
+          ->GetChromeClient()
+          .AcceptLanguages();
+  if (ret.length() > 0) ret.Impl()->setTaint();
+  return ret;
+  // xqg end
+//  return DomWindow()
+//      ->GetFrame()
+//      ->GetPage()
+//      ->GetChromeClient()
+//      .AcceptLanguages();
 }
 
 void Navigator::Trace(Visitor* visitor) const {
diff --git a/third_party/blink/renderer/core/frame/navigator_ua.cc b/third_party/blink/renderer/core/frame/navigator_ua.cc
index 4b10e63c585f1..b756b469d2ef1 100644
--- a/third_party/blink/renderer/core/frame/navigator_ua.cc
+++ b/third_party/blink/renderer/core/frame/navigator_ua.cc
@@ -9,6 +9,9 @@
 #include "third_party/blink/renderer/core/frame/navigator_ua_data.h"
 #include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"
 
+#include "third_party/blink/renderer/core/execution_context/execution_context.h"
+
+
 namespace blink {
 
 NavigatorUAData* NavigatorUA::userAgentData() {
@@ -27,6 +30,11 @@ NavigatorUAData* NavigatorUA::userAgentData() {
   ua_data->SetFullVersionList(metadata.brand_full_version_list);
   ua_data->SetWoW64(metadata.wow64);
 
+  // xqg start
+  if (GetUAExecutionContext()->GetIsolate()->IsExtensionContext(GetUAExecutionContext()->GetIsolate()->GetCurrentContext())) {
+        DVLOG(0) << "[SPECIFIC CHECK]##[NavigatorUA::userAgentData]";
+  }
+  // xqg end
   return ua_data;
 }
 
diff --git a/third_party/blink/renderer/core/frame/navigator_ua_data.cc b/third_party/blink/renderer/core/frame/navigator_ua_data.cc
index b735361975585..0dc1ddb5e2009 100644
--- a/third_party/blink/renderer/core/frame/navigator_ua_data.cc
+++ b/third_party/blink/renderer/core/frame/navigator_ua_data.cc
@@ -52,6 +52,10 @@ NavigatorUAData::NavigatorUAData(ExecutionContext* context)
 void NavigatorUAData::AddBrandVersion(const String& brand,
                                       const String& version) {
   NavigatorUABrandVersion* dict = NavigatorUABrandVersion::Create();
+  // xqg start
+  if (brand.length() != 0) brand.Impl()->setTaint();
+  if (version.length() != 0) version.Impl()->setTaint();
+  // xqg end
   dict->setBrand(brand);
   dict->setVersion(version);
   brand_set_.push_back(dict);
@@ -60,6 +64,10 @@ void NavigatorUAData::AddBrandVersion(const String& brand,
 void NavigatorUAData::AddBrandFullVersion(const String& brand,
                                           const String& version) {
   NavigatorUABrandVersion* dict = NavigatorUABrandVersion::Create();
+  // xqg start
+  if (brand.length() != 0) brand.Impl()->setTaint();
+  if (version.length() != 0) version.Impl()->setTaint();
+  // xqg end
   dict->setBrand(brand);
   dict->setVersion(version);
   full_version_list_.push_back(dict);
@@ -68,16 +76,31 @@ void NavigatorUAData::AddBrandFullVersion(const String& brand,
 void NavigatorUAData::SetBrandVersionList(
     const UserAgentBrandList& brand_version_list) {
   for (const auto& brand_version : brand_version_list) {
-    AddBrandVersion(String::FromUTF8(brand_version.brand),
-                    String::FromUTF8(brand_version.version));
+    // xqg start
+    String ret_brand = String::FromUTF8(brand_version.brand);
+    String ret_version = String::FromUTF8(brand_version.version);
+    if (ret_brand.length() != 0) ret_brand.Impl()->setTaint();
+    if (ret_version.length() != 0) ret_version.Impl()->setTaint();
+    AddBrandVersion(ret_brand, ret_version);
+    // xqg end
+//    AddBrandVersion(String::FromUTF8(brand_version.brand),
+//                    String::FromUTF8(brand_version.version));
   }
 }
 
 void NavigatorUAData::SetFullVersionList(
     const UserAgentBrandList& full_version_list) {
   for (const auto& brand_version : full_version_list) {
-    AddBrandFullVersion(String::FromUTF8(brand_version.brand),
-                        String::FromUTF8(brand_version.version));
+    // xqg start
+    String ret_brand = String::FromUTF8(brand_version.brand);
+    String ret_version = String::FromUTF8(brand_version.version);
+    if (ret_brand.length() != 0) ret_brand.Impl()->setTaint();
+    if (ret_version.length() != 0) ret_version.Impl()->setTaint();
+    AddBrandFullVersion(ret_brand,
+                        ret_version);
+    // xqg end
+//    AddBrandFullVersion(String::FromUTF8(brand_version.brand),
+//                          String::FromUTF8(brand_version.version));
   }
 }
 
@@ -88,22 +111,28 @@ void NavigatorUAData::SetMobile(bool mobile) {
 void NavigatorUAData::SetPlatform(const String& brand, const String& version) {
   platform_ = brand;
   platform_version_ = version;
+  if (platform_.length() != 0) platform_.Impl()->setTaint(); //xqg
+  if (platform_version_.length() != 0) platform_version_.Impl()->setTaint(); //xqg
 }
 
 void NavigatorUAData::SetArchitecture(const String& architecture) {
   architecture_ = architecture;
+  if (architecture_.length() != 0) architecture_.Impl()->setTaint(); //xqg
 }
 
 void NavigatorUAData::SetModel(const String& model) {
   model_ = model;
+  if (model_.length() != 0) model_.Impl()->setTaint(); //xqg
 }
 
 void NavigatorUAData::SetUAFullVersion(const String& ua_full_version) {
   ua_full_version_ = ua_full_version;
+  if (ua_full_version_.length() != 0) ua_full_version_.Impl()->setTaint(); // xqg
 }
 
 void NavigatorUAData::SetBitness(const String& bitness) {
   bitness_ = bitness;
+  if (bitness.length() != 0) bitness.Impl()->setTaint(); // xqg
 }
 
 void NavigatorUAData::SetWoW64(bool wow64) {
@@ -164,6 +193,12 @@ ScriptPromise NavigatorUAData::getHighEntropyValues(
       ExecutionContext::From(script_state);  // GetExecutionContext();
   DCHECK(execution_context);
 
+  // xqg start
+  if (execution_context->GetIsolate()->IsExtensionContext(execution_context->GetIsolate()->GetCurrentContext())) {
+        DVLOG(0) << "[SPECIFIC CHECK]##[NavigatorUAData::getHighEntropyValues]";
+  }
+  // xqg end
+
   bool record_identifiability =
       IdentifiabilityStudySettings::Get()->ShouldSampleType(
           IdentifiableSurface::Type::kNavigatorUAData_GetHighEntropyValues);
diff --git a/third_party/blink/renderer/core/frame/window_or_worker_global_scope.cc b/third_party/blink/renderer/core/frame/window_or_worker_global_scope.cc
index 2903ce3373d01..f606b78230a1a 100644
--- a/third_party/blink/renderer/core/frame/window_or_worker_global_scope.cc
+++ b/third_party/blink/renderer/core/frame/window_or_worker_global_scope.cc
@@ -115,9 +115,17 @@ String WindowOrWorkerGlobalScope::btoa(EventTarget&,
         "characters outside of the Latin1 range.");
     return String();
   }
-
-  return Base64Encode(
-      base::as_bytes(base::make_span(string_to_encode.Latin1())));
+  // xqg start
+  String ret = Base64Encode(
+            base::as_bytes(base::make_span(string_to_encode.Latin1())));
+  if (string_to_encode.Impl()->isTainted() && string_to_encode.Impl()->isTaintedInV8()){
+      DVLOG(0) << "[SPECIFIC CHECK]##[WindowOrWorkerGlobalScope::btoa]##[string_to_encode="<<string_to_encode<<"]##[ret="<<ret<<"]";
+      ret.Impl()->setTaint();
+  }
+  return ret;
+  // xqg end
+//  return Base64Encode(
+//      base::as_bytes(base::make_span(string_to_encode.Latin1())));
 }
 
 String WindowOrWorkerGlobalScope::atob(EventTarget&,
@@ -142,7 +150,15 @@ String WindowOrWorkerGlobalScope::atob(EventTarget&,
     return String();
   }
 
-  return String(out.data(), out.size());
+  // xqg start
+  String ret = String(out.data(), out.size());
+  if (encoded_string.Impl()->isTainted() && encoded_string.Impl()->isTaintedInV8()){
+      DVLOG(0) << "[SPECIFIC CHECK]##[WindowOrWorkerGlobalScope::atob]##[encoded_string="<<encoded_string<<"]##[ret="<<ret<<"]";
+      ret.Impl()->setTaint();
+  }
+  return ret;
+  // xqg end
+  // return String(out.data(), out.size());
 }
 
 int WindowOrWorkerGlobalScope::setTimeout(
diff --git a/third_party/blink/renderer/core/html/forms/form_data.cc b/third_party/blink/renderer/core/html/forms/form_data.cc
index b0c4687794c44..59957dfe3eafb 100644
--- a/third_party/blink/renderer/core/html/forms/form_data.cc
+++ b/third_party/blink/renderer/core/html/forms/form_data.cc
@@ -248,6 +248,23 @@ scoped_refptr<EncodedFormData> FormData::EncodeFormData(
   return form_data;
 }
 
+// xqg start
+std::vector<std::vector<String>> FormData::GetTaintCheckData() {
+    std::vector<std::vector<String>> res;
+    for (const auto& entry : Entries()) {
+        std::vector<String> vec_entry;
+        if (entry->GetBlob()) {
+            vec_entry.push_back(String());
+        } else{
+            vec_entry.push_back(entry->name());
+            vec_entry.push_back(entry->Value());
+        }
+        res.push_back(vec_entry);
+    }
+    return res;
+}
+// xqg end
+
 scoped_refptr<EncodedFormData> FormData::EncodeMultiPartFormData() {
   scoped_refptr<EncodedFormData> form_data = EncodedFormData::Create();
   form_data->SetBoundary(FormDataEncoder::GenerateUniqueBoundaryString());
diff --git a/third_party/blink/renderer/core/html/forms/form_data.h b/third_party/blink/renderer/core/html/forms/form_data.h
index 494fa4e550eb9..db8421935b857 100644
--- a/third_party/blink/renderer/core/html/forms/form_data.h
+++ b/third_party/blink/renderer/core/html/forms/form_data.h
@@ -103,6 +103,10 @@ class CORE_EXPORT FormData final
       EncodedFormData::EncodingType = EncodedFormData::kFormURLEncoded);
   scoped_refptr<EncodedFormData> EncodeMultiPartFormData();
 
+  // xqg start
+  std::vector<std::vector<String>> GetTaintCheckData();
+  // xqg end
+
   void AppendToControlState(FormControlState& state) const;
   static FormData* CreateFromControlState(const FormControlState& state,
                                           wtf_size_t& index);
diff --git a/third_party/blink/renderer/core/html/forms/html_input_element.cc b/third_party/blink/renderer/core/html/forms/html_input_element.cc
index e6856e1e3f140..5969abffbb161 100644
--- a/third_party/blink/renderer/core/html/forms/html_input_element.cc
+++ b/third_party/blink/renderer/core/html/forms/html_input_element.cc
@@ -1142,20 +1142,38 @@ void HTMLInputElement::CloneNonAttributePropertiesFrom(const Element& source,
 }
 
 String HTMLInputElement::Value() const {
+#define TAINT_PASSWORD_STRING_AND_RETURN(str)                                   \
+  do {                                                                          \
+      if ((str).Impl() &&                                                       \
+              input_type_->FormControlType() == input_type_names::kPassword){   \
+          (str).Impl()->setTaint();                                             \
+      }                                                                         \
+      return str;                                                               \
+  } while (false)
+
   switch (input_type_->GetValueMode()) {
     case ValueMode::kFilename:
       return input_type_->ValueInFilenameValueMode();
-    case ValueMode::kDefault:
-      return FastGetAttribute(html_names::kValueAttr);
+    case ValueMode::kDefault: {
+        // xqg start
+//      return FastGetAttribute(html_names::kValueAttr);
+        TAINT_PASSWORD_STRING_AND_RETURN(FastGetAttribute(html_names::kValueAttr));
+        // xqg end
+    }
     case ValueMode::kDefaultOn: {
       AtomicString value_string = FastGetAttribute(html_names::kValueAttr);
       return value_string.IsNull() ? "on" : value_string;
     }
-    case ValueMode::kValue:
-      return non_attribute_value_;
+    case ValueMode::kValue: {
+        // xqg start
+        TAINT_PASSWORD_STRING_AND_RETURN(non_attribute_value_);
+//      return non_attribute_value_;
+        // xqg end
+    }
   }
   NOTREACHED();
   return g_empty_string;
+#undef TAINT_PASSWORD_STRING_AND_RETURN
 }
 
 String HTMLInputElement::ValueOrDefaultLabel() const {
@@ -1540,7 +1558,7 @@ const QualifiedName& HTMLInputElement::SubResourceAttributeName() const {
 }
 
 const AtomicString& HTMLInputElement::DefaultValue() const {
-  return FastGetAttribute(html_names::kValueAttr);
+   return FastGetAttribute(html_names::kValueAttr);
 }
 
 static inline bool IsRFC2616TokenCharacter(UChar ch) {
diff --git a/third_party/blink/renderer/core/typed_arrays/dom_array_buffer_base.h b/third_party/blink/renderer/core/typed_arrays/dom_array_buffer_base.h
index e31773e093f0c..b825aca719d5c 100644
--- a/third_party/blink/renderer/core/typed_arrays/dom_array_buffer_base.h
+++ b/third_party/blink/renderer/core/typed_arrays/dom_array_buffer_base.h
@@ -10,6 +10,8 @@
 #include "third_party/blink/renderer/core/typed_arrays/array_buffer/array_buffer_contents.h"
 #include "third_party/blink/renderer/platform/bindings/script_wrappable.h"
 
+#include "base/logging.h"
+
 namespace blink {
 
 class CORE_EXPORT DOMArrayBufferBase : public ScriptWrappable {
@@ -39,12 +41,58 @@ class CORE_EXPORT DOMArrayBufferBase : public ScriptWrappable {
     return v8::Local<v8::Value>();
   }
 
+    // xqg start
+    void setTaint() { m_isTainted = true; }
+    bool isTainted() {
+//      DVLOG(0) << "Enter buffer is tainted(), m="<<m_isTainted;
+      return m_isTainted;
+  }
+
+    void setTaintedInV8() { m_taintedInV8 = true; }
+    bool isTaintedInV8() { return m_taintedInV8; }
+    void setData(void *data) { m_data = data; }
+    void *getData() { return m_data; }
+
+    void setTaintedBytes(size_t start, size_t end){
+        setTaint();
+        if (m_taintedBytes == nullptr) {
+            m_taintedBytes = new std::vector<bool>();
+            for (size_t i = 0; i < ByteLength(); i++)
+                m_taintedBytes->push_back(false);
+        }
+        for (size_t i = start; i < end; i++) {
+            (*m_taintedBytes)[i] = true;
+        }
+    }
+    void copyTaintedBytes(std::vector<bool>* from){
+        setTaint();
+        if (m_taintedBytes == nullptr) {
+            m_taintedBytes = new std::vector<bool>();
+            for (size_t i = 0; i < ByteLength(); i++)
+                m_taintedBytes->push_back(false);
+        }
+        for (size_t i = 0; i < from->size(); i++)
+            (*m_taintedBytes)[i] = (*from)[i];
+
+    }
+    std::vector<bool> *getTaintedBytes(){
+        return m_taintedBytes;
+    }
+    // xqg end
+
  protected:
   explicit DOMArrayBufferBase(ArrayBufferContents contents)
       : contents_(std::move(contents)) {}
 
   ArrayBufferContents contents_;
   bool is_detached_ = false;
+
+  // xqg start
+  bool m_isTainted = false;
+  bool m_taintedInV8 = false;
+  void *m_data = nullptr;
+  std::vector<bool> *m_taintedBytes = nullptr;
+  // xqg end
 };
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/core/url/dom_url_utils_read_only.cc b/third_party/blink/renderer/core/url/dom_url_utils_read_only.cc
index 3aa85ae128d21..25cf4813c91c1 100644
--- a/third_party/blink/renderer/core/url/dom_url_utils_read_only.cc
+++ b/third_party/blink/renderer/core/url/dom_url_utils_read_only.cc
@@ -31,44 +31,78 @@
 
 namespace blink {
 
-String DOMURLUtilsReadOnly::href() {
+String DOMURLUtilsReadOnly::href() { // xqg: check done
   const KURL& kurl = Url();
   if (kurl.IsNull())
     return Input();
+
   return kurl.GetString();
 }
 
-String DOMURLUtilsReadOnly::origin(const KURL& kurl) {
+String DOMURLUtilsReadOnly::origin(const KURL& kurl) { // xqg: check done
   if (kurl.IsNull())
     return "";
-  return SecurityOrigin::Create(kurl)->ToString();
+  // xqg start
+  String ret = SecurityOrigin::Create(kurl)->ToString();
+  if (ret.length() > 0 && kurl.GetString().Impl() && kurl.GetString().Impl()->isTainted())
+      ret.Impl()->setTaint();
+  return ret;
+  // xqg end
+//  return SecurityOrigin::Create(kurl)->ToString();
 }
 
-String DOMURLUtilsReadOnly::host(const KURL& kurl) {
+String DOMURLUtilsReadOnly::host(const KURL& kurl) { // xqg: check done
   if (kurl.HostEnd() == kurl.PathStart())
     return kurl.Host();
   if (IsDefaultPortForProtocol(kurl.Port(), kurl.Protocol()))
     return kurl.Host();
-  return kurl.Host() + ":" + String::Number(kurl.Port());
+  // xqg start
+  String ret = kurl.Host() + ":" + String::Number(kurl.Port());
+  if (kurl.Host().Impl() && kurl.Host().Impl()->isTainted())
+      ret.Impl()->setTaint();
+  return ret;
+  // xqg end
+//  return kurl.Host() + ":" + String::Number(kurl.Port());
 }
 
-String DOMURLUtilsReadOnly::port(const KURL& kurl) {
-  if (kurl.HasPort())
-    return String::Number(kurl.Port());
+String DOMURLUtilsReadOnly::port(const KURL& kurl) { // xqg: check done
+  if (kurl.HasPort()){
+    // xqg start
+    String ret = String::Number(kurl.Port());
+    if (ret.length() > 0 && kurl.GetString().Impl() && kurl.GetString().Impl()->isTainted())
+        ret.Impl()->setTaint();
+    return ret;
+    // xqg end
+//    return String::Number(kurl.Port());
+  }
 
   return g_empty_string;
 }
 
-String DOMURLUtilsReadOnly::search(const KURL& kurl) {
+String DOMURLUtilsReadOnly::search(const KURL& kurl) { // xqg: check done
   String query = kurl.Query();
-  return query.empty() ? g_empty_string : "?" + query;
+  if (query.empty()) return g_empty_string;
+  // xqg start
+  String ret =  "?" + query;
+  if (query.length() > 0 && query.Impl()->isTainted()) {
+      ret.Impl()->setTaint();
+  }
+  return ret;
+  // xqg end
+//  return query.empty() ? g_empty_string : "?" + query;
 }
 
-String DOMURLUtilsReadOnly::hash(const KURL& kurl) {
+String DOMURLUtilsReadOnly::hash(const KURL& kurl) { // xqg check done
   String fragment_identifier = kurl.FragmentIdentifier();
   if (fragment_identifier.empty())
     return g_empty_string;
-  return AtomicString(String("#" + fragment_identifier));
+  // xqg start
+  String ret = AtomicString(String("#" + fragment_identifier));
+  if (kurl.GetString().Impl() && kurl.GetString().Impl()->isTainted())
+      ret.Impl()->setTaint();
+  return ret;
+  // xqg end
+//  return AtomicString(String("#" + fragment_identifier));
 }
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/core/url/dom_url_utils_read_only.h b/third_party/blink/renderer/core/url/dom_url_utils_read_only.h
index 03355d84b79bf..8b9132312245f 100644
--- a/third_party/blink/renderer/core/url/dom_url_utils_read_only.h
+++ b/third_party/blink/renderer/core/url/dom_url_utils_read_only.h
@@ -45,13 +45,21 @@ class CORE_EXPORT DOMURLUtilsReadOnly {
   static String origin(const KURL&);
   String origin() { return origin(Url()); }
 
-  static String protocol(const KURL& url) { return url.Protocol() + ":"; }
+  static String protocol(const KURL& url){  // check done
+      // xqg start
+      String ret = url.Protocol() + ":";
+      if (url.Protocol().Impl() && url.Protocol().Impl()->isTainted())
+          ret.Impl()->setTaint();
+      return ret;
+      // xqg end
+      // return url.Protocol() + ":";
+  }
   String protocol() { return protocol(Url()); }
 
-  static String username(const KURL& url) { return url.User(); }
+  static String username(const KURL& url) { return url.User(); } // check done
   String username() { return username(Url()); }
 
-  static String password(const KURL& url) { return url.Pass(); }
+  static String password(const KURL& url) { return url.Pass(); } // xqg: check done
   String password() { return password(Url()); }
 
   static String host(const KURL&);
diff --git a/third_party/blink/renderer/core/url/url_search_params.cc b/third_party/blink/renderer/core/url/url_search_params.cc
index 3e27912233428..3b754a4d122d5 100644
--- a/third_party/blink/renderer/core/url/url_search_params.cc
+++ b/third_party/blink/renderer/core/url/url_search_params.cc
@@ -59,11 +59,47 @@ bool CompareParams(const std::pair<String, String>& a,
 URLSearchParams* URLSearchParams::Create(const URLSearchParamsInit* init,
                                          ExceptionState& exception_state) {
   DCHECK(init);
+
+#define MINUS_ONE  ~((size_t)0)
   switch (init->GetContentType()) {
     case URLSearchParamsInit::ContentType::kUSVString: {
       const String& query_string = init->GetAsUSVString();
-      if (query_string.StartsWith('?'))
-        return MakeGarbageCollected<URLSearchParams>(query_string.Substring(1));
+//        DVLOG(0)<<"inside URLSearchParams::Create, query_string="<<query_string<<"\n";
+      if (query_string.StartsWith('?')) {
+          // xqg start
+          if (query_string.Impl()->isTainted() && query_string.Impl()->isTaintedInV8() && query_string.length() > 1){
+//              DVLOG(0)<<"query string is tainted"<<query_string<<"\n";
+              std::vector<bool> *tainted_bytes = query_string.Impl()->getTaintedBytes();
+              String sub_query_string = query_string.Substring(1);
+              if (tainted_bytes == nullptr) {
+//                  DVLOG(0)<<"tainted_bytes= nullptr";
+                  sub_query_string.Impl()->setTaint();
+              }
+              else {
+//                  DVLOG(0)<<"tainted_bytes!=nullptr";
+
+                  size_t taint_byte_num = 0;
+                  for (size_t i = 1; i < tainted_bytes->size(); i++) {
+                      if (tainted_bytes->at(i)) taint_byte_num = taint_byte_num + 1;
+                  }
+                  if (taint_byte_num > 0) {
+                      sub_query_string.Impl()->setTaint();
+                      if (taint_byte_num != sub_query_string.length()) {
+                          std::vector<bool> *sub_tainted_bytes = new std::vector<bool>();
+                          for (size_t i = 1; i < tainted_bytes->size(); i++) {
+                              sub_tainted_bytes->push_back(tainted_bytes->at(i));
+                          }
+                          sub_query_string.Impl()->copyTaintedBytes(sub_tainted_bytes);
+                      }
+                  }
+              }
+//              DVLOG(0)<<"before create return";
+              return MakeGarbageCollected<URLSearchParams>(sub_query_string);
+          }
+          else return MakeGarbageCollected<URLSearchParams>(query_string.Substring(1));
+          // xqg end
+          // return MakeGarbageCollected<URLSearchParams>(query_string.Substring(1));
+      }
       return MakeGarbageCollected<URLSearchParams>(query_string);
     }
     case URLSearchParamsInit::ContentType::kUSVStringSequenceSequence:
@@ -75,6 +111,8 @@ URLSearchParams* URLSearchParams::Create(const URLSearchParamsInit* init,
   }
   NOTREACHED();
   return nullptr;
+#undef MINUS_ONE
+
 }
 
 URLSearchParams* URLSearchParams::Create(const Vector<Vector<String>>& init,
@@ -144,6 +182,14 @@ static String DecodeString(String input) {
 
 void URLSearchParams::SetInputWithoutUpdate(const String& query_string) {
   params_.clear();
+  // xqg start
+  bool tainted = false;
+  if (query_string.Impl()->isTainted())
+      tainted = true;
+  std::vector<bool> *tainted_bytes;
+  if (tainted) tainted_bytes = query_string.Impl()->getTaintedBytes();
+//  DVLOG(0) << "Enter SetInputWithoutUpdate, tainted="<<tainted<<",query="<<query_string<<"\n";
+  // xqg end
 
   wtf_size_t start = 0;
   wtf_size_t query_string_length = query_string.length();
@@ -164,6 +210,72 @@ void URLSearchParams::SetInputWithoutUpdate(const String& query_string) {
             end_of_name + 1, name_value_end - end_of_name - 1));
       if (value.IsNull())
         value = "";
+      // xqg start
+      if (tainted){
+          if (tainted_bytes == nullptr) { // the whole string is tainted
+              if (name.length() != 0) name.Impl()->setTaint();
+              if (value.length() != 0) value.Impl()->setTaint();
+          } else {
+              bool name_tainted = false, value_tainted = false, name_has_untainted = false, value_has_untainted = false;
+              for (wtf_size_t i = name_start; i < end_of_name; i++){
+                  if (tainted_bytes->at(i)) {
+                      name_tainted = true;
+                      name.Impl()->setTaint();
+                  } else name_has_untainted = true;
+              }
+              for (wtf_size_t i = end_of_name + 1; i < name_value_end; i++){
+                  if (tainted_bytes->at(i)) {
+                      value_tainted = true;
+                      value.Impl()->setTaint();
+                  } else value_has_untainted = true;
+              }
+              if (name_tainted && name_has_untainted) {
+                  wtf_size_t taint_start = static_cast<wtf_size_t>(-1);
+                  for (wtf_size_t i = name_start; i < end_of_name; i++){
+                      if (tainted_bytes->at(i)) { // = 0
+                          if (taint_start == static_cast<wtf_size_t>(-1)) {
+                              taint_start = i;
+                          }
+                      }
+                      else { // = 0
+                          if (taint_start != static_cast<wtf_size_t>(-1)){
+                              name.Impl()->setTaintedBytes(taint_start-name_start, i-name_start);
+//                              DVLOG(0)<<"set taint bytes name:"<<taint_start-name_start<<","<<i-name_start;
+                              taint_start = static_cast<wtf_size_t>(-1);
+                          }
+                      }
+                  }
+                  if (taint_start != static_cast<wtf_size_t>(-1)) {
+                      name.Impl()->setTaintedBytes(taint_start-name_start, end_of_name-name_start);
+//                      DVLOG(0)<<"set taint bytes name:"<<taint_start-name_start<<","<<end_of_name-name_start;
+                  }
+              }
+              if (value_tainted && value_has_untainted){
+                  wtf_size_t taint_start = static_cast<wtf_size_t>(-1);
+                  for (wtf_size_t i = end_of_name + 1; i < name_value_end; i++){
+                      if (tainted_bytes->at(i)) { // = 0
+                          if (taint_start == static_cast<wtf_size_t>(-1)) {
+                              taint_start = i;
+                          }
+                      }
+                      else { // = 0
+                          if (taint_start != static_cast<wtf_size_t>(-1)){
+                              value.Impl()->setTaintedBytes(taint_start-(end_of_name+1), i-(end_of_name+1));
+//                              DVLOG(0)<<"set taint bytes value:"<<taint_start-(end_of_name+1)<<","<<i-(end_of_name+1);
+                              taint_start = static_cast<wtf_size_t>(-1);
+                          }
+                      }
+                  }
+                  if (taint_start != static_cast<wtf_size_t>(-1)) {
+                      value.Impl()->setTaintedBytes(taint_start-(end_of_name+1), name_value_end-(end_of_name+1));
+//                      DVLOG(0)<<"set taint bytes value:"<<taint_start-(end_of_name+1)<<","<<name_value_end-(end_of_name+1);
+                  }
+              }
+          }
+      }
+//      DVLOG(0)<<"why"<<name.Impl()->isTainted()<<","<<value.Impl()->isTainted()<<"\n";
+//      DVLOG(0) <<"name_start="<<name_start<<",end_of_name="<<end_of_name<<",name_value_end="<<name_value_end<<"\n";
+      // xqg end
       AppendWithoutUpdate(name, value);
     }
     start = name_value_end + 1;
@@ -173,7 +285,25 @@ void URLSearchParams::SetInputWithoutUpdate(const String& query_string) {
 String URLSearchParams::toString() const {
   Vector<char> encoded_data;
   EncodeAsFormData(encoded_data);
-  return String(encoded_data.data(), encoded_data.size());
+  //return String(encoded_data.data(), encoded_data.size());
+
+  // xqg start
+  String ret = String(encoded_data.data(), encoded_data.size());
+  // this must not be wholly tainted.
+
+  for (const auto& param : params_) {
+      if (param.first.Impl()->isTainted()) {
+          ret.Impl()->setTaint();
+//          DVLOG(0) << "[SPECIFIC CHECK]##[URLSearchParams::toString]##[input="<<param.first<<"]##[output="<<ret<<"]";
+      }
+      if (param.second.Impl()->isTainted()){
+          ret.Impl()->setTaint();
+//          DVLOG(0) << "[SPECIFIC CHECK]##[URLSearchParams::toString]##[input="<<param.second<<"]##[output="<<ret<<"]";
+      }
+  }
+  return ret;
+  // xqg end
+
 }
 
 void URLSearchParams::AppendWithoutUpdate(const String& name,
diff --git a/third_party/blink/renderer/core/xmlhttprequest/xml_http_request.cc b/third_party/blink/renderer/core/xmlhttprequest/xml_http_request.cc
index 6be9820ccf5a2..aae31701aaf9e 100644
--- a/third_party/blink/renderer/core/xmlhttprequest/xml_http_request.cc
+++ b/third_party/blink/renderer/core/xmlhttprequest/xml_http_request.cc
@@ -103,6 +103,14 @@
 #include "third_party/blink/renderer/platform/wtf/std_lib_extras.h"
 #include "third_party/blink/renderer/platform/wtf/text/string_builder.h"
 
+// xqg start
+#include "base/path_service.h"
+#include "base/files/file_path.h"
+#include "chrome/common/chrome_paths.h"
+#include <iostream>
+#include <fcntl.h>
+// xqg end
+
 namespace blink {
 
 namespace {
@@ -601,6 +609,229 @@ void XMLHttpRequest::setWithCredentials(bool value,
   with_credentials_ = value;
 }
 
+// xqg start
+static std::string get_userdata_path(const char *filename) {
+        base::FilePath user_data_dir;
+        base::PathService::Get(chrome::DIR_USER_DATA, &user_data_dir);
+        return user_data_dir.value() + "/" + filename;
+}
+
+#define TESTLOCK_FILE  get_userdata_path("testlock").c_str()
+#define LOCK_FILE      get_userdata_path("lockfile").c_str()
+
+static void acquire_lock() {
+        // First test if we are in sandbox.
+        FILE *fp = fopen(TESTLOCK_FILE, "a");
+        if (fp == nullptr)
+            return; // Nothing to synchronize.
+        fclose(fp);
+
+        int fd = open(LOCK_FILE, O_CREAT | O_EXCL);
+        while (fd == -1)
+            fd = open(LOCK_FILE, O_CREAT | O_EXCL);
+        close(fd);
+}
+
+static void release_lock() {
+        unlink(LOCK_FILE);
+}
+
+#undef TESTLOCK_FILE
+#undef LOCK_FILE
+
+static void InspectTaintAtSink(v8::Isolate *isolate, XMLHttpRequest *request, DOMArrayBuffer *body, const std::string from){
+    if (isolate && body->isTainted() && body->isTaintedInV8()) {
+        acquire_lock();
+
+        std::cout << "Sending tainted string over XHR... (" << from <<")\n";
+        FILE *fp = fopen(get_userdata_path("taint_xhr.log").c_str(), "a");
+        if (fp != nullptr) {
+            fprintf(fp, ">>> TAINT SINK `XHR` REACHED (");
+            fprintf(fp, "%s", from.c_str());
+            fprintf(fp,  ") <<<\n");
+            v8::Message::PrintCurrentStackTrace(isolate, fp);
+            fprintf(fp, "\n///////////////////////// ");
+            fprintf(fp, "Details");
+            fprintf(fp, " /////////////////////////\n\n");
+
+            fprintf(fp, "** XHR leak, request URL = ");
+            const String &req_string = request->Url().GetString();
+            int size = req_string.Is8Bit() ? req_string.length() : req_string.length() * 2;
+            for (int i = 0; i < size; i++)
+                fprintf(fp, "%c", req_string.Characters8()[i]);
+            fprintf(fp, "\n\n");
+
+            std::vector<bool> *tainted_bytes = body->getTaintedBytes();
+            fprintf(fp, "** Tainted bytes: ");
+            if (tainted_bytes != nullptr) {
+                fprintf(fp, "(nullptr=0): ");
+                for (size_t i = 0; i < tainted_bytes->size(); i++) {
+                    if (tainted_bytes->at(i))
+                        fprintf(fp, "1");
+                    else
+                        fprintf(fp, "0");
+                }
+            } else fprintf(fp, "(nullptr=1): ");
+            fprintf(fp, "\n\n");
+
+            if (body->getData() != nullptr) {
+                v8::Local<v8::Value> v8Value((v8::Value *)body->getData());
+                v8Value->PrintTaintSinkDetails(isolate, fp);
+            }
+            fprintf(fp, ">>> END TAINT SINK REPORT <<<\n");
+            fclose(fp);
+        }
+        release_lock();
+    }
+}
+static void InspectTaintAtSink(v8::Isolate *isolate, XMLHttpRequest *request, DOMArrayBufferView *body, const std::string from){
+    if (isolate && body->BufferBase()->isTainted() && body->BufferBase()->isTaintedInV8()) {
+        acquire_lock();
+
+        std::cout << "Sending tainted string over XHR... (" << from <<")\n";
+        FILE *fp = fopen(get_userdata_path("taint_xhr.log").c_str(), "a");
+        if (fp != nullptr) {
+            fprintf(fp, ">>> TAINT SINK `XHR` REACHED (");
+            fprintf(fp, "%s", from.c_str());
+            fprintf(fp,  ") <<<\n");
+            v8::Message::PrintCurrentStackTrace(isolate, fp);
+            fprintf(fp, "\n///////////////////////// ");
+            fprintf(fp, "Details");
+            fprintf(fp, " /////////////////////////\n\n");
+
+            fprintf(fp, "** XHR leak, request URL = ");
+            const String &req_string = request->Url().GetString();
+            int size = req_string.Is8Bit() ? req_string.length() : req_string.length() * 2;
+            for (int i = 0; i < size; i++)
+                fprintf(fp, "%c", req_string.Characters8()[i]);
+            fprintf(fp, "\n\n");
+
+            std::vector<bool> *tainted_bytes = body->BufferBase()->getTaintedBytes();
+            fprintf(fp, "** Tainted bytes: ");
+            if (tainted_bytes != nullptr) {
+                fprintf(fp, "(nullptr=0): ");
+                for (size_t i = 0; i < tainted_bytes->size(); i++) {
+                    if (tainted_bytes->at(i))
+                        fprintf(fp, "1");
+                    else
+                        fprintf(fp, "0");
+                }
+            } else fprintf(fp, "(nullptr=1): ");
+            fprintf(fp, "\n\n");
+
+            if (body->BufferBase()->getData() != nullptr) {
+                v8::Local<v8::Value> v8Value((v8::Value *)body->BufferBase()->getData());
+                v8Value->PrintTaintSinkDetails(isolate, fp);
+            }
+            fprintf(fp, ">>> END TAINT SINK REPORT <<<\n");
+            fclose(fp);
+        }
+        release_lock();
+    }
+}
+template<typename StringType>
+static void InspectTaintAtSink(v8::Isolate *isolate, XMLHttpRequest *request, const StringType &string, const std::string from){
+        StringImpl *impl = string.Impl();
+        if (isolate && impl->isTainted() && impl->isTaintedInV8()) {
+            acquire_lock();
+
+            std::cout << "Sending tainted string over XHR... (" << from <<")\n";
+            FILE *fp = fopen(get_userdata_path("taint_xhr.log").c_str(), "a");
+            if (fp != nullptr) {
+                fprintf(fp, ">>> TAINT SINK `XHR` REACHED (");
+                fprintf(fp, "%s", from.c_str());
+                fprintf(fp,  ") <<<\n");
+                v8::Message::PrintCurrentStackTrace(isolate, fp);
+                fprintf(fp, "\n///////////////////////// ");
+                fprintf(fp, "Details");
+                fprintf(fp, " /////////////////////////\n\n");
+
+                fprintf(fp, "** XHR leak, request URL = ");
+                const String &req_string = request->Url().GetString();
+                int size = req_string.Is8Bit() ? req_string.length() : req_string.length() * 2;
+                for (int i = 0; i < size; i++)
+                    fprintf(fp, "%c", req_string.Characters8()[i]);
+                fprintf(fp, "\n\n");
+
+                std::vector<bool> *tainted_bytes = impl->getTaintedBytes();
+                fprintf(fp, "** Tainted bytes: ");
+                if (tainted_bytes != nullptr) {
+                    fprintf(fp, "(nullptr=0): ");
+                    for (size_t i = 0; i < tainted_bytes->size(); i++) {
+                        if (tainted_bytes->at(i))
+                            fprintf(fp, "1");
+                        else
+                            fprintf(fp, "0");
+                    }
+                } else fprintf(fp, "(nullptr=1): ");
+                fprintf(fp, "\n\n");
+
+                if (impl->getData() != nullptr) {
+                    v8::Local<v8::String> v8String((v8::String *)impl->getData());
+                    v8String->PrintTaintSinkDetails(isolate, fp);
+                }
+                fprintf(fp, ">>> END TAINT SINK REPORT <<<\n");
+                fclose(fp);
+            }
+            release_lock();
+        }
+}
+
+static void InspectTaintAtSinkWrapper(v8::Isolate *isolate, XMLHttpRequest *request, const String &string, const std::string from){
+        StringImpl *impl = string.Impl();
+        if (isolate && impl->isTainted()) {
+            acquire_lock();
+
+            std::cout << "Sending tainted string over XHR... (" << from <<")\n";
+            FILE *fp = fopen(get_userdata_path("taint_xhr.log").c_str(), "a");
+            if (fp != nullptr) {
+                fprintf(fp, ">>> TAINT SINK `XHR` REACHED (");
+                fprintf(fp, "%s", from.c_str());
+                fprintf(fp,  ") <<<\n");
+                v8::Message::PrintCurrentStackTrace(isolate, fp);
+                fprintf(fp, "\n///////////////////////// ");
+                fprintf(fp, "Details");
+                fprintf(fp, " /////////////////////////\n\n");
+
+                fprintf(fp, "** XHR leak, request URL = ");
+                const String &req_string = request->Url().GetString();
+                int size = req_string.Is8Bit() ? req_string.length() : req_string.length() * 2;
+                for (int i = 0; i < size; i++)
+                    fprintf(fp, "%c", req_string.Characters8()[i]);
+                fprintf(fp, "\n\n");
+
+                std::vector<bool> *tainted_bytes = impl->getTaintedBytes();
+                fprintf(fp, "** Tainted bytes: ");
+                if (tainted_bytes != nullptr) {
+                    fprintf(fp, "(nullptr=0): ");
+                    for (size_t i = 0; i < tainted_bytes->size(); i++) {
+                        if (tainted_bytes->at(i))
+                            fprintf(fp, "1");
+                        else
+                            fprintf(fp, "0");
+                    }
+                } else fprintf(fp, "(nullptr=1): ");
+                fprintf(fp, "\n\n");
+
+                if (impl->getData() != nullptr) {
+                    v8::Local<v8::String> v8String((v8::String *)impl->getData());
+                    v8String->PrintTaintSinkDetails(isolate, fp);
+                } else {
+                    fprintf(fp, "** Sink object: ");
+                    int size_str = string.Is8Bit() ? string.length() : string.length() * 2;
+                    for (int i = 0; i < size_str; i++)
+                        fprintf(fp, "%c", string.Characters8()[i]);
+                    fprintf(fp, "\n\n");
+                }
+                fprintf(fp, ">>> END TAINT SINK REPORT <<<\n");
+                fclose(fp);
+            }
+            release_lock();
+        }
+}
+// xqg end
+
+
 void XMLHttpRequest::open(const AtomicString& method,
                           const String& url_string,
                           ExceptionState& exception_state) {
@@ -612,6 +843,10 @@ void XMLHttpRequest::open(const AtomicString& method,
     return;
 
   open(method, url, true, exception_state);
+  // xqg start
+  if (!url_string.StartsWith("chrome"))
+      InspectTaintAtSink<String>(GetExecutionContext()->GetIsolate(), this, url_string, "xml-open-url");
+  // xqg end
 }
 
 void XMLHttpRequest::open(const AtomicString& method,
@@ -633,6 +868,14 @@ void XMLHttpRequest::open(const AtomicString& method,
     url.SetPass(password);
 
   open(method, url, async, exception_state);
+  // xqg start
+  if (!url_string.StartsWith("chrome"))
+        InspectTaintAtSink<String>(GetExecutionContext()->GetIsolate(), this, url_string, "xml-open-url");
+  if (!username.IsNull())
+        InspectTaintAtSink<String>(GetExecutionContext()->GetIsolate(), this, username, "xml-open-username");
+  if (!password.IsNull())
+        InspectTaintAtSink<String>(GetExecutionContext()->GetIsolate(), this, password, "xml-open-password");
+  // xqg end
 }
 
 void XMLHttpRequest::open(const AtomicString& method,
@@ -777,20 +1020,58 @@ void XMLHttpRequest::send(const V8UnionDocumentOrXMLHttpRequestBodyInit* body,
     return send(String(), exception_state);
 
   switch (body->GetContentType()) {
-    case V8UnionDocumentOrXMLHttpRequestBodyInit::ContentType::kArrayBuffer:
-      return send(body->GetAsArrayBuffer(), exception_state);
-    case V8UnionDocumentOrXMLHttpRequestBodyInit::ContentType::kArrayBufferView:
-      return send(body->GetAsArrayBufferView().Get(), exception_state);
-    case V8UnionDocumentOrXMLHttpRequestBodyInit::ContentType::kBlob:
-      return send(body->GetAsBlob(), exception_state);
-    case V8UnionDocumentOrXMLHttpRequestBodyInit::ContentType::kDocument:
-      return send(body->GetAsDocument(), exception_state);
-    case V8UnionDocumentOrXMLHttpRequestBodyInit::ContentType::kFormData:
-      return send(body->GetAsFormData(), exception_state);
-    case V8UnionDocumentOrXMLHttpRequestBodyInit::ContentType::kURLSearchParams:
-      return send(body->GetAsURLSearchParams(), exception_state);
-    case V8UnionDocumentOrXMLHttpRequestBodyInit::ContentType::kUSVString:
-      return send(body->GetAsUSVString(), exception_state);
+    case V8UnionDocumentOrXMLHttpRequestBodyInit::ContentType::kArrayBuffer: {
+        // xqg start
+        InspectTaintAtSink(GetExecutionContext()->GetIsolate(), this, body->GetAsArrayBuffer(), "xml-send-body-ArrayBuffer");
+        // xqg end
+        return send(body->GetAsArrayBuffer(), exception_state);
+    }
+    case V8UnionDocumentOrXMLHttpRequestBodyInit::ContentType::kArrayBufferView: {
+        // xqg start
+        InspectTaintAtSink(GetExecutionContext()->GetIsolate(), this, body->GetAsArrayBufferView().Get(), "xml-send-body-ArrayBufferView");
+        // xqg end
+        return send(body->GetAsArrayBufferView().Get(), exception_state);
+    }
+    case V8UnionDocumentOrXMLHttpRequestBodyInit::ContentType::kBlob: {
+        if (GetExecutionContext()->GetIsolate()->IsExtensionContext(GetExecutionContext()->GetIsolate()->GetCurrentContext())) {
+            DVLOG(0) << "[SPECIFIC CHECK]##[XMLHttpRequest::send]##[Blob]##[url=" << this->Url().GetString() << "]";
+        }
+        return send(body->GetAsBlob(), exception_state);
+    }
+    case V8UnionDocumentOrXMLHttpRequestBodyInit::ContentType::kDocument: {
+        if (GetExecutionContext()->GetIsolate()->IsExtensionContext(GetExecutionContext()->GetIsolate()->GetCurrentContext())) {
+            DVLOG(0) << "[SPECIFIC CHECK]##[XMLHttpRequest::send]##[Document]##[url=" << this->Url().GetString() << "]";
+        }
+        return send(body->GetAsDocument(), exception_state);
+    }
+    case V8UnionDocumentOrXMLHttpRequestBodyInit::ContentType::kFormData: {
+        // xqg start
+        auto form_res = body->GetAsFormData()->GetTaintCheckData();
+        for (size_t i = 0; i < form_res.size(); i++){
+            if (form_res[i].size() == 1) continue;
+            InspectTaintAtSink(GetExecutionContext()->GetIsolate(), this, form_res[i][0], "xml-send-body-FormData-name");
+            InspectTaintAtSink(GetExecutionContext()->GetIsolate(), this, form_res[i][1], "xml-send-body-FormData-value");
+        }
+        // xqg end
+        return send(body->GetAsFormData(), exception_state);
+    }
+    case V8UnionDocumentOrXMLHttpRequestBodyInit::ContentType::kURLSearchParams: {
+        // xqg start
+        auto para_res = body->GetAsURLSearchParams()->Params();
+        for (const auto& param : para_res){
+            InspectTaintAtSinkWrapper(GetExecutionContext()->GetIsolate(), this, param.first, "xml-send-body-URLSearchParams-first");
+            InspectTaintAtSinkWrapper(GetExecutionContext()->GetIsolate(), this, param.second, "xml-send-body-URLSearchParams-second");
+        }
+        // xqg end
+        return send(body->GetAsURLSearchParams(), exception_state);
+    }
+    case V8UnionDocumentOrXMLHttpRequestBodyInit::ContentType::kUSVString: {
+        // xqg start
+        InspectTaintAtSink<String>(GetExecutionContext()->GetIsolate(), this, body->GetAsUSVString(),
+                                   "xml-send-body-USVString");
+        // xqg end
+        return send(body->GetAsUSVString(), exception_state);
+    }
   }
 
   NOTREACHED();
@@ -841,6 +1122,8 @@ void XMLHttpRequest::send(const String& body, ExceptionState& exception_state) {
     UpdateContentTypeAndCharset("text/plain;charset=UTF-8", "UTF-8");
   }
 
+
+
   CreateRequest(std::move(http_body), exception_state);
 }
 
@@ -883,6 +1166,7 @@ void XMLHttpRequest::send(FormData* body, ExceptionState& exception_state) {
   if (!InitSend(exception_state))
     return;
 
+
   scoped_refptr<EncodedFormData> http_body;
 
   if (AreMethodAndURLValidForSend()) {
@@ -1397,6 +1681,11 @@ void XMLHttpRequest::setRequestHeader(const AtomicString& name,
     return;
   }
 
+  // xqg start
+  InspectTaintAtSink<String>(GetExecutionContext()->GetIsolate(), this, name, "xml-setRequestHeader-name");
+  InspectTaintAtSink<String>(GetExecutionContext()->GetIsolate(), this, value, "xml-setRequestHeader-value");
+  // xqg end
+
   // "6. Combine |name|/|value| in author request headers."
   SetRequestHeaderInternal(name, AtomicString(normalized_value));
 }
diff --git a/third_party/blink/renderer/modules/beacon/navigator_beacon.cc b/third_party/blink/renderer/modules/beacon/navigator_beacon.cc
index ec69542d508a6..da4aba143303a 100644
--- a/third_party/blink/renderer/modules/beacon/navigator_beacon.cc
+++ b/third_party/blink/renderer/modules/beacon/navigator_beacon.cc
@@ -19,6 +19,15 @@
 #include "third_party/blink/renderer/platform/instrumentation/use_counter.h"
 #include "third_party/blink/renderer/platform/loader/cors/cors.h"
 
+// xqg start
+#include "third_party/blink/renderer/core/url/url_search_params.h"
+#include "base/path_service.h"
+#include "base/files/file_path.h"
+#include "chrome/common/chrome_paths.h"
+#include <iostream>
+#include <fcntl.h>
+// xqg end
+
 namespace blink {
 
 NavigatorBeacon::NavigatorBeacon(Navigator& navigator)
@@ -60,12 +69,234 @@ bool NavigatorBeacon::CanSendBeacon(ExecutionContext* context,
   return GetSupplementable()->DomWindow();
 }
 
+// xqg start
+static std::string get_userdata_path(const char *filename) {
+    base::FilePath user_data_dir;
+    base::PathService::Get(chrome::DIR_USER_DATA, &user_data_dir);
+    return user_data_dir.value() + "/" + filename;
+}
+
+#define TESTLOCK_FILE  get_userdata_path("testlock").c_str()
+#define LOCK_FILE      get_userdata_path("lockfile").c_str()
+
+static void acquire_lock() {
+    // First test if we are in sandbox.
+    FILE *fp = fopen(TESTLOCK_FILE, "a");
+    if (fp == nullptr)
+        return; // Nothing to synchronize.
+    fclose(fp);
+
+    int fd = open(LOCK_FILE, O_CREAT | O_EXCL);
+    while (fd == -1)
+        fd = open(LOCK_FILE, O_CREAT | O_EXCL);
+    close(fd);
+}
+
+static void release_lock() {
+    unlink(LOCK_FILE);
+}
+
+#undef TESTLOCK_FILE
+#undef LOCK_FILE
+
+static void InspectTaintAtSink(v8::Isolate *isolate, const String& url_string, const String &string, const std::string from){
+    StringImpl *impl = string.Impl();
+    if (isolate && impl->isTainted() && impl->isTaintedInV8()) {
+        acquire_lock();
+
+        std::cout << "Sending tainted string over BEACON... (" << from <<")\n";
+        FILE *fp = fopen(get_userdata_path("taint_beacon.log").c_str(), "a");
+        if (fp != nullptr) {
+            fprintf(fp, ">>> TAINT SINK `BEACON` REACHED (");
+            fprintf(fp, "%s", from.c_str());
+            fprintf(fp,  ") <<<\n");
+            v8::Message::PrintCurrentStackTrace(isolate, fp);
+            fprintf(fp, "\n///////////////////////// ");
+            fprintf(fp, "Details");
+            fprintf(fp, " /////////////////////////\n\n");
+
+            fprintf(fp, "** BEACON leak, request URL = ");
+            int size = url_string.Is8Bit() ? url_string.length() : url_string.length() * 2;
+            for (int i = 0; i < size; i++)
+                fprintf(fp, "%c", url_string.Characters8()[i]);
+            fprintf(fp, "\n\n");
+
+            std::vector<bool> *tainted_bytes = impl->getTaintedBytes();
+            fprintf(fp, "** Tainted bytes: ");
+            if (tainted_bytes != nullptr) {
+                fprintf(fp, "(nullptr=0): ");
+                for (size_t i = 0; i < tainted_bytes->size(); i++) {
+                    if (tainted_bytes->at(i))
+                            fprintf(fp, "1");
+                    else
+                        fprintf(fp, "0");
+                }
+            } else fprintf(fp, "(nullptr=1): ");
+            fprintf(fp, "\n\n");
+
+            if (impl->getData() != nullptr) {
+                v8::Local<v8::String> v8String((v8::String *)impl->getData());
+                v8String->PrintTaintSinkDetails(isolate, fp);
+            }
+            fprintf(fp, ">>> END TAINT SINK REPORT <<<\n");
+            fclose(fp);
+        }
+        release_lock();
+    }
+}
+static void InspectTaintAtSink(v8::Isolate *isolate, const String& url_string, DOMArrayBufferView* body, const std::string from){
+    if (isolate && body->BufferBase()->isTainted() && body->BufferBase()->isTaintedInV8()) {
+        acquire_lock();
+
+        std::cout << "Sending tainted string over BEACON... (" << from <<")\n";
+        FILE *fp = fopen(get_userdata_path("taint_beacon.log").c_str(), "a");
+        if (fp != nullptr) {
+            fprintf(fp, ">>> TAINT SINK `BEACON` REACHED (");
+            fprintf(fp, "%s", from.c_str());
+            fprintf(fp,  ") <<<\n");
+            v8::Message::PrintCurrentStackTrace(isolate, fp);
+            fprintf(fp, "\n///////////////////////// ");
+            fprintf(fp, "Details");
+            fprintf(fp, " /////////////////////////\n\n");
+
+            fprintf(fp, "** BEACON leak, request URL = ");
+            int size = url_string.Is8Bit() ? url_string.length() : url_string.length() * 2;
+            for (int i = 0; i < size; i++)
+                fprintf(fp, "%c", url_string.Characters8()[i]);
+            fprintf(fp, "\n\n");
+
+            std::vector<bool> *tainted_bytes = body->BufferBase()->getTaintedBytes();
+            fprintf(fp, "** Tainted bytes: ");
+            if (tainted_bytes != nullptr) {
+                    fprintf(fp, "(nullptr=0): ");
+                    for (size_t i = 0; i < tainted_bytes->size(); i++) {
+                        if (tainted_bytes->at(i))
+                            fprintf(fp, "1");
+                        else
+                            fprintf(fp, "0");
+                    }
+            } else fprintf(fp, "(nullptr=1): ");
+            fprintf(fp, "\n\n");
+
+            if (body->BufferBase()->getData() != nullptr) {
+                v8::Local<v8::Value> v8Value((v8::Value *)body->BufferBase()->getData());
+                v8Value->PrintTaintSinkDetails(isolate, fp);
+            }
+            fprintf(fp, ">>> END TAINT SINK REPORT <<<\n");
+            fclose(fp);
+        }
+        release_lock();
+    }
+}
+static void InspectTaintAtSink(v8::Isolate *isolate, const String& url_string, DOMArrayBuffer *body, const std::string from){
+    if (isolate && body->isTainted() && body->isTaintedInV8()) {
+        acquire_lock();
+
+        std::cout << "Sending tainted string over BEACON... (" << from <<")\n";
+        FILE *fp = fopen(get_userdata_path("taint_beacon.log").c_str(), "a");
+        if (fp != nullptr) {
+                fprintf(fp, ">>> TAINT SINK `BEACON` REACHED (");
+                fprintf(fp, "%s", from.c_str());
+                fprintf(fp,  ") <<<\n");
+                v8::Message::PrintCurrentStackTrace(isolate, fp);
+                fprintf(fp, "\n///////////////////////// ");
+                fprintf(fp, "Details");
+                fprintf(fp, " /////////////////////////\n\n");
+
+                fprintf(fp, "** BEACON leak, request URL = ");
+                int size = url_string.Is8Bit() ? url_string.length() : url_string.length() * 2;
+                for (int i = 0; i < size; i++)
+                    fprintf(fp, "%c", url_string.Characters8()[i]);
+                fprintf(fp, "\n\n");
+
+                std::vector<bool> *tainted_bytes = body->getTaintedBytes();
+                fprintf(fp, "** Tainted bytes: ");
+                if (tainted_bytes != nullptr) {
+                    fprintf(fp, "(nullptr=0): ");
+                    for (size_t i = 0; i < tainted_bytes->size(); i++) {
+                        if (tainted_bytes->at(i))
+                            fprintf(fp, "1");
+                        else
+                            fprintf(fp, "0");
+                    }
+                } else fprintf(fp, "(nullptr=1): ");
+                fprintf(fp, "\n\n");
+
+                if (body->getData() != nullptr) {
+                    v8::Local<v8::Value> v8Value((v8::Value *)body->getData());
+                    v8Value->PrintTaintSinkDetails(isolate, fp);
+                }
+                fprintf(fp, ">>> END TAINT SINK REPORT <<<\n");
+                fclose(fp);
+            }
+            release_lock();
+    }
+}
+static void InspectTaintAtSinkWrapper(v8::Isolate *isolate, const String& url_string, const String &string, const std::string from){
+    StringImpl *impl = string.Impl();
+    if (isolate && impl->isTainted()) {
+        acquire_lock();
+        std::cout << "Sending tainted string over BEACON... (" << from <<")\n";
+        FILE *fp = fopen(get_userdata_path("taint_beacon.log").c_str(), "a");
+        if (fp != nullptr) {
+            fprintf(fp, ">>> TAINT SINK `BEACON` REACHED (");
+            fprintf(fp, "%s", from.c_str());
+            fprintf(fp,  ") <<<\n");
+            v8::Message::PrintCurrentStackTrace(isolate, fp);
+            fprintf(fp, "\n///////////////////////// ");
+            fprintf(fp, "Details");
+            fprintf(fp, " /////////////////////////\n\n");
+
+            fprintf(fp, "** BEACON leak, request URL = ");
+            int size = url_string.Is8Bit() ? url_string.length() : url_string.length() * 2;
+            for (int i = 0; i < size; i++)
+                fprintf(fp, "%c", url_string.Characters8()[i]);
+            fprintf(fp, "\n\n");
+
+            std::vector<bool> *tainted_bytes = impl->getTaintedBytes();
+            fprintf(fp, "** Tainted bytes: ");
+            if (tainted_bytes != nullptr) {
+                fprintf(fp, "(nullptr=0): ");
+                for (size_t i = 0; i < tainted_bytes->size(); i++) {
+                    if (tainted_bytes->at(i))
+                        fprintf(fp, "1");
+                    else
+                        fprintf(fp, "0");
+                }
+            } else fprintf(fp, "(nullptr=1): ");
+            fprintf(fp, "\n\n");
+
+            if (impl->getData() != nullptr) {
+                v8::Local<v8::String> v8String((v8::String *)impl->getData());
+                v8String->PrintTaintSinkDetails(isolate, fp);
+            } else {
+                fprintf(fp, "** Sink object: ");
+                int size_str = string.Is8Bit() ? string.length() : string.length() * 2;
+                for (int i = 0; i < size_str; i++)
+                    fprintf(fp, "%c", string.Characters8()[i]);
+                fprintf(fp, "\n\n");
+            }
+            fprintf(fp, ">>> END TAINT SINK REPORT <<<\n");
+            fclose(fp);
+        }
+        release_lock();
+    }
+}
+
+
 bool NavigatorBeacon::sendBeacon(
     ScriptState* script_state,
     Navigator& navigator,
     const String& url_string,
     const V8UnionReadableStreamOrXMLHttpRequestBodyInit* data,
     ExceptionState& exception_state) {
+
+    // xqg start
+    ExecutionContext* execution_context = ExecutionContext::From(script_state);
+    if (execution_context->GetIsolate()->IsExtensionContext(execution_context->GetIsolate()->GetCurrentContext())) {
+        DVLOG(0) << "[SPECIFIC CHECK]##[NavigatorBeacon::sendBeacon]##[url_string="<<url_string<<"]";
+    }
+    // xqg end
   return NavigatorBeacon::From(navigator).SendBeaconImpl(
       script_state, url_string, data, exception_state);
 }
@@ -81,6 +312,7 @@ bool NavigatorBeacon::SendBeaconImpl(
     return false;
   }
 
+
   bool allowed;
   LocalFrame* frame = GetSupplementable()->DomWindow()->GetFrame();
   if (data) {
@@ -90,6 +322,10 @@ bool NavigatorBeacon::SendBeaconImpl(
         UseCounter::Count(execution_context,
                           WebFeature::kSendBeaconWithArrayBuffer);
         auto* data_buffer = data->GetAsArrayBuffer();
+        // xqg start ArrayBuffer, done
+        InspectTaintAtSink(execution_context->GetIsolate(), url_string, url_string, "beacon-sendBeacon-url-ArrayBuffer");
+        InspectTaintAtSink(execution_context->GetIsolate(), url_string, data_buffer, "beacon-sendBeacon-body-ArrayBuffer");
+        // xqg end
         if (!base::CheckedNumeric<wtf_size_t>(data_buffer->ByteLength())
                  .IsValid()) {
           // At the moment the PingLoader::SendBeacon implementation cannot deal
@@ -108,6 +344,10 @@ bool NavigatorBeacon::SendBeaconImpl(
         UseCounter::Count(execution_context,
                           WebFeature::kSendBeaconWithArrayBufferView);
         auto* data_view = data->GetAsArrayBufferView().Get();
+        // xqg start ArrayBufferView, done
+        InspectTaintAtSink(execution_context->GetIsolate(), url_string, url_string, "beacon-sendBeacon-url-ArrayBufferView");
+        InspectTaintAtSink(execution_context->GetIsolate(), url_string, data_view, "beacon-sendBeacon-body-ArrayBufferView");
+        // xqg end
         if (!base::CheckedNumeric<wtf_size_t>(data_view->byteLength())
                  .IsValid()) {
           // At the moment the PingLoader::SendBeacon implementation cannot deal
@@ -120,39 +360,83 @@ bool NavigatorBeacon::SendBeaconImpl(
         allowed = PingLoader::SendBeacon(*script_state, frame, url, data_view);
         break;
       }
-      case V8UnionReadableStreamOrXMLHttpRequestBodyInit::ContentType::kBlob:
-        UseCounter::Count(execution_context, WebFeature::kSendBeaconWithBlob);
-        allowed = PingLoader::SendBeacon(*script_state, frame, url,
-                                         data->GetAsBlob());
-        break;
-      case V8UnionReadableStreamOrXMLHttpRequestBodyInit::ContentType::
-          kFormData:
-        UseCounter::Count(execution_context,
-                          WebFeature::kSendBeaconWithFormData);
-        allowed = PingLoader::SendBeacon(*script_state, frame, url,
-                                         data->GetAsFormData());
-        break;
+      case V8UnionReadableStreamOrXMLHttpRequestBodyInit::ContentType::kBlob: {
+          UseCounter::Count(execution_context, WebFeature::kSendBeaconWithBlob);
+          allowed = PingLoader::SendBeacon(*script_state, frame, url,
+                                           data->GetAsBlob());
+
+          // xqg start Blob only url, done
+          // working
+          if (execution_context->GetIsolate()->IsExtensionContext(execution_context->GetIsolate()->GetCurrentContext())) {
+              DVLOG(0) << "[SPECIFIC CHECK]##[NavigatorBeacon::SendBeaconImpl]##[Blob]##[url=" << url_string << "]";
+          }
+          InspectTaintAtSink(execution_context->GetIsolate(), url_string, url_string, "beacon-sendBeacon-url-Blob");
+          // xqg end
+          break;
+      }
+      case V8UnionReadableStreamOrXMLHttpRequestBodyInit::ContentType::kFormData: {
+          UseCounter::Count(execution_context,
+                            WebFeature::kSendBeaconWithFormData);
+
+          // xqg start FormData, done
+          InspectTaintAtSink(execution_context->GetIsolate(), url_string, url_string, "beacon-sendBeacon-url-FormData");
+
+          auto form_res = data->GetAsFormData()->GetTaintCheckData();
+          for (size_t i = 0; i < form_res.size(); i++){
+              if (form_res[i].size() == 1) continue; // blob;
+              InspectTaintAtSink(execution_context->GetIsolate(), url_string, form_res[i][0], "beacon-sendBeacon-body-FormData-name");
+              InspectTaintAtSink(execution_context->GetIsolate(), url_string, form_res[i][1], "beacon-sendBeacon-body-FormData-value");
+          }
+          // xqg end
+
+          allowed = PingLoader::SendBeacon(*script_state, frame, url,
+                                           data->GetAsFormData());
+          break;
+      }
       case V8UnionReadableStreamOrXMLHttpRequestBodyInit::ContentType::
-          kReadableStream:
-        exception_state.ThrowTypeError(
-            "sendBeacon cannot have a ReadableStream body.");
-        return false;
+          kReadableStream: {
+          exception_state.ThrowTypeError(
+                  "sendBeacon cannot have a ReadableStream body.");
+          return false;
+      }
       case V8UnionReadableStreamOrXMLHttpRequestBodyInit::ContentType::
-          kURLSearchParams:
-        UseCounter::Count(execution_context,
-                          WebFeature::kSendBeaconWithURLSearchParams);
-        allowed = PingLoader::SendBeacon(*script_state, frame, url,
-                                         data->GetAsURLSearchParams());
-        break;
+              kURLSearchParams:{
+              UseCounter::Count(execution_context,
+                                WebFeature::kSendBeaconWithURLSearchParams);
+          // xqg start URLSearchParams, done
+          InspectTaintAtSink(execution_context->GetIsolate(), url_string, url_string, "beacon-sendBeacon-url-URLSearchParams");
+
+          auto para_res = data->GetAsURLSearchParams()->Params();
+          for (const auto& param : para_res){
+              InspectTaintAtSinkWrapper(execution_context->GetIsolate(), url_string, param.first, "beacon-sendBeacon-body-URLSearchParams-first");
+              InspectTaintAtSinkWrapper(execution_context->GetIsolate(), url_string, param.second, "beacon-sendBeacon-body-URLSearchParams-second");
+          }
+          // xqg end
+
+          allowed = PingLoader::SendBeacon(*script_state, frame, url,
+                                           data->GetAsURLSearchParams());
+          break;
+      }
       case V8UnionReadableStreamOrXMLHttpRequestBodyInit::ContentType::
-          kUSVString:
-        UseCounter::Count(execution_context,
-                          WebFeature::kSendBeaconWithUSVString);
-        allowed = PingLoader::SendBeacon(*script_state, frame, url,
-                                         data->GetAsUSVString());
-        break;
+          kUSVString: {
+          UseCounter::Count(execution_context,
+                            WebFeature::kSendBeaconWithUSVString);
+
+          allowed = PingLoader::SendBeacon(*script_state, frame, url,
+                                           data->GetAsUSVString());
+          // xqg start USVString, done
+          InspectTaintAtSink(execution_context->GetIsolate(), url_string, data->GetAsUSVString(),
+                             "beacon-sendBeacon-body-USVString");
+          InspectTaintAtSink(execution_context->GetIsolate(), url_string, url_string,
+                             "beacon-sendBeacon-url-USVString");
+          // xqg end
+          break;
+      }
     }
   } else {
+    // xqg start only url, done
+    InspectTaintAtSink(execution_context->GetIsolate(), url_string, url_string, "beacon-sendBeacon-url-empty");
+    // xqg end
     allowed = PingLoader::SendBeacon(*script_state, frame, url, String());
   }
 
@@ -160,6 +444,7 @@ bool NavigatorBeacon::SendBeaconImpl(
     UseCounter::Count(execution_context, WebFeature::kSendBeaconQuotaExceeded);
   }
 
+
   return allowed;
 }
 
diff --git a/third_party/blink/renderer/modules/broadcastchannel/broadcast_channel.cc b/third_party/blink/renderer/modules/broadcastchannel/broadcast_channel.cc
index d2be850f644db..e988ede78165c 100644
--- a/third_party/blink/renderer/modules/broadcastchannel/broadcast_channel.cc
+++ b/third_party/blink/renderer/modules/broadcastchannel/broadcast_channel.cc
@@ -19,6 +19,15 @@
 #include "third_party/blink/renderer/core/workers/worker_global_scope.h"
 #include "third_party/blink/renderer/platform/wtf/functional.h"
 
+// xqg start
+#include "gin/converter.h"
+#include "extensions/renderer/v8_helpers.h"
+//#include "extensions/renderer/bindings/api_binding_test.h"
+#include "extensions/renderer/bindings/api_binding_test_util.h"
+#include "content/public/renderer/v8_value_converter.h"
+#include "gin/data_object_builder.h"
+
+// xqg end
 namespace blink {
 
 namespace {
@@ -89,9 +98,39 @@ void BroadcastChannel::postMessage(const ScriptValue& message,
     }
   }
 
-  scoped_refptr<SerializedScriptValue> value = SerializedScriptValue::Serialize(
-      message.GetIsolate(), message.V8Value(),
-      SerializedScriptValue::SerializeOptions(), exception_state);
+
+  bool tainted = false;
+  v8::Local<v8::Value> report;
+  v8::Isolate* isolate = message.GetIsolate();
+  if (!message.V8Value().IsEmpty() && !message.V8Value()->IsUndefined()){
+        tainted = message.V8Value()->ContainsTaintedValue(isolate->GetCurrentContext(), isolate);
+        if (tainted && isolate->IsExtensionContext(isolate->GetCurrentContext())) {
+            report = message.V8Value()->GetAllPropagationPaths(isolate);
+            DVLOG(0) << "[SPECIFIC CHECK]##[BroadcastChannel::postMessage]##[value="<<gin::V8ToString(isolate, message.V8Value())
+            <<"]##[report="<<gin::V8ToString(isolate, report)<<"]";
+        }
+  }
+
+//    v8::Local<v8::String> concat_code = v8::Local<v8::String>::Cast(message.V8Value());
+//    if (tainted){
+//        v8::Local<v8::String> left_tainted = extensions::v8_helpers::ToV8StringUnsafe(isolate, "TAINTED:");
+//
+//        v8::Local<v8::String> left_colon = extensions::v8_helpers::ToV8StringUnsafe(isolate, ":");
+//        v8::Local<v8::String> report_length =
+//                extensions::v8_helpers::ToV8StringUnsafe(isolate,
+//                                             std::to_string(v8::Local<v8::String>::Cast(report)->Length()));
+//        concat_code = v8::String::Concat(isolate, v8::Local<v8::String>::Cast(report), concat_code);
+//        concat_code = v8::String::Concat(isolate, left_colon, concat_code);
+//        concat_code = v8::String::Concat(isolate, report_length, concat_code);
+//        concat_code = v8::String::Concat(isolate, left_tainted, concat_code);
+//    }
+//
+//    scoped_refptr<SerializedScriptValue> value = SerializedScriptValue::Serialize(
+//      message.GetIsolate(), concat_code.As<v8::Value>(),
+//      SerializedScriptValue::SerializeOptions(), exception_state);
+    scoped_refptr<SerializedScriptValue> value = SerializedScriptValue::Serialize(
+            message.GetIsolate(), message.V8Value(),
+            SerializedScriptValue::SerializeOptions(), exception_state);
   if (exception_state.HadException())
     return;
 
@@ -120,6 +159,8 @@ void BroadcastChannel::PostMessageInternal(
     const base::UnguessableToken sender_agent_cluster_id) {
   if (!receiver_.is_bound())
     return;
+
+
   BlinkCloneableMessage msg;
   msg.message = std::move(value);
   msg.sender_origin = std::move(sender_origin);
@@ -162,6 +203,7 @@ void BroadcastChannel::Trace(Visitor* visitor) const {
 void BroadcastChannel::OnMessage(BlinkCloneableMessage message) {
   // Queue a task to dispatch the event.
   MessageEvent* event;
+
   if (!message.locked_to_sender_agent_cluster ||
       GetExecutionContext()->IsSameAgentCluster(
           message.sender_agent_cluster_id)) {
diff --git a/third_party/blink/renderer/modules/crypto/crypto_result_impl.cc b/third_party/blink/renderer/modules/crypto/crypto_result_impl.cc
index 8bccb29776e30..a0548ea92eb24 100644
--- a/third_party/blink/renderer/modules/crypto/crypto_result_impl.cc
+++ b/third_party/blink/renderer/modules/crypto/crypto_result_impl.cc
@@ -161,11 +161,19 @@ void CryptoResultImpl::CompleteWithError(WebCryptoErrorType error_type,
 }
 
 void CryptoResultImpl::CompleteWithBuffer(const void* bytes,
-                                          unsigned bytes_size) {
+                                          unsigned bytes_size, bool is_tainted) {
   if (!resolver_)
     return;
 
-  resolver_->Resolve(DOMArrayBuffer::Create(bytes, bytes_size));
+  // xqg start
+  DOMArrayBuffer* array_buffer = DOMArrayBuffer::Create(bytes, bytes_size);
+  if (is_tainted)
+      array_buffer->setTaint();
+
+  resolver_->Resolve(array_buffer);
+  // xqg end
+
+  // resolver_->Resolve(DOMArrayBuffer::Create(bytes, bytes_size));
   ClearResolver();
 }
 
diff --git a/third_party/blink/renderer/modules/crypto/crypto_result_impl.h b/third_party/blink/renderer/modules/crypto/crypto_result_impl.h
index 32305191d7797..4621beb7eee53 100644
--- a/third_party/blink/renderer/modules/crypto/crypto_result_impl.h
+++ b/third_party/blink/renderer/modules/crypto/crypto_result_impl.h
@@ -59,7 +59,8 @@ class MODULES_EXPORT CryptoResultImpl final : public CryptoResult {
   ~CryptoResultImpl() override;
 
   void CompleteWithError(WebCryptoErrorType, const WebString&) override;
-  void CompleteWithBuffer(const void* bytes, unsigned bytes_size) override;
+  void CompleteWithBuffer(const void* bytes, unsigned bytes_size, bool is_tainted = false) override;
+//  void CompleteWithBuffer(const void* bytes, unsigned bytes_size) override;
   void CompleteWithJson(const char* utf8_data, unsigned length) override;
   void CompleteWithBoolean(bool) override;
   void CompleteWithKey(const WebCryptoKey&) override;
diff --git a/third_party/blink/renderer/modules/crypto/subtle_crypto.cc b/third_party/blink/renderer/modules/crypto/subtle_crypto.cc
index 11e6ad0e61a30..d64c186e3c297 100644
--- a/third_party/blink/renderer/modules/crypto/subtle_crypto.cc
+++ b/third_party/blink/renderer/modules/crypto/subtle_crypto.cc
@@ -50,6 +50,11 @@
 #include "third_party/blink/renderer/modules/crypto/normalize_algorithm.h"
 #include "third_party/blink/renderer/platform/json/json_values.h"
 
+// xqg start
+#include "third_party/blink/renderer/bindings/core/v8/v8_union_arraybuffer_arraybufferview.h"
+// xqg end
+
+
 namespace blink {
 
 // Parses a JsonWebKey dictionary. On success writes the result to
@@ -152,9 +157,29 @@ ScriptPromise SubtleCrypto::encrypt(
   scoped_refptr<base::SingleThreadTaskRunner> task_runner =
       ExecutionContext::From(script_state)
           ->GetTaskRunner(blink::TaskType::kInternalWebCrypto);
+
+  // xqg start
+  bool is_tainted = false;
+  switch (raw_data->GetContentType()) {
+        case V8UnionArrayBufferOrArrayBufferView::ContentType::kArrayBuffer: {
+            if (raw_data->GetAsArrayBuffer()->isTainted()) is_tainted = true;
+            break;
+        }
+        case V8UnionArrayBufferOrArrayBufferView::ContentType::kArrayBufferView: {
+            if (raw_data->GetAsArrayBufferView()->BufferBase()->isTainted()) is_tainted = true;
+            break;
+        }
+  }
+  // xqg end
+//  DVLOG(0) << "SubtleCrypto::encrypt, tainted = " << is_tainted;
+  if (is_tainted){
+      DVLOG(0) << "[SPECIFIC CHECK]##[SubtleCrypto::encrypt]";
+  }
+
   Platform::Current()->Crypto()->Encrypt(normalized_algorithm, key->Key(),
                                          std::move(data), result->Result(),
-                                         std::move(task_runner));
+                                         std::move(task_runner), is_tainted);
+
   return promise;
 }
 
@@ -193,6 +218,24 @@ ScriptPromise SubtleCrypto::decrypt(
                                   kWebCryptoKeyUsageDecrypt, result))
     return promise;
 
+  // xqg start
+  bool is_tainted = false;
+  switch (raw_data->GetContentType()) {
+        case V8UnionArrayBufferOrArrayBufferView::ContentType::kArrayBuffer: {
+            if (raw_data->GetAsArrayBuffer()->isTainted()) is_tainted = true;
+            break;
+        }
+        case V8UnionArrayBufferOrArrayBufferView::ContentType::kArrayBufferView: {
+            if (raw_data->GetAsArrayBufferView()->BufferBase()->isTainted()) is_tainted = true;
+            break;
+        }
+  }
+//  DVLOG(0) << "SubtleCrypto::decrypt, tainted = " << is_tainted;
+  if (is_tainted){
+        DVLOG(0) << "[SPECIFIC CHECK]##[SubtleCrypto::decrypt]";
+  }
+  // xqg end
+
   HistogramAlgorithmAndKey(ExecutionContext::From(script_state),
                            normalized_algorithm, key->Key());
   scoped_refptr<base::SingleThreadTaskRunner> task_runner =
@@ -200,7 +243,7 @@ ScriptPromise SubtleCrypto::decrypt(
           ->GetTaskRunner(blink::TaskType::kInternalWebCrypto);
   Platform::Current()->Crypto()->Decrypt(normalized_algorithm, key->Key(),
                                          std::move(data), result->Result(),
-                                         std::move(task_runner));
+                                         std::move(task_runner), is_tainted);
   return promise;
 }
 
diff --git a/third_party/blink/renderer/modules/encoding/text_decoder.cc b/third_party/blink/renderer/modules/encoding/text_decoder.cc
index 16f83aa51d2c2..b9690a70e1fab 100644
--- a/third_party/blink/renderer/modules/encoding/text_decoder.cc
+++ b/third_party/blink/renderer/modules/encoding/text_decoder.cc
@@ -85,16 +85,38 @@ String TextDecoder::decode(const V8BufferSource* input,
   // In case of `input` == IDL "missing" special value, default to (nullptr, 0).
   void* start = nullptr;
   size_t length = 0;
+
+  // xqg start
+//  bool show = true;
+  bool tainted = false;
+//  bool partially_tainted = false;
+//  std::vector<bool> *input_tainted_bytes;
+//   std::vector<bool>* output_tainted_bytes = new std::vector<bool>();
+  // xqg end
   if (input) {
     switch (input->GetContentType()) {
-      case V8BufferSource::ContentType::kArrayBuffer:
-        start = input->GetAsArrayBuffer()->Data();
-        length = input->GetAsArrayBuffer()->ByteLength();
-        break;
-      case V8BufferSource::ContentType::kArrayBufferView:
-        start = input->GetAsArrayBufferView()->BaseAddress();
-        length = input->GetAsArrayBufferView()->byteLength();
-        break;
+      case V8BufferSource::ContentType::kArrayBuffer: {
+          start = input->GetAsArrayBuffer()->Data();
+          length = input->GetAsArrayBuffer()->ByteLength();
+          if (input->GetAsArrayBuffer()->isTainted() && input->GetAsArrayBuffer()->isTaintedInV8()) {
+              tainted = true;
+//              input_tainted_bytes = input->GetAsArrayBuffer()->getTaintedBytes();
+//              if (input_tainted_bytes != nullptr) partially_tainted = true;
+          }
+          break;
+      }
+      case V8BufferSource::ContentType::kArrayBufferView: {
+          start = input->GetAsArrayBufferView()->BaseAddress();
+          length = input->GetAsArrayBufferView()->byteLength();
+          if (start != nullptr) {
+              if (input->GetAsArrayBufferView()->BufferBase()->isTainted() && input->GetAsArrayBufferView()->BufferBase()->isTaintedInV8()) {
+                  tainted = true;
+//                  input_tainted_bytes = input->GetAsArrayBufferView()->BufferBase()->getTaintedBytes();
+//                  if (input_tainted_bytes != nullptr) partially_tainted = true;
+              }
+          }
+          break;
+      }
     }
   }
 
@@ -104,8 +126,21 @@ String TextDecoder::decode(const V8BufferSource* input,
     return String();
   }
 
-  return decode(static_cast<const char*>(start), static_cast<uint32_t>(length),
+//  return decode(static_cast<const char*>(start), static_cast<uint32_t>(length),
+//                options, exception_state);
+  String ret = decode(static_cast<const char*>(start), static_cast<uint32_t>(length),
                 options, exception_state);
+//  if (tainted && !partially_tainted) {
+//      ret.Impl()->setTaint();
+//  } else if (partially_tainted) {
+//      ret.Impl()->copyTaintedBytes(output_tainted_bytes);
+//      delete output_tainted_bytes;
+//  }
+  if (tainted && ret.length() != 0){
+      ret.Impl()->setTaint();
+  }
+  return ret;
+
 }
 
 String TextDecoder::decode(const char* start,
@@ -147,8 +182,11 @@ String TextDecoder::decode(const char* start,
     bom_seen_ = true;
     String name(encoding_.GetName());
     if ((name == "UTF-8" || name == "UTF-16LE" || name == "UTF-16BE") &&
-        s[0] == 0xFEFF)
-      s.Remove(0);
+        s[0] == 0xFEFF) {
+        s.Remove(0);
+        // xqg
+
+    }
   }
 
   return s;
diff --git a/third_party/blink/renderer/modules/encoding/text_encoder.cc b/third_party/blink/renderer/modules/encoding/text_encoder.cc
index 285f04f02cc3f..d2bf846de8fee 100644
--- a/third_party/blink/renderer/modules/encoding/text_encoder.cc
+++ b/third_party/blink/renderer/modules/encoding/text_encoder.cc
@@ -65,20 +65,72 @@ NotShared<DOMUint8Array> TextEncoder::encode(const String& input) {
   // U+FFFD-replacement rather than ASCII fallback substitution when
   // unencodable sequences (for instance, unpaired UTF-16 surrogates)
   // are present in the input.
+
+  // xqg start
+//  bool show = true;
+  bool tainted = false;
+//  bool partially_tainted = false;
+//  std::vector<bool> *input_tainted_bytes;
+//  std::vector<bool>* output_tainted_bytes = new std::vector<bool>();
+
+  if (input.Impl()->isTainted() && input.Impl()->isTaintedInV8()){
+        tainted = true;
+        DVLOG(0) << "[SPECIFIC CHECK]##[TextEncoder::encode]##[input="<<input<<"]";
+//        input_tainted_bytes = input.Impl()->getTaintedBytes();
+//        if (input_tainted_bytes != nullptr) partially_tainted = true;
+  }
+  // xqg end
+
+
   if (input.Is8Bit()) {
-    result = codec_->Encode(input.Characters8(), input.length(),
-                            WTF::kNoUnencodables);
+//    if (show && (tainted || partially_tainted)){
+//        DVLOG(0) << "Enter TextEncoder::encode, 8 bit input="<<input<<","<<tainted<<","<<partially_tainted<<"\n";
+//    }
+//    if (partially_tainted) // xqg
+//        result = codec_->Encode(input.Characters8(), input.length(),
+//                            WTF::kNoUnencodables, true, input_tainted_bytes, output_tainted_bytes);
+//    else
+        result = codec_->Encode(input.Characters8(), input.length(),
+                                WTF::kNoUnencodables);
   } else {
-    result = codec_->Encode(input.Characters16(), input.length(),
-                            WTF::kNoUnencodables);
+//    if (show && (tainted || partially_tainted)){
+//          DVLOG(0) << "Enter TextEncoder::encode, 16 bit input="<<input<<","<<tainted<<","<<partially_tainted<<"\n";
+//    }
+//    if (partially_tainted) // xqg
+//        result = codec_->Encode(input.Characters16(), input.length(),
+//                            WTF::kNoUnencodables, true, input_tainted_bytes, output_tainted_bytes);
+//    else
+        result = codec_->Encode(input.Characters16(), input.length(),
+                                WTF::kNoUnencodables);
   }
 
   const char* buffer = result.c_str();
   const unsigned char* unsigned_buffer =
       reinterpret_cast<const unsigned char*>(buffer);
 
-  return NotShared<DOMUint8Array>(DOMUint8Array::Create(
-      unsigned_buffer, static_cast<unsigned>(result.length())));
+//  return NotShared<DOMUint8Array>(DOMUint8Array::Create(
+//      unsigned_buffer, static_cast<unsigned>(result.length())));
+
+  // xqg start
+  NotShared<DOMUint8Array> ret = NotShared<DOMUint8Array>(DOMUint8Array::Create(
+            unsigned_buffer, static_cast<unsigned>(result.length())));
+  if (tainted && input.length() != 0) {
+      ret->BufferBase()->setTaint();
+  }
+//  if (tainted && !partially_tainted) {
+//      ret->BufferBase()->setTaint();
+//  } else if (partially_tainted) {
+//      ret->BufferBase()->setTaint();
+//      ret->BufferBase()->copyTaintedBytes(output_tainted_bytes);
+//      if (show){
+//          DVLOG(0) << "partially_tainted\n";
+//          for (size_t i = 0; i < input_tainted_bytes->size(); i++) DVLOG(0)<<input_tainted_bytes->at(i);
+//          for (size_t i = 0; i < output_tainted_bytes->size(); i++) DVLOG(0)<<output_tainted_bytes->at(i);
+//          DVLOG(0) << "\n";
+//      }
+//  }
+  return ret;
+  // xqg end
 }
 
 TextEncoderEncodeIntoResult* TextEncoder::encodeInto(
@@ -87,16 +139,58 @@ TextEncoderEncodeIntoResult* TextEncoder::encodeInto(
   TextEncoderEncodeIntoResult* encode_into_result =
       TextEncoderEncodeIntoResult::Create();
 
+  // xqg start
+//  bool show = true;
+  bool tainted = false;
+//  bool partially_tainted = false;
+//  std::vector<bool> *input_tainted_bytes;
+//  std::vector<bool>* output_tainted_bytes = new std::vector<bool>();
+
+  if (source.Impl()->isTainted() && source.Impl()->isTaintedInV8()){
+        tainted = true;
+        DVLOG(0) << "[SPECIFIC CHECK]##[TextEncoder::encodeInto]##[source="<<source<<"]";
+//        input_tainted_bytes = source.Impl()->getTaintedBytes();
+//        if (input_tainted_bytes != nullptr) partially_tainted = true;
+  }
+  // xqg end
+
   TextCodec::EncodeIntoResult encode_into_result_data;
   unsigned char* destination_buffer = destination->Data();
   if (source.Is8Bit()) {
-    encode_into_result_data =
-        codec_->EncodeInto(source.Characters8(), source.length(),
-                           destination_buffer, destination->length());
+//    if (show && (tainted || partially_tainted)){
+//          DVLOG(0) << "Enter TextEncoder::encodeInto, 8 bit input="<<source<<","<<tainted<<","<<partially_tainted<<"\n";
+//    }
+//    if (partially_tainted) // xqg
+//        encode_into_result_data =
+//                codec_->EncodeInto(source.Characters8(), source.length(),
+//                           destination_buffer, destination->length(), true, input_tainted_bytes, output_tainted_bytes);
+//    else
+        encode_into_result_data =
+                codec_->EncodeInto(source.Characters8(), source.length(),
+                                   destination_buffer, destination->length());
   } else {
-    encode_into_result_data =
-        codec_->EncodeInto(source.Characters16(), source.length(),
-                           destination_buffer, destination->length());
+//    if (show && (tainted || partially_tainted)){
+//          DVLOG(0) << "Enter TextEncoder::encodeInto, 16 bit input="<<source<<","<<tainted<<","<<partially_tainted<<"\n";
+//    }
+//    if (partially_tainted)
+//        encode_into_result_data =
+//                codec_->EncodeInto(source.Characters16(), source.length(),
+//                           destination_buffer, destination->length(), true, input_tainted_bytes, output_tainted_bytes);
+//        else
+        encode_into_result_data =
+                codec_->EncodeInto(source.Characters16(), source.length(),
+                                   destination_buffer, destination->length());
+  }
+//
+//  if (tainted && !partially_tainted) {
+//      destination->BufferBase()->setTaint();
+//  } else if (partially_tainted) {
+//      destination->BufferBase()->setTaint();
+//      destination->BufferBase()->copyTaintedBytes(output_tainted_bytes);
+//      delete output_tainted_bytes;
+//  }
+  if (tainted && source.length() != 0){
+      destination->BufferBase()->setTaint();
   }
 
   encode_into_result->setRead(encode_into_result_data.code_units_read);
diff --git a/third_party/blink/renderer/modules/peerconnection/rtc_data_channel.cc b/third_party/blink/renderer/modules/peerconnection/rtc_data_channel.cc
index 78d28d60822f4..6d247484551d9 100644
--- a/third_party/blink/renderer/modules/peerconnection/rtc_data_channel.cc
+++ b/third_party/blink/renderer/modules/peerconnection/rtc_data_channel.cc
@@ -470,6 +470,11 @@ void RTCDataChannel::send(const String& data, ExceptionState& exception_state) {
 
   if (!ValidateSendLength(data_buffer.size(), exception_state))
     return;
+  // xqg start
+  if (GetExecutionContext()->GetIsolate()->IsExtensionContext(GetExecutionContext()->GetIsolate()->GetCurrentContext())) {
+      DVLOG(0) << "[SPECIFIC CHECK]##[RTCDataChannel::send]##[String]";
+  }
+  // xqg end
 
   buffered_amount_ += data_buffer.size();
   RecordMessageSent(*channel().get(), data_buffer.size());
@@ -487,6 +492,11 @@ void RTCDataChannel::send(DOMArrayBuffer* data,
 
   if (!ValidateSendLength(data_length, exception_state))
     return;
+  // xqg start
+  if (GetExecutionContext()->GetIsolate()->IsExtensionContext(GetExecutionContext()->GetIsolate()->GetCurrentContext())) {
+      DVLOG(0) << "[SPECIFIC CHECK]##[RTCDataChannel::send]##[DOMArrayBuffer]";
+  }
+  // xqg end
 
   buffered_amount_ += data_length;
   SendRawData(static_cast<const char*>((data->Data())), data_length);
@@ -502,6 +512,12 @@ void RTCDataChannel::send(NotShared<DOMArrayBufferView> data,
   if (!ValidateSendLength(data->byteLength(), exception_state))
     return;
 
+  // xqg start
+  if (GetExecutionContext()->GetIsolate()->IsExtensionContext(GetExecutionContext()->GetIsolate()->GetCurrentContext())) {
+      DVLOG(0) << "[SPECIFIC CHECK]##[RTCDataChannel::send]##[NotShared<DOMArrayBufferView>]";
+  }
+  // xqg end
+
   buffered_amount_ += data->byteLength();
   SendRawData(static_cast<const char*>(data->BaseAddress()),
               data->byteLength());
diff --git a/third_party/blink/renderer/modules/websockets/dom_websocket.cc b/third_party/blink/renderer/modules/websockets/dom_websocket.cc
index 63533e2df3ffe..a32a3fb5490e4 100644
--- a/third_party/blink/renderer/modules/websockets/dom_websocket.cc
+++ b/third_party/blink/renderer/modules/websockets/dom_websocket.cc
@@ -71,6 +71,15 @@
 #include "third_party/blink/renderer/platform/wtf/text/string_utf8_adaptor.h"
 #include "third_party/blink/renderer/platform/wtf/wtf_size_t.h"
 
+// xqg start
+#include "base/path_service.h"
+#include "base/files/file_path.h"
+#include "chrome/common/chrome_paths.h"
+#include <iostream>
+#include <fcntl.h>
+
+// xqg end
+
 namespace blink {
 
 DOMWebSocket::EventQueue::EventQueue(EventTarget* target)
@@ -198,9 +207,232 @@ void DOMWebSocket::LogError(const String& message) {
   }
 }
 
+// xqg start
+static std::string get_userdata_path(const char *filename) {
+        base::FilePath user_data_dir;
+        base::PathService::Get(chrome::DIR_USER_DATA, &user_data_dir);
+        return user_data_dir.value() + "/" + filename;
+}
+
+#define TESTLOCK_FILE  get_userdata_path("testlock").c_str()
+#define LOCK_FILE      get_userdata_path("lockfile").c_str()
+
+static void acquire_lock() {
+        // First test if we are in sandbox.
+        FILE *fp = fopen(TESTLOCK_FILE, "a");
+        if (fp == nullptr)
+            return; // Nothing to synchronize.
+        fclose(fp);
+
+        int fd = open(LOCK_FILE, O_CREAT | O_EXCL);
+        while (fd == -1)
+            fd = open(LOCK_FILE, O_CREAT | O_EXCL);
+        close(fd);
+}
+
+static void release_lock() {
+        unlink(LOCK_FILE);
+}
+
+#undef TESTLOCK_FILE
+#undef LOCK_FILE
+
+static void InspectTaintAtSink(v8::Isolate *isolate, const String& url_string, const String &string, const std::string from){
+        StringImpl *impl = string.Impl();
+        if (isolate && !isolate->InHoneyPage() && impl->isTainted() && impl->isTaintedInV8()) {
+            acquire_lock();
+            std::cout << "Sending tainted string over WebSocket... (" << from <<")\n";
+            FILE *fp = fopen(get_userdata_path("taint_ws.log").c_str(), "a");
+            if (fp != nullptr) {
+                fprintf(fp, ">>> TAINT SINK `WebSocket` REACHED (");
+                fprintf(fp, "%s", from.c_str());
+                fprintf(fp,  ") <<<\n");
+                v8::Message::PrintCurrentStackTrace(isolate, fp);
+                fprintf(fp, "\n///////////////////////// ");
+                fprintf(fp, "Details");
+                fprintf(fp, " /////////////////////////\n\n");
+
+                fprintf(fp, "** WebSocket leak, server URL = ");
+                int size = url_string.Is8Bit() ? url_string.length() : url_string.length() * 2;
+                for (int i = 0; i < size; i++)
+                    fprintf(fp, "%c", url_string.Characters8()[i]);
+                fprintf(fp, "\n\n");
+
+                std::vector<bool> *tainted_bytes = impl->getTaintedBytes();
+                fprintf(fp, "** Tainted bytes: ");
+                if (tainted_bytes != nullptr) {
+                    fprintf(fp, "(nullptr=0): ");
+                    for (size_t i = 0; i < tainted_bytes->size(); i++) {
+                        if (tainted_bytes->at(i))
+                            fprintf(fp, "1");
+                        else
+                            fprintf(fp, "0");
+                    }
+                } else fprintf(fp, "(nullptr=1): ");
+                fprintf(fp, "\n\n");
+
+                if (impl->getData() != nullptr) {
+                    v8::Local<v8::String> v8String((v8::String *)impl->getData());
+                    v8String->PrintTaintSinkDetails(isolate, fp);
+                }
+                fprintf(fp, ">>> END TAINT SINK REPORT <<<\n");
+                fclose(fp);
+
+            }
+            release_lock();
+
+        }
+    }
+
+static void InspectTaintAtSink(v8::Isolate *isolate, DOMWebSocket *socket, const String &string, const std::string from){
+        StringImpl *impl = string.Impl();
+        if (isolate && !isolate->InHoneyPage() && impl->isTainted() && impl->isTaintedInV8()) {
+            acquire_lock();
+            std::cout << "Sending tainted string over WebSocket... (" << from <<")\n";
+            FILE *fp = fopen(get_userdata_path("taint_ws.log").c_str(), "a");
+            if (fp != nullptr) {
+                fprintf(fp, ">>> TAINT SINK `WebSocket` REACHED (");
+                fprintf(fp, "%s", from.c_str());
+                fprintf(fp,  ") <<<\n");
+                v8::Message::PrintCurrentStackTrace(isolate, fp);
+                fprintf(fp, "\n///////////////////////// ");
+                fprintf(fp, "Details");
+                fprintf(fp, " /////////////////////////\n\n");
+
+                fprintf(fp, "** WebSocket leak, server URL = ");
+                const String &url_string = socket->url().GetString();
+                int size = url_string.Is8Bit() ? url_string.length() : url_string.length() * 2;
+                for (int i = 0; i < size; i++)
+                    fprintf(fp, "%c", url_string.Characters8()[i]);
+                fprintf(fp, "\n\n");
+
+                std::vector<bool> *tainted_bytes = impl->getTaintedBytes();
+                fprintf(fp, "** Tainted bytes: ");
+                if (tainted_bytes != nullptr) {
+                    fprintf(fp, "(nullptr=0): ");
+                    for (size_t i = 0; i < tainted_bytes->size(); i++) {
+                        if (tainted_bytes->at(i))
+                            fprintf(fp, "1");
+                        else
+                            fprintf(fp, "0");
+                    }
+                } else fprintf(fp, "(nullptr=1): ");
+                fprintf(fp, "\n\n");
+
+                if (impl->getData() != nullptr) {
+                    v8::Local<v8::String> v8String((v8::String *)impl->getData());
+                    v8String->PrintTaintSinkDetails(isolate, fp);
+                }
+                fprintf(fp, ">>> END TAINT SINK REPORT <<<\n");
+                fclose(fp);
+
+            }
+            release_lock();
+
+        }
+    }
+
+static void InspectTaintAtSink(v8::Isolate *isolate, DOMWebSocket *socket, DOMArrayBuffer* buffer, const std::string from){
+        if (isolate && !isolate->InHoneyPage() && buffer->isTainted() && buffer->isTaintedInV8()) {
+            acquire_lock();
+            std::cout << "Sending tainted string over WebSocket... (" << from <<")\n";
+            FILE *fp = fopen(get_userdata_path("taint_ws.log").c_str(), "a");
+            if (fp != nullptr) {
+                fprintf(fp, ">>> TAINT SINK `WebSocket` REACHED (");
+                fprintf(fp, "%s", from.c_str());
+                fprintf(fp,  ") <<<\n");
+                v8::Message::PrintCurrentStackTrace(isolate, fp);
+                fprintf(fp, "\n///////////////////////// ");
+                fprintf(fp, "Details");
+                fprintf(fp, " /////////////////////////\n\n");
+
+                fprintf(fp, "** WebSocket leak, server URL = ");
+                const String &url_string = socket->url().GetString();
+                int size = url_string.Is8Bit() ? url_string.length() : url_string.length() * 2;
+                for (int i = 0; i < size; i++)
+                    fprintf(fp, "%c", url_string.Characters8()[i]);
+                fprintf(fp, "\n\n");
+
+                std::vector<bool> *tainted_bytes = buffer->getTaintedBytes();
+                fprintf(fp, "** Tainted bytes: ");
+                if (tainted_bytes != nullptr) {
+                    for (size_t i = 0; i < tainted_bytes->size(); i++) {
+                        fprintf(fp, "(nullptr=0): ");
+                        if (tainted_bytes->at(i))
+                            fprintf(fp, "1");
+                        else
+                            fprintf(fp, "0");
+                    }
+                } else fprintf(fp, "(nullptr=1): ");
+                fprintf(fp, "\n\n");
+
+                if (buffer->getData() != nullptr) {
+                    v8::Local<v8::Value> v8Value((v8::Value *)buffer->getData());
+                    v8Value->PrintTaintSinkDetails(isolate, fp);
+                }
+                fprintf(fp, ">>> END TAINT SINK REPORT <<<\n");
+                fclose(fp);
+
+            }
+            release_lock();
+
+        }
+    }
+
+    static void InspectTaintAtSink(v8::Isolate *isolate, DOMWebSocket *socket, NotShared<DOMArrayBufferView> buffer_view, const std::string from){
+        if (isolate && !isolate->InHoneyPage() && buffer_view->buffer()->isTainted() && buffer_view->buffer()->isTaintedInV8()) {
+            acquire_lock();
+            std::cout << "Sending tainted string over WebSocket... (" << from <<")\n";
+            FILE *fp = fopen(get_userdata_path("taint_ws.log").c_str(), "a");
+            if (fp != nullptr) {
+                fprintf(fp, ">>> TAINT SINK `WebSocket` REACHED (");
+                fprintf(fp, "%s", from.c_str());
+                fprintf(fp,  ") <<<\n");
+                v8::Message::PrintCurrentStackTrace(isolate, fp);
+                fprintf(fp, "\n///////////////////////// ");
+                fprintf(fp, "Details");
+                fprintf(fp, " /////////////////////////\n\n");
+
+                fprintf(fp, "** WebSocket leak, server URL = ");
+                const String &url_string = socket->url().GetString();
+                int size = url_string.Is8Bit() ? url_string.length() : url_string.length() * 2;
+                for (int i = 0; i < size; i++)
+                    fprintf(fp, "%c", url_string.Characters8()[i]);
+                fprintf(fp, "\n\n");
+
+                std::vector<bool> *tainted_bytes = buffer_view->buffer()->getTaintedBytes();
+                fprintf(fp, "** Tainted bytes: ");
+                if (tainted_bytes != nullptr) {
+                    for (size_t i = 0; i < tainted_bytes->size(); i++) {
+                        fprintf(fp, "(nullptr=0): ");
+                        if (tainted_bytes->at(i))
+                            fprintf(fp, "1");
+                        else
+                            fprintf(fp, "0");
+                    }
+                } else fprintf(fp, "(nullptr=1): ");
+                fprintf(fp, "\n\n");
+
+                if (buffer_view->buffer()->getData() != nullptr) {
+                    v8::Local<v8::Value> v8Value((v8::Value *)buffer_view->buffer()->getData());
+                    v8Value->PrintTaintSinkDetails(isolate, fp);
+                }
+                fprintf(fp, ">>> END TAINT SINK REPORT <<<\n");
+                fclose(fp);
+
+            }
+            release_lock();
+
+        }
+    }
+
 DOMWebSocket* DOMWebSocket::Create(ExecutionContext* context,
                                    const String& url,
                                    ExceptionState& exception_state) {
+
+  // xqg start
+  InspectTaintAtSink(context->GetIsolate(), url, url, "ws-create-url");
+  // xqg end
   return Create(
       context, url,
       MakeGarbageCollected<V8UnionStringOrStringSequence>(Vector<String>()),
@@ -317,9 +549,13 @@ void DOMWebSocket::ReleaseChannel() {
   channel_ = nullptr;
 }
 
+
 void DOMWebSocket::send(const String& message,
                         ExceptionState& exception_state) {
   DVLOG(1) << "WebSocket " << this << " send() Sending String " << message;
+  // xqg start
+  InspectTaintAtSink(GetExecutionContext()->GetIsolate(), this, message, "ws-send-body-String");
+  // xqg end
   if (common_.GetState() == kConnecting) {
     SetInvalidStateErrorForSendMethod(exception_state);
     return;
@@ -336,6 +572,7 @@ void DOMWebSocket::send(const String& message,
 
   DCHECK(channel_);
   buffered_amount_ += encoded_message.length();
+
   channel_->Send(encoded_message, base::OnceClosure());
 }
 
@@ -344,6 +581,10 @@ void DOMWebSocket::send(DOMArrayBuffer* binary_data,
   DVLOG(1) << "WebSocket " << this << " send() Sending ArrayBuffer "
            << binary_data;
   DCHECK(binary_data);
+  // xqg start
+  InspectTaintAtSink(GetExecutionContext()->GetIsolate(), this, binary_data, "ws-send-body-DOMArrayBuffer");
+  // xqg end
+
   if (common_.GetState() == kConnecting) {
     SetInvalidStateErrorForSendMethod(exception_state);
     return;
@@ -364,6 +605,10 @@ void DOMWebSocket::send(NotShared<DOMArrayBufferView> array_buffer_view,
   DVLOG(1) << "WebSocket " << this << " send() Sending ArrayBufferView "
            << array_buffer_view.Get();
   DCHECK(array_buffer_view);
+
+  // xqg start
+  InspectTaintAtSink(GetExecutionContext()->GetIsolate(), this, array_buffer_view, "ws-send-body-DOMArrayBufferView");
+  // xqg end
   if (common_.GetState() == kConnecting) {
     SetInvalidStateErrorForSendMethod(exception_state);
     return;
@@ -383,6 +628,11 @@ void DOMWebSocket::send(Blob* binary_data, ExceptionState& exception_state) {
   DVLOG(1) << "WebSocket " << this << " send() Sending Blob "
            << binary_data->Uuid();
   DCHECK(binary_data);
+  // xqg start
+  if (GetExecutionContext()->GetIsolate()->IsExtensionContext(GetExecutionContext()->GetIsolate()->GetCurrentContext())) {
+      DVLOG(0) << "[SPECIFIC CHECK]##[DOMWebSocket::send]##[Blob]##[url=" << this->url().GetString() << "]";
+  }
+  // xqg end
   if (common_.GetState() == kConnecting) {
     SetInvalidStateErrorForSendMethod(exception_state);
     return;
diff --git a/third_party/blink/renderer/modules/webtransport/web_transport.cc b/third_party/blink/renderer/modules/webtransport/web_transport.cc
index 6655ef31a5b4a..1d54df761c9b2 100644
--- a/third_party/blink/renderer/modules/webtransport/web_transport.cc
+++ b/third_party/blink/renderer/modules/webtransport/web_transport.cc
@@ -675,6 +675,12 @@ WebTransport* WebTransport::Create(ScriptState* script_state,
                                    WebTransportOptions* options,
                                    ExceptionState& exception_state) {
   DVLOG(1) << "WebTransport::Create() url=" << url;
+
+  // xqg start
+  if (script_state->GetIsolate()->IsExtensionContext(script_state->GetIsolate()->GetCurrentContext())){
+        DVLOG(0) << "[SPECIFIC CHECK]##[WebTransport::Create]##[url="<<url<<"]";
+  }
+  // xqg end
   DCHECK(options);
   UseCounter::Count(ExecutionContext::From(script_state),
                     WebFeature::kWebTransport);
@@ -699,7 +705,9 @@ WebTransport::WebTransport(ScriptState* script_state,
       transport_remote_(context),
       handshake_client_receiver_(this, context),
       client_receiver_(this, context),
-      inspector_transport_id_(CreateUniqueIdentifier()) {}
+      inspector_transport_id_(CreateUniqueIdentifier()) {
+
+}
 
 ScriptPromise WebTransport::createUnidirectionalStream(
     ScriptState* script_state,
diff --git a/third_party/blink/renderer/platform/bindings/dom_data_store.h b/third_party/blink/renderer/platform/bindings/dom_data_store.h
index 99576c7434805..448dbea1f1de8 100644
--- a/third_party/blink/renderer/platform/bindings/dom_data_store.h
+++ b/third_party/blink/renderer/platform/bindings/dom_data_store.h
@@ -41,6 +41,12 @@
 #include "third_party/blink/renderer/platform/wtf/std_lib_extras.h"
 #include "v8/include/v8.h"
 
+// xqg start
+#include "third_party/blink/renderer/core/typed_arrays/dom_array_buffer.h"
+#include "third_party/blink/renderer/core/typed_arrays/dom_shared_array_buffer.h"
+#include "third_party/blink/renderer/core/typed_arrays/dom_array_buffer_view.h"
+// xqg end
+
 namespace blink {
 
 // Holds a map specialized to map between ScriptWrappable objects and their
@@ -55,29 +61,182 @@ class DOMDataStore final : public GarbageCollected<DOMDataStore> {
 
   static bool SetReturnValue(v8::ReturnValue<v8::Value> return_value,
                              ScriptWrappable* object) {
-    if (CanUseMainWorldWrapper())
-      return object->SetReturnValue(return_value);
-    return Current(return_value.GetIsolate())
-        .SetReturnValueFrom(return_value, object);
+    // xqg start
+    bool tainted = false;
+    std::vector<bool> *tainted_bytes;
+    // xqg end
+    if (CanUseMainWorldWrapper()) {
+        // return object->SetReturnValue(return_value);
+        bool ret =  object->SetReturnValue(return_value);
+        if (object->DowncastTo<DOMArrayBuffer>()){
+            DOMArrayBuffer* buffer = object->DowncastTo<DOMArrayBuffer>();
+            if (buffer->isTainted()) {
+                tainted = true;
+                tainted_bytes = buffer->getTaintedBytes();
+            }
+        } else if(object->DowncastTo<DOMSharedArrayBuffer>()){
+            DOMSharedArrayBuffer* buffer = object->DowncastTo<DOMSharedArrayBuffer>();
+            if (buffer->isTainted()) {
+                tainted = true;
+                tainted_bytes = buffer->getTaintedBytes();
+            }
+        } else if (object->DowncastTo<DOMArrayBufferView>()){
+            DOMArrayBufferView* buffer_view = object->DowncastTo<DOMArrayBufferView>();
+            if (buffer_view->BufferBase()->isTainted()) {
+                tainted = true;
+                tainted_bytes = buffer_view->BufferBase()->getTaintedBytes();
+            }
+        }
+        if (ret && tainted){
+            if (tainted_bytes != nullptr)
+                return_value.Get()->SetTaint(return_value.GetIsolate(), *tainted_bytes);
+            else return_value.Get()->SetTaint(return_value.GetIsolate());
+        }
+        return ret;
+    }
+    bool ret = Current(return_value.GetIsolate())
+            .SetReturnValueFrom(return_value, object);
+    if (object->DowncastTo<DOMArrayBuffer>()){
+          DOMArrayBuffer* buffer = object->DowncastTo<DOMArrayBuffer>();
+          if (buffer->isTainted()) {
+              tainted = true;
+              tainted_bytes = buffer->getTaintedBytes();
+          }
+      } else if(object->DowncastTo<DOMSharedArrayBuffer>()){
+          DOMSharedArrayBuffer* buffer = object->DowncastTo<DOMSharedArrayBuffer>();
+          if (buffer->isTainted()) {
+              tainted = true;
+              tainted_bytes = buffer->getTaintedBytes();
+          }
+      } else if (object->DowncastTo<DOMArrayBufferView>()){
+          DOMArrayBufferView* buffer_view = object->DowncastTo<DOMArrayBufferView>();
+          if (buffer_view->BufferBase()->isTainted()) {
+              tainted = true;
+              tainted_bytes = buffer_view->BufferBase()->getTaintedBytes();
+          }
+    }
+    if (ret && tainted){
+        if (tainted_bytes != nullptr)
+            return_value.Get()->SetTaint(return_value.GetIsolate(), *tainted_bytes);
+        else
+            return_value.Get()->SetTaint(return_value.GetIsolate());
+    }
+    return ret;
+
+//    return Current(return_value.GetIsolate())
+//        .SetReturnValueFrom(return_value, object);
   }
 
   static bool SetReturnValueForMainWorld(
       v8::ReturnValue<v8::Value> return_value,
       ScriptWrappable* object) {
-    return object->SetReturnValue(return_value);
+    // return object->SetReturnValue(return_value);
+    // xqg start
+    bool ret = object->SetReturnValue(return_value);
+
+    bool tainted = false;
+    std::vector<bool> *tainted_bytes;
+    if (object->DowncastTo<DOMArrayBuffer>()){
+          DOMArrayBuffer* buffer = object->DowncastTo<DOMArrayBuffer>();
+          if (buffer->isTainted()) {
+              tainted = true;
+              tainted_bytes = buffer->getTaintedBytes();
+          }
+    } else if(object->DowncastTo<DOMSharedArrayBuffer>()){
+          DOMSharedArrayBuffer* buffer = object->DowncastTo<DOMSharedArrayBuffer>();
+          if (buffer->isTainted()) {
+              tainted = true;
+              tainted_bytes = buffer->getTaintedBytes();
+          }
+    } else if (object->DowncastTo<DOMArrayBufferView>()){
+          DOMArrayBufferView* buffer_view = object->DowncastTo<DOMArrayBufferView>();
+          if (buffer_view->BufferBase()->isTainted()) {
+              tainted = true;
+              tainted_bytes = buffer_view->BufferBase()->getTaintedBytes();
+          }
+    }
+    if (ret && tainted){
+        if (tainted_bytes != nullptr)
+            return_value.Get()->SetTaint(return_value.GetIsolate(), *tainted_bytes);
+        else
+            return_value.Get()->SetTaint(return_value.GetIsolate());
+    }
+    return ret;
+    // xqg end
   }
 
   static bool SetReturnValueFast(v8::ReturnValue<v8::Value> return_value,
                                  ScriptWrappable* object,
                                  v8::Local<v8::Object> holder,
                                  const ScriptWrappable* wrappable) {
+    // xqg start
+    bool tainted = false;
+    std::vector<bool> *tainted_bytes;
+
+    // xqg end
     if (CanUseMainWorldWrapper()
         // The second fastest way to check if we're in the main world is to
         // check if the wrappable's wrapper is the same as the holder.
-        || HolderContainsWrapper(holder, wrappable))
-      return object->SetReturnValue(return_value);
-    return Current(return_value.GetIsolate())
-        .SetReturnValueFrom(return_value, object);
+        || HolderContainsWrapper(holder, wrappable)) {
+      // return object->SetReturnValue(return_value);
+      bool ret = object->SetReturnValue(return_value);
+      if (object->DowncastTo<DOMArrayBuffer>()){
+            DOMArrayBuffer* buffer = object->DowncastTo<DOMArrayBuffer>();
+            if (buffer->isTainted()) {
+                tainted = true;
+                tainted_bytes = buffer->getTaintedBytes();
+            }
+      } else if(object->DowncastTo<DOMSharedArrayBuffer>()){
+            DOMSharedArrayBuffer* buffer = object->DowncastTo<DOMSharedArrayBuffer>();
+            if (buffer->isTainted()) {
+                tainted = true;
+                tainted_bytes = buffer->getTaintedBytes();
+            }
+      } else if (object->DowncastTo<DOMArrayBufferView>()){
+            DOMArrayBufferView* buffer_view = object->DowncastTo<DOMArrayBufferView>();
+            if (buffer_view->BufferBase()->isTainted()) {
+                tainted = true;
+                tainted_bytes = buffer_view->BufferBase()->getTaintedBytes();
+            }
+      }
+      if (ret && tainted){
+          if (tainted_bytes != nullptr)
+              return_value.Get()->SetTaint(return_value.GetIsolate(), *tainted_bytes);
+          else
+              return_value.Get()->SetTaint(return_value.GetIsolate());
+      }
+      return ret;
+    }
+//    return Current(return_value.GetIsolate())
+//        .SetReturnValueFrom(return_value, object);
+    bool ret = Current(return_value.GetIsolate())
+            .SetReturnValueFrom(return_value, object);
+    if (object->DowncastTo<DOMArrayBuffer>()){
+          DOMArrayBuffer* buffer = object->DowncastTo<DOMArrayBuffer>();
+          if (buffer->isTainted()) {
+              tainted = true;
+              tainted_bytes = buffer->getTaintedBytes();
+          }
+    } else if(object->DowncastTo<DOMSharedArrayBuffer>()){
+          DOMSharedArrayBuffer* buffer = object->DowncastTo<DOMSharedArrayBuffer>();
+          if (buffer->isTainted()) {
+              tainted = true;
+              tainted_bytes = buffer->getTaintedBytes();
+          }
+    } else if (object->DowncastTo<DOMArrayBufferView>()){
+          DOMArrayBufferView* buffer_view = object->DowncastTo<DOMArrayBufferView>();
+          if (buffer_view->BufferBase()->isTainted()) {
+              tainted = true;
+              tainted_bytes = buffer_view->BufferBase()->getTaintedBytes();
+          }
+    }
+    if (ret && tainted){
+        if (tainted_bytes != nullptr)
+            return_value.Get()->SetTaint(return_value.GetIsolate(), *tainted_bytes);
+        else
+            return_value.Get()->SetTaint(return_value.GetIsolate());
+    }
+    return ret;
   }
 
   static v8::Local<v8::Object> GetWrapper(ScriptWrappable* object,
diff --git a/third_party/blink/renderer/platform/bindings/string_resource.cc b/third_party/blink/renderer/platform/bindings/string_resource.cc
index 45fbe5654295a..eab7f6acd1fe1 100644
--- a/third_party/blink/renderer/platform/bindings/string_resource.cc
+++ b/third_party/blink/renderer/platform/bindings/string_resource.cc
@@ -17,6 +17,12 @@ struct StringTraits {
   static const StringClass& FromStringResource(StringResourceBase*);
   template <typename V8StringTrait>
   static StringClass FromV8String(v8::Isolate*, v8::Local<v8::String>, int);
+
+    // xqg start
+    static void setTaint(StringClass &string);
+    static void setData(StringClass &string, void *data);
+    // xqg end
+
 };
 
 template <>
@@ -26,6 +32,17 @@ struct StringTraits<String> {
   }
   template <typename V8StringTrait>
   static String FromV8String(v8::Isolate*, v8::Local<v8::String>, int);
+
+    // xqg start
+    static void setTaint(String &string) {
+        string.Impl()->setTaint();
+        string.Impl()->setTaintedInV8();
+    }
+    static void setData(String &string, void *data) {
+        string.Impl()->setData(data);
+    }
+    // xqg end
+
 };
 
 template <>
@@ -35,6 +52,17 @@ struct StringTraits<AtomicString> {
   }
   template <typename V8StringTrait>
   static AtomicString FromV8String(v8::Isolate*, v8::Local<v8::String>, int);
+
+    // xqg start
+    static void setTaint(AtomicString &string) {
+        string.Impl()->setTaint();
+        string.Impl()->setTaintedInV8();
+    }
+    static void setData(AtomicString &string, void *data) {
+        string.Impl()->setData(data);
+    }
+    // xqg end
+
 };
 
 struct V8StringTwoBytesTrait {
@@ -141,7 +169,9 @@ ALWAYS_INLINE StringType
 ConvertAndExternalizeString(v8::Isolate* isolate,
                             v8::Local<v8::String> v8_string,
                             bool can_externalize,
-                            bool* was_externalized) {
+                            bool* was_externalized,
+                            bool tainted)  // xqg
+                            {
   int length = v8_string->Length();
   bool one_byte = v8_string->ContainsOnlyOneByte();
   StringType result =
@@ -149,7 +179,34 @@ ConvertAndExternalizeString(v8::Isolate* isolate,
                      V8StringOneByteTrait>(isolate, v8_string, length)
                : StringTraits<StringType>::template FromV8String<
                      V8StringTwoBytesTrait>(isolate, v8_string, length);
-
+  // xqg start
+#define MINUS_ONE  ~((size_t)0)
+  if (tainted){
+//      DVLOG(0) << "ToBlinkString1, tainted = "<<result<<"\n";
+
+      std::vector<bool> tainted_bytes = v8_string->GetTaintedBytes(isolate);
+      StringTraits<StringType>::setTaint(result);
+      v8::Local<v8::String> copy = v8_string.MakePersistentCopy(isolate);
+      StringTraits<StringType>::setData(result, *copy);
+      if (!tainted_bytes.empty()) {
+          CHECK(tainted_bytes.size() == result.length());
+      }
+      if (!tainted_bytes.empty()) {
+          CHECK(tainted_bytes.size() == result.length());
+          size_t start = MINUS_ONE;
+          for (size_t i = 0; i < tainted_bytes.size(); i++) {
+              if (start == MINUS_ONE && tainted_bytes[i]) {
+                  start = i;
+              } else if (start != MINUS_ONE && !tainted_bytes[i]){
+                  result.Impl()->setTaintedBytes(start, i);
+                  start = MINUS_ONE;
+              }
+          }
+          if (start != MINUS_ONE)
+              result.Impl()->setTaintedBytes(start, result.length());
+      }
+  }
+  // xqg end
   *was_externalized = false;
   if (LIKELY(can_externalize)) {
     if (result.Is8Bit()) {
@@ -170,12 +227,18 @@ ConvertAndExternalizeString(v8::Isolate* isolate,
   }
 
   return result;
+#undef MINUS_ONE
 }
 
 }  // namespace
 
 template <typename StringType>
 StringType ToBlinkString(v8::Local<v8::String> v8_string, ExternalMode mode) {
+
+  v8::Isolate* isolate = v8::Isolate::GetCurrent();
+  bool tainted = v8_string->IsTainted(isolate);
+  std::vector<bool> tainted_bytes = v8_string->GetTaintedBytes(isolate);
+
   // Be very careful in this code to ensure it is RVO friendly. Accidentally
   // breaking RVO will degrade some of the blink_perf benchmarks by a few
   // percent. This includes moving the StringTraits<>::FromStringResource() call
@@ -185,9 +248,36 @@ StringType ToBlinkString(v8::Local<v8::String> v8_string, ExternalMode mode) {
   // Check for an already externalized string first as this is a very
   // common case for all platforms with the one exception being super short
   // strings on for platforms with v8 pointer compression.
+#define MINUS_ONE  ~((size_t)0)
   StringResourceBase* string_resource = GetExternalizedString(v8_string);
-  if (string_resource)
-    return StringTraits<StringType>::FromStringResource(string_resource);
+  if (string_resource) {
+      // return StringTraits<StringType>::FromStringResource(string_resource);
+      // xqg start
+      StringType ret = StringTraits<StringType>::FromStringResource(string_resource);
+      if (tainted) {
+//          DVLOG(0) << "ToBlinkString1, tainted = "<<ret<<"\n";
+          StringTraits<StringType>::setTaint(ret);
+          v8::Local<v8::String> copy = v8_string.MakePersistentCopy(isolate);
+          StringTraits<StringType>::setData(ret, *copy);
+          if (!tainted_bytes.empty()) {
+              CHECK(tainted_bytes.size() == ret.length());
+              size_t start = MINUS_ONE;
+              for (size_t i = 0; i < tainted_bytes.size(); i++) {
+                  if (start == MINUS_ONE && tainted_bytes[i]) {
+                      start = i;
+                  } else if (start != MINUS_ONE && !tainted_bytes[i]) {
+                      ret.Impl()->setTaintedBytes(start, i);
+                      start = MINUS_ONE;
+                  }
+              }
+              if (start != MINUS_ONE) {
+                  ret.Impl()->setTaintedBytes(start, ret.length());
+              }
+          }
+      }
+      return ret;
+      // xqg end
+  }
 
   int length = v8_string->Length();
   if (UNLIKELY(!length)) {
@@ -200,7 +290,8 @@ StringType ToBlinkString(v8::Local<v8::String> v8_string, ExternalMode mode) {
   // TODO(ajwong): Avoid v8::Isolate::GetCurrent() call.
   return ConvertAndExternalizeString<StringType>(
       v8::Isolate::GetCurrent(), v8_string, CanExternalize(v8_string, mode),
-      &was_externalized);
+      &was_externalized, tainted);
+#undef MINUS_ONE
 }
 
 // Explicitly instantiate the above template with the expected
@@ -213,14 +304,44 @@ template AtomicString ToBlinkString<AtomicString>(v8::Local<v8::String>,
 StringView ToBlinkStringView(v8::Local<v8::String> v8_string,
                              StringView::StackBackingStore& backing_store,
                              ExternalMode mode) {
+  v8::Isolate* isolate = v8::Isolate::GetCurrent();
+  bool tainted = v8_string->IsTainted(isolate);
+  std::vector<bool> tainted_bytes = v8_string->GetTaintedBytes(isolate);
+
   // Be very careful in this code to ensure it is RVO friendly. Accidentally
   // breaking RVO will degrade some of the blink_perf benchmarks by a few
   // percent. This includes moving the StringTraits<>::FromStringResource() call
   // into GetExternalizedString() as it becomes impossible for the calling code
   // to satisfy all RVO constraints.
   StringResourceBase* string_resource = GetExternalizedString(v8_string);
-  if (string_resource)
-    return StringTraits<AtomicString>::FromStringResource(string_resource);
+#define MINUS_ONE  ~((size_t)0)
+  if (string_resource) {
+      // return StringTraits<AtomicString>::FromStringResource(string_resource);
+      // xqg start
+      auto ret = StringTraits<AtomicString>::FromStringResource(string_resource);
+      if (tainted) {
+//          DVLOG(0) << "ToBlinkStringView, tainted = "<<ret<<"\n";
+          StringTraits<AtomicString>::setTaint(ret);
+          v8::Local<v8::String> copy = v8_string.MakePersistentCopy(isolate);
+          StringTraits<AtomicString>::setData(ret, *copy);
+          if (!tainted_bytes.empty()) {
+              CHECK(tainted_bytes.size() == ret.length());
+              size_t start = MINUS_ONE;
+              for (size_t i = 0; i < tainted_bytes.size(); i++) {
+                  if (start == MINUS_ONE && tainted_bytes[i]) {
+                      start = i;
+                  } else if (start != MINUS_ONE && !tainted_bytes[i]) {
+                      ret.Impl()->setTaintedBytes(start, i);
+                      start = MINUS_ONE;
+                  }
+              }
+              if (start != MINUS_ONE)
+                  ret.Impl()->setTaintedBytes(start, ret.length());
+          }
+      }
+      return ret;
+      // xqg end
+  }
 
   int length = v8_string->Length();
   if (UNLIKELY(!length))
@@ -236,7 +357,7 @@ StringView ToBlinkStringView(v8::Local<v8::String> v8_string,
   // small identifiers on 64-bit platforms, externalizations are less frequent
   // so this path is hotter.
   bool can_externalize = CanExternalize(v8_string, mode);
-  v8::Isolate* isolate = v8::Isolate::GetCurrent();
+//  v8::Isolate* isolate = v8::Isolate::GetCurrent();
   if (LIKELY(can_externalize)) {
     bool was_externalized;
     // An AtomicString is always used here for externalization. Using a String
@@ -256,7 +377,7 @@ StringView ToBlinkStringView(v8::Local<v8::String> v8_string,
     // calling this with kDoNotExternalize and relying on the
     // StringView::StackBackingStore yields the most efficient code.
     AtomicString blink_string = ConvertAndExternalizeString<AtomicString>(
-        isolate, v8_string, can_externalize, &was_externalized);
+        isolate, v8_string, can_externalize, &was_externalized, tainted);
     if (was_externalized)
       return StringView(blink_string);
   }
@@ -312,6 +433,7 @@ StringView ToBlinkStringView(v8::Local<v8::String> v8_string,
   // an int64_t.
   v8_string->Write(isolate, reinterpret_cast<uint16_t*>(uchar), 0, length);
   return StringView(uchar, length);
+#undef MINUS_ONE
 }
 
 // Fast but non thread-safe version.
diff --git a/third_party/blink/renderer/platform/bindings/to_v8.h b/third_party/blink/renderer/platform/bindings/to_v8.h
index 94aea1c209307..580f21fb352d5 100644
--- a/third_party/blink/renderer/platform/bindings/to_v8.h
+++ b/third_party/blink/renderer/platform/bindings/to_v8.h
@@ -38,14 +38,53 @@ inline v8::Local<v8::Value> ToV8(ScriptWrappable* impl,
                                  v8::Isolate* isolate) {
   if (UNLIKELY(!impl))
     return v8::Null(isolate);
+
+  // xqg start
+  bool tainted = false;
+  std::vector<bool> *tainted_bytes;
+  if (impl->DowncastTo<DOMArrayBuffer>()){
+        DOMArrayBuffer* buffer = impl->DowncastTo<DOMArrayBuffer>();
+        if (buffer->isTainted()) {
+            tainted = true;
+            tainted_bytes = buffer->getTaintedBytes();
+        }
+  } else if(impl->DowncastTo<DOMSharedArrayBuffer>()){
+        DOMSharedArrayBuffer* buffer = impl->DowncastTo<DOMSharedArrayBuffer>();
+        if (buffer->isTainted()) {
+            tainted = true;
+            tainted_bytes = buffer->getTaintedBytes();
+        }
+  } else if (impl->DowncastTo<DOMArrayBufferView>()){
+        DOMArrayBufferView* buffer_view = impl->DowncastTo<DOMArrayBufferView>();
+        if (buffer_view->BufferBase()->isTainted()) {
+            tainted = true;
+            tainted_bytes = buffer_view->BufferBase()->getTaintedBytes();
+        }
+  }
+
+  // xqg end
+
   v8::Local<v8::Value> wrapper = DOMDataStore::GetWrapper(impl, isolate);
-  if (!wrapper.IsEmpty())
-    return wrapper;
+  if (!wrapper.IsEmpty()) {
+      if (tainted){
+          if (tainted_bytes != nullptr)
+              wrapper->SetTaint(isolate, *tainted_bytes);
+          else
+              wrapper->SetTaint(isolate);
+      }
+
+      return wrapper;
+  }
 
   ScriptState* script_state =
       ScriptState::From(creation_context->GetCreationContextChecked());
   wrapper = impl->Wrap(script_state).ToLocalChecked();
   DCHECK(!wrapper.IsEmpty());
+
+  // xqg start
+  
+  // xqg end
+
   return wrapper;
 }
 
diff --git a/third_party/blink/renderer/platform/bindings/v8_set_return_value.h b/third_party/blink/renderer/platform/bindings/v8_set_return_value.h
index 1712f3c24ed26..a513c2f41f523 100644
--- a/third_party/blink/renderer/platform/bindings/v8_set_return_value.h
+++ b/third_party/blink/renderer/platform/bindings/v8_set_return_value.h
@@ -16,7 +16,11 @@
 #include "third_party/blink/renderer/platform/bindings/v8_value_cache.h"
 #include "third_party/blink/renderer/platform/platform_export.h"
 #include "v8/include/v8.h"
-
+// xqg start
+#include "third_party/blink/renderer/core/typed_arrays/dom_array_buffer.h"
+#include "third_party/blink/renderer/core/typed_arrays/dom_shared_array_buffer.h"
+#include "third_party/blink/renderer/core/typed_arrays/dom_array_buffer_view.h"
+// xqg end
 namespace blink {
 
 namespace bindings {
@@ -71,6 +75,37 @@ struct V8ReturnValue {
       return;
     }
     info.GetReturnValue().Set(wrapper);
+    // xqg start
+    bool tainted = false;
+    std::vector<bool> *tainted_bytes;
+
+    if (wrappable->DowncastTo<DOMArrayBuffer>()){
+          DOMArrayBuffer* buffer = wrappable->DowncastTo<DOMArrayBuffer>();
+          if (buffer->isTainted()) {
+              tainted = true;
+              tainted_bytes = buffer->getTaintedBytes();
+          }
+    } else if(wrappable->DowncastTo<DOMSharedArrayBuffer>()){
+          DOMSharedArrayBuffer* buffer = wrappable->DowncastTo<DOMSharedArrayBuffer>();
+          if (buffer->isTainted()) {
+              tainted = true;
+              tainted_bytes = buffer->getTaintedBytes();
+          }
+    } else if (wrappable->DowncastTo<DOMArrayBufferView>()){
+          DOMArrayBufferView* buffer_view = wrappable->DowncastTo<DOMArrayBufferView>();
+          if (buffer_view->BufferBase()->isTainted()) {
+              tainted = true;
+              tainted_bytes = buffer_view->BufferBase()->getTaintedBytes();
+          }
+    }
+
+    if (tainted){
+        if (tainted_bytes != nullptr)
+            info.GetReturnValue().Get()->SetTaint(info.GetReturnValue().GetIsolate(), *tainted_bytes);
+        else
+            info.GetReturnValue().Get()->SetTaint(info.GetReturnValue().GetIsolate());
+    }
+    // xqg end
   }
 };
 
diff --git a/third_party/blink/renderer/platform/bindings/v8_value_cache.cc b/third_party/blink/renderer/platform/bindings/v8_value_cache.cc
index ca75cd5ceb865..9a12143226a2d 100644
--- a/third_party/blink/renderer/platform/bindings/v8_value_cache.cc
+++ b/third_party/blink/renderer/platform/bindings/v8_value_cache.cc
@@ -155,12 +155,45 @@ v8::Local<v8::String> StringCache::V8ExternalStringSlow(
   return CreateStringAndInsertIntoCache(isolate, string_impl);
 }
 
+// xqg start
+    v8::Local<v8::String> StringCache::V8ExternalString(v8::Isolate* isolate,
+                                                        StringImpl* string_impl){ // xqg: it here, working, not parkable.
+        DCHECK(string_impl);
+        if (string_impl->isTainted()) {
+            std::vector<bool> *tainted_bytes = string_impl->getTaintedBytes();
+            v8::Local<v8::String> new_string = MakeExternalString(isolate, String(string_impl));
+            if (tainted_bytes != nullptr)
+                new_string->SetTaint(isolate, *tainted_bytes);
+            else
+                new_string->SetTaint(isolate);
+            return new_string;
+        }
+        if (last_string_impl_.get() == string_impl)
+            return last_v8_string_.NewLocal(isolate);
+        return V8ExternalStringSlow(isolate, string_impl);
+    }
+    // xqg end
+
 v8::Local<v8::String> StringCache::V8ExternalString(
     v8::Isolate* isolate,
     const ParkableString& string) {
   if (!string.length())
     return v8::String::Empty(isolate);
 
+    // xqg start
+  if (string.ToString().Impl()->isTainted()) {
+        std::vector<bool> *tainted_bytes = string.ToString().Impl()->getTaintedBytes();
+
+        v8::Local<v8::String> new_string =
+                MakeExternalString(isolate, ParkableString(string));
+        if (tainted_bytes != nullptr)
+            new_string->SetTaint(isolate, *tainted_bytes);
+        else
+            new_string->SetTaint(isolate);
+        return new_string;
+  }
+    // xqg end
+
   ParkableStringCacheMapTraits::MapType::PersistentValueReference
       cached_v8_string = parkable_string_cache_.GetReference(string.Impl());
   if (!cached_v8_string.IsEmpty()) {
@@ -194,6 +227,29 @@ void StringCache::SetReturnValueFromStringSlow(
       CreateStringAndInsertIntoCache(return_value.GetIsolate(), string_impl));
 }
 
+
+// xqg start
+void StringCache::SetReturnValueFromString(v8::ReturnValue<v8::Value> return_value, StringImpl* string_impl) {
+        DCHECK(string_impl);
+
+        // So tainted strings don't get mixed up with normal (web page) copies.
+        if (string_impl->isTainted()) {
+            std::vector<bool> *tainted_bytes = string_impl->getTaintedBytes();
+            return_value.Set(MakeExternalString(return_value.GetIsolate(), String(string_impl)));
+            if (tainted_bytes != nullptr)
+                return_value.Get()->SetTaint(return_value.GetIsolate(), *tainted_bytes);
+            else
+                return_value.Get()->SetTaint(return_value.GetIsolate());
+            return;
+        }
+
+        if (last_string_impl_.get() == string_impl)
+            last_v8_string_.SetReturnValue(return_value);
+        else
+            SetReturnValueFromStringSlow(return_value, string_impl);
+}
+// xqg end
+
 v8::Local<v8::String> StringCache::CreateStringAndInsertIntoCache(
     v8::Isolate* isolate,
     StringImpl* string_impl) {
diff --git a/third_party/blink/renderer/platform/bindings/v8_value_cache.h b/third_party/blink/renderer/platform/bindings/v8_value_cache.h
index 4b8f6eb8a9de4..71bc43754a8ec 100644
--- a/third_party/blink/renderer/platform/bindings/v8_value_cache.h
+++ b/third_party/blink/renderer/platform/bindings/v8_value_cache.h
@@ -125,25 +125,31 @@ class PLATFORM_EXPORT StringCache {
   StringCache(const StringCache&) = delete;
   StringCache& operator=(const StringCache&) = delete;
 
-  v8::Local<v8::String> V8ExternalString(v8::Isolate* isolate,
-                                         StringImpl* string_impl) {
-    DCHECK(string_impl);
-    if (last_string_impl_.get() == string_impl)
-      return last_v8_string_.NewLocal(isolate);
-    return V8ExternalStringSlow(isolate, string_impl);
-  }
+  // xqg start
+//  v8::Local<v8::String> V8ExternalString(v8::Isolate* isolate,
+//                                         StringImpl* string_impl) {
+//    DCHECK(string_impl);
+//    if (last_string_impl_.get() == string_impl)
+//      return last_v8_string_.NewLocal(isolate);
+//    return V8ExternalStringSlow(isolate, string_impl);
+//  }
+  v8::Local<v8::String> V8ExternalString(v8::Isolate* isolate, StringImpl* string_impl);
+  // xqg end
 
   v8::Local<v8::String> V8ExternalString(v8::Isolate* isolate,
                                          const ParkableString& string);
 
-  void SetReturnValueFromString(v8::ReturnValue<v8::Value> return_value,
+  // xqg start
+  /*void SetReturnValueFromString(v8::ReturnValue<v8::Value> return_value,
                                 StringImpl* string_impl) {
     DCHECK(string_impl);
     if (last_string_impl_.get() == string_impl)
       last_v8_string_.SetReturnValue(return_value);
     else
       SetReturnValueFromStringSlow(return_value, string_impl);
-  }
+  }*/
+  void SetReturnValueFromString(v8::ReturnValue<v8::Value> return_value, StringImpl* string_impl);
+  // xqg end
 
   void Dispose();
 
diff --git a/third_party/blink/renderer/platform/crypto_result.h b/third_party/blink/renderer/platform/crypto_result.h
index b2622b634f9dc..65eee9ddb9d79 100644
--- a/third_party/blink/renderer/platform/crypto_result.h
+++ b/third_party/blink/renderer/platform/crypto_result.h
@@ -55,7 +55,7 @@ class PLATFORM_EXPORT CryptoResult : public GarbageCollected<CryptoResult> {
   virtual ~CryptoResult() = default;
 
   virtual void CompleteWithError(WebCryptoErrorType, const WebString&) = 0;
-  virtual void CompleteWithBuffer(const void* bytes, unsigned bytes_size) = 0;
+  virtual void CompleteWithBuffer(const void* bytes, unsigned bytes_size, bool is_tainted) = 0;
   virtual void CompleteWithJson(const char* utf8_data, unsigned length) = 0;
   virtual void CompleteWithBoolean(bool) = 0;
   virtual void CompleteWithKey(const WebCryptoKey&) = 0;
diff --git a/third_party/blink/renderer/platform/exported/web_crypto_result.cc b/third_party/blink/renderer/platform/exported/web_crypto_result.cc
index 2197ef11341b9..1ce424e62a916 100644
--- a/third_party/blink/renderer/platform/exported/web_crypto_result.cc
+++ b/third_party/blink/renderer/platform/exported/web_crypto_result.cc
@@ -42,9 +42,9 @@ void WebCryptoResult::CompleteWithError(WebCryptoErrorType error_type,
 }
 
 void WebCryptoResult::CompleteWithBuffer(const void* bytes,
-                                         unsigned bytes_size) {
+                                         unsigned bytes_size, bool is_tainted) {
   if (!Cancelled())
-    impl_->CompleteWithBuffer(bytes, bytes_size);
+    impl_->CompleteWithBuffer(bytes, bytes_size, is_tainted); //xqg
   Reset();
 }
 
diff --git a/third_party/blink/renderer/platform/weborigin/kurl.cc b/third_party/blink/renderer/platform/weborigin/kurl.cc
index 800b6ca388588..e38d87de6d064 100644
--- a/third_party/blink/renderer/platform/weborigin/kurl.cc
+++ b/third_party/blink/renderer/platform/weborigin/kurl.cc
@@ -298,6 +298,23 @@ KURL& KURL::operator=(const KURL& other) {
   return *this;
 }
 
+// xqg start
+void KURL::setTaint(bool fromV8) {
+    if (string_.Impl()) {
+        string_.Impl()->setTaint();
+        if (fromV8)
+            string_.Impl()->setTaintedInV8();
+    }
+}
+
+bool KURL::isTainted() {
+    if (string_.Impl()) {
+        return string_.Impl()->isTainted();
+    }
+    return false;
+}
+// xqg end
+
 bool KURL::IsNull() const {
   return string_.IsNull();
 }
@@ -356,11 +373,21 @@ String KURL::LastPathComponent() const {
 
 String KURL::Protocol() const {
   DCHECK_EQ(ComponentString(parsed_.scheme), protocol_);
+  // xqg start
+  if (protocol_.length() > 0 && string_.Impl() && string_.Impl()->isTainted())
+      protocol_.Impl()->setTaint();
+  // xqg end
   return protocol_;
 }
 
 String KURL::Host() const {
-  return ComponentString(parsed_.host);
+  // xqg start
+  String ret = ComponentString(parsed_.host);
+  if (ret.length() > 0 && string_.Impl() && string_.Impl()->isTainted())
+      ret.Impl()->setTaint();
+  return ret;
+  // xqg end
+  // return ComponentString(parsed_.host);
 }
 
 uint16_t KURL::Port() const {
@@ -384,11 +411,23 @@ String KURL::Pass() const {
   // a null string when the password is empty, which we duplicate here.
   if (!parsed_.password.is_nonempty())
     return String();
-  return ComponentString(parsed_.password);
+  // xqg start
+  String ret = ComponentString(parsed_.password);
+  if (ret.length() > 0 && string_.Impl() && string_.Impl()->isTainted())
+      ret.Impl()->setTaint();
+  return ret;
+  // xqg end
+//  return ComponentString(parsed_.password);
 }
 
 String KURL::User() const {
-  return ComponentString(parsed_.username);
+  // xqg start
+  String ret = ComponentString(parsed_.username);
+  if (ret.length() > 0 && string_.Impl() && string_.Impl()->isTainted())
+        ret.Impl()->setTaint();
+  return ret;
+  // xqg end
+//  return ComponentString(parsed_.username);
 }
 
 String KURL::FragmentIdentifier() const {
@@ -405,13 +444,28 @@ bool KURL::HasFragmentIdentifier() const {
 }
 
 String KURL::BaseAsString() const {
+  // xqg start
+  String ret = string_.Left(PathAfterLastSlash());
+  if (ret.length() > 0 && string_.Impl() && string_.Impl()->isTainted()){
+      ret.Impl()->setTaint();
+  }
+  return ret;
+  // xqg end
   // FIXME: There is probably a more efficient way to do this?
-  return string_.Left(PathAfterLastSlash());
-}
-
-String KURL::Query() const {
-  if (parsed_.query.len >= 0)
-    return ComponentString(parsed_.query);
+//  return string_.Left(PathAfterLastSlash());
+}
+
+String KURL::Query() const { // xqg: done
+  if (parsed_.query.len >= 0) {
+      // xqg start
+      String ret = ComponentString(parsed_.query);
+      if (ret.length() > 0 && string_.Impl() && string_.Impl()->isTainted()) {
+          ret.Impl()->setTaint();
+      }
+      return ret;
+      // xqg end
+//      return ComponentString(parsed_.query);
+  }
 
   // Bug: https://bugs.webkit.org/show_bug.cgi?id=21015 this function returns
   // an empty string when the query is empty rather than a null (not sure
@@ -423,7 +477,14 @@ String KURL::Query() const {
 }
 
 String KURL::GetPath() const {
-  return ComponentString(parsed_.path);
+  // xqg start
+  String ret = ComponentString(parsed_.path);
+  if (ret.length() > 0 && string_.Impl() && string_.Impl()->isTainted()) {
+      ret.Impl()->setTaint();
+  }
+  return ret;
+  // xqg end
+  // return ComponentString(parsed_.path);
 }
 
 namespace {
@@ -903,8 +964,22 @@ void KURL::Init(const KURL& base,
       StringView(output.data(), static_cast<unsigned>(output.length())) ==
           relative) {
     string_ = relative;
+    // xqg start
+    if (string_.length() > 0 &&
+    ((relative.length() > 0 && relative.Impl() && relative.Impl()->isTainted()) ||
+    ((base.GetString().length() > 0 && base.GetString().Impl() && base.GetString().Impl()->isTainted())))){
+        string_.Impl()->setTaint();
+    }
+    // xqg end
   } else {
     string_ = AtomicString::FromUTF8(output.data(), output.length());
+    // xqg start
+    if (string_.length() > 0 &&
+          ((relative.length() > 0 && relative.Impl() && relative.Impl()->isTainted()) ||
+           ((base.GetString().length() > 0 && base.GetString().Impl() && base.GetString().Impl()->isTainted())))){
+        string_.Impl()->setTaint();
+    }
+      // xqg end
   }
 
   InitProtocolMetadata();
@@ -918,9 +993,15 @@ void KURL::InitInnerURL() {
     return;
   }
   if (url::Parsed* inner_parsed = parsed_.inner_parsed()) {
+
     inner_url_ = std::make_unique<KURL>(
         string_.Substring(inner_parsed->scheme.begin,
                           inner_parsed->Length() - inner_parsed->scheme.begin));
+
+    // xqg start
+    if (string_.length() > 0 && string_.Impl() && string_.Impl()->isTainted())
+        inner_url_->setTaint(false);
+    // xqg end
   } else {
     inner_url_.reset();
   }
diff --git a/third_party/blink/renderer/platform/weborigin/kurl.h b/third_party/blink/renderer/platform/weborigin/kurl.h
index 68a4ddf8e52ab..87ba71a3dce20 100644
--- a/third_party/blink/renderer/platform/weborigin/kurl.h
+++ b/third_party/blink/renderer/platform/weborigin/kurl.h
@@ -140,6 +140,11 @@ class PLATFORM_EXPORT KURL {
   bool CanSetPathname() const { return IsHierarchical(); }
   bool IsHierarchical() const;
 
+  // xqg start
+  void setTaint(bool fromV8);
+  bool isTainted();
+  // xqg end
+
   const String& GetString() const { return string_; }
 
   String ElidedString() const;
diff --git a/third_party/blink/renderer/platform/wtf/text/string_builder.cc b/third_party/blink/renderer/platform/wtf/text/string_builder.cc
index 2f6b61952f3b3..d75f10be7093a 100644
--- a/third_party/blink/renderer/platform/wtf/text/string_builder.cc
+++ b/third_party/blink/renderer/platform/wtf/text/string_builder.cc
@@ -42,6 +42,7 @@ String StringBuilder::ReleaseString() {
     BuildString<String>();
   String string = std::move(string_);
   Clear();
+  has_taint_string = false; // xqg
   return string;
 }
 
@@ -50,6 +51,10 @@ String StringBuilder::ToString() {
     return g_empty_string;
   if (string_.IsNull())
     BuildString<String>();
+  if (has_taint_string) {
+      string_.Impl()->setTaint(); // xqg
+//      DVLOG(0) << "has_taint_string=true"<<string_<<"\n";
+  }
   return string_;
 }
 
diff --git a/third_party/blink/renderer/platform/wtf/text/string_builder.h b/third_party/blink/renderer/platform/wtf/text/string_builder.h
index 0444040e7fb53..4921021aad2c3 100644
--- a/third_party/blink/renderer/platform/wtf/text/string_builder.h
+++ b/third_party/blink/renderer/platform/wtf/text/string_builder.h
@@ -58,6 +58,8 @@ class WTF_EXPORT StringBuilder {
     if (!other.length_)
       return;
 
+    if (other.has_taint_string) has_taint_string = true;          // xqg
+
     if (!length_ && !HasBuffer() && !other.string_.IsNull()) {
       string_ = other.string_;
       length_ = other.string_.length();
@@ -80,6 +82,10 @@ class WTF_EXPORT StringBuilder {
     if (extent < offset || extent > string.length())
       return;
 
+    StringImpl* impl = string.SharedImpl();
+    if (impl){
+        if (impl->isTainted()) has_taint_string = true;
+    }
     // We can't do this before the above check since StringView's constructor
     // doesn't accept invalid offsets or lengths.
     Append(StringView(string, offset, length));
@@ -98,6 +104,11 @@ class WTF_EXPORT StringBuilder {
     // inside the parser in the common case when flushing buffered text to
     // a Text node.
     StringImpl* impl = string.SharedImpl();
+    // xqg start
+    if (impl) {
+          if (impl->isTainted()) has_taint_string = true;
+    }
+    // xqg end
     if (!length_ && !HasBuffer() && impl) {
       string_ = impl;
       length_ = impl->length();
@@ -271,6 +282,7 @@ class WTF_EXPORT StringBuilder {
   unsigned length_ = 0;
   bool is_8bit_ = true;
   bool has_buffer_ = false;
+  bool has_taint_string = false; // xqg
 };
 
 template <typename CharType>
diff --git a/third_party/blink/renderer/platform/wtf/text/string_impl.cc b/third_party/blink/renderer/platform/wtf/text/string_impl.cc
index eb2477b5bbd79..24fd499e363c6 100644
--- a/third_party/blink/renderer/platform/wtf/text/string_impl.cc
+++ b/third_party/blink/renderer/platform/wtf/text/string_impl.cc
@@ -56,7 +56,8 @@ struct SameSizeAsStringImpl {
 #if DCHECK_IS_ON()
   unsigned int ref_count_change_count;
 #endif
-  int fields[3];
+  // int fields[3];
+  int fields[7]; // xqg
 };
 
 ASSERT_SIZE(StringImpl, SameSizeAsStringImpl);
@@ -1573,6 +1574,35 @@ scoped_refptr<StringImpl> StringImpl::UpconvertedString() {
   return this;
 }
 
+// xqg start
+void StringImpl::setTaintedBytes(size_t start, size_t end) {
+    setTaint();
+    if (m_taintedBytes == nullptr) {
+        m_taintedBytes = new std::vector<bool>();
+        for (size_t i = 0; i < length(); i++)
+            m_taintedBytes->push_back(false);
+    }
+    for (size_t i = start; i < end; i++) {
+        (*m_taintedBytes)[i] = true;
+    }
+}
+
+void StringImpl::copyTaintedBytes(std::vector<bool>* from) {
+    setTaint();
+    if (m_taintedBytes == nullptr) {
+        m_taintedBytes = new std::vector<bool>();
+        for (size_t i = 0; i < length(); i++)
+            m_taintedBytes->push_back(false);
+    }
+    for (size_t i = 0; i < from->size(); i++)
+        (*m_taintedBytes)[i] = (*from)[i];
+}
+
+std::vector<bool> *StringImpl::getTaintedBytes() {
+    return m_taintedBytes;
+}
+// xqg end
+
 static inline bool StringImplContentEqual(const StringImpl* a,
                                           const StringImpl* b) {
   wtf_size_t a_length = a->length();
diff --git a/third_party/blink/renderer/platform/wtf/text/string_impl.h b/third_party/blink/renderer/platform/wtf/text/string_impl.h
index da65ab24fe25c..b884cebb56739 100644
--- a/third_party/blink/renderer/platform/wtf/text/string_impl.h
+++ b/third_party/blink/renderer/platform/wtf/text/string_impl.h
@@ -93,7 +93,8 @@ class WTF_EXPORT StringImpl {
   explicit StringImpl(ConstructEmptyStringTag)
       : length_(0),
         hash_and_flags_(kAsciiPropertyCheckDone | kContainsOnlyAscii |
-                        kIsLowerAscii | kIs8Bit | kIsStatic) {
+                        kIsLowerAscii | kIs8Bit | kIsStatic),
+                        m_data(nullptr), m_taintedBytes(nullptr) { // xqg
     // Ensure that the hash is computed so that AtomicStringHash can call
     // existingHash() with impunity. The empty string is special because it
     // is never entered into AtomicString's HashKey, but still needs to
@@ -105,19 +106,22 @@ class WTF_EXPORT StringImpl {
   explicit StringImpl(ConstructEmptyString16BitTag)
       : length_(0),
         hash_and_flags_(kAsciiPropertyCheckDone | kContainsOnlyAscii |
-                        kIsLowerAscii | kIsStatic) {
+                        kIsLowerAscii | kIsStatic),
+                        m_data(nullptr), m_taintedBytes(nullptr){ // xqg
     GetHash();
   }
 
   // FIXME: there has to be a less hacky way to do this.
   enum Force8Bit { kForce8BitConstructor };
   StringImpl(wtf_size_t length, Force8Bit)
-      : length_(length), hash_and_flags_(LengthToAsciiFlags(length) | kIs8Bit) {
+      : length_(length), hash_and_flags_(LengthToAsciiFlags(length) | kIs8Bit),
+        m_data(nullptr), m_taintedBytes(nullptr){ // xqg
     DCHECK(length_);
   }
 
   StringImpl(wtf_size_t length)
-      : length_(length), hash_and_flags_(LengthToAsciiFlags(length)) {
+      : length_(length), hash_and_flags_(LengthToAsciiFlags(length)),
+        m_data(nullptr), m_taintedBytes(nullptr){ // xqg
     DCHECK(length_);
   }
 
@@ -125,7 +129,8 @@ class WTF_EXPORT StringImpl {
   StringImpl(wtf_size_t length, wtf_size_t hash, StaticStringTag)
       : length_(length),
         hash_and_flags_(hash << kHashShift | LengthToAsciiFlags(length) |
-                        kIs8Bit | kIsStatic) {}
+                        kIs8Bit | kIsStatic),
+        m_data(nullptr), m_taintedBytes(nullptr){} // xqg
 
  public:
   REQUIRE_ADOPTION_FOR_REFCOUNTED_TYPE();
@@ -228,6 +233,31 @@ class WTF_EXPORT StringImpl {
 
   bool IsLowerASCII() const;
 
+  // xqg start
+  void setTaint() {hash_and_flags_.fetch_or(kIsTainted, std::memory_order_seq_cst);}
+
+  void unsetTaint() {hash_and_flags_.fetch_and(~kIsTainted, std::memory_order_seq_cst);}
+
+  bool isTainted(){return hash_and_flags_.load(std::memory_order_seq_cst) & kIsTainted;}
+
+  void setTaintedInV8() {hash_and_flags_.fetch_or(kTaintedInV8, std::memory_order_seq_cst);}
+
+  void unsetTaintedInV8() {hash_and_flags_.fetch_and(~kTaintedInV8, std::memory_order_seq_cst);}
+
+
+  bool isTaintedInV8() {return hash_and_flags_.load(std::memory_order_seq_cst) & kTaintedInV8;}
+
+  void setData(void *data) {m_data = data;}
+
+  void *getData() {return m_data;}
+
+  void setTaintedBytes(size_t start, size_t end);
+
+  void copyTaintedBytes(std::vector<bool>* from); // xqg newly add
+
+  std::vector<bool> *getTaintedBytes();
+  // xqg end
+
   // The high bits of 'hash' are always empty, but we prefer to store our
   // flags in the low bits because it makes them slightly more efficient to
   // access.  So, we shift left and right when setting and getting our hash
@@ -519,6 +549,12 @@ class WTF_EXPORT StringImpl {
     // or the correct hash (if it is). It is possible for a thread to compute
     // the hash for a second time if there is a race. This is safe, since
     // storing the same bits again with a bitwise or is idempotent.
+
+    // xqg start
+    kIsTainted = 1 << 6,
+
+    kTaintedInV8 = 1 << 7,
+    // xqg end
   };
 
   // Hash value is 24 bits.
@@ -605,6 +641,11 @@ class WTF_EXPORT StringImpl {
   mutable std::atomic_uint32_t ref_count_{1};
   const unsigned length_;
   mutable std::atomic<uint32_t> hash_and_flags_;
+
+  // xqg start
+  void *m_data;
+  std::vector<bool> *m_taintedBytes;
+  // xqg end
 };
 
 template <>
diff --git a/third_party/blink/renderer/platform/wtf/text/text_codec.h b/third_party/blink/renderer/platform/wtf/text/text_codec.h
index be2c9e64f364d..e183680cbf5c6 100644
--- a/third_party/blink/renderer/platform/wtf/text/text_codec.h
+++ b/third_party/blink/renderer/platform/wtf/text/text_codec.h
@@ -98,26 +98,36 @@ class WTF_EXPORT TextCodec {
                         wtf_size_t length,
                         FlushBehavior,
                         bool stop_on_error,
-                        bool& saw_error) = 0;
+                        bool& saw_error, bool partially_tainted = false,
+        std::vector<bool>* input_tainted_bytes = nullptr,
+        std::vector<bool>* output_tainted_bytes = nullptr) = 0;
   virtual std::string Encode(const UChar*,
                              wtf_size_t length,
-                             UnencodableHandling) = 0;
+                             UnencodableHandling, bool partially_tainted = false,
+        std::vector<bool>* input_tainted_bytes = nullptr,
+        std::vector<bool>* output_tainted_bytes = nullptr) = 0;
   virtual std::string Encode(const LChar*,
                              wtf_size_t length,
-                             UnencodableHandling) = 0;
+                             UnencodableHandling, bool partially_tainted = false,
+        std::vector<bool>* input_tainted_bytes = nullptr,
+        std::vector<bool>* output_tainted_bytes = nullptr) = 0;
   // EncodeInto is meant only to encode UTF8 bytes into an unsigned char*
   // buffer; therefore this method is only usefully overridden by TextCodecUTF8.
   virtual EncodeIntoResult EncodeInto(const LChar*,
                                       wtf_size_t length,
                                       unsigned char* destination,
-                                      size_t capacity) {
+                                      size_t capacity, bool partially_tainted = false,
+        std::vector<bool>* input_tainted_bytes = nullptr,
+        std::vector<bool>* output_tainted_bytes = nullptr) {
     NOTREACHED();
     return EncodeIntoResult{0, 0};
   }
   virtual EncodeIntoResult EncodeInto(const UChar*,
                                       wtf_size_t length,
                                       unsigned char* destination,
-                                      size_t capacity) {
+                                      size_t capacity, bool partially_tainted = false,
+        std::vector<bool>* input_tainted_bytes = nullptr,
+        std::vector<bool>* output_tainted_bytes = nullptr) {
     NOTREACHED();
     return EncodeIntoResult{0, 0};
   }
diff --git a/third_party/blink/renderer/platform/wtf/text/text_codec_icu.cc b/third_party/blink/renderer/platform/wtf/text/text_codec_icu.cc
index 21fcb2e452966..dbf3f5faede8e 100644
--- a/third_party/blink/renderer/platform/wtf/text/text_codec_icu.cc
+++ b/third_party/blink/renderer/platform/wtf/text/text_codec_icu.cc
@@ -380,7 +380,9 @@ String TextCodecICU::Decode(const char* bytes,
                             wtf_size_t length,
                             FlushBehavior flush,
                             bool stop_on_error,
-                            bool& saw_error) {
+                            bool& saw_error,bool partially_tainted,
+                            std::vector<bool>* input_tainted_bytes,
+                            std::vector<bool>* output_tainted_bytes) {
   // Get a converter for the passed-in encoding.
   if (!converter_icu_) {
     CreateICUConverter();
@@ -742,13 +744,17 @@ std::string TextCodecICU::EncodeCommon(const CharType* characters,
 
 std::string TextCodecICU::Encode(const UChar* characters,
                                  wtf_size_t length,
-                                 UnencodableHandling handling) {
+                                 UnencodableHandling handling, bool partially_tainted,
+                                 std::vector<bool>* input_tainted_bytes,
+                                 std::vector<bool>* output_tainted_bytes) {
   return EncodeCommon(characters, length, handling);
 }
 
 std::string TextCodecICU::Encode(const LChar* characters,
                                  wtf_size_t length,
-                                 UnencodableHandling handling) {
+                                 UnencodableHandling handling, bool partially_tainted,
+                                 std::vector<bool>* input_tainted_bytes,
+                                 std::vector<bool>* output_tainted_bytes) {
   return EncodeCommon(characters, length, handling);
 }
 
diff --git a/third_party/blink/renderer/platform/wtf/text/text_codec_icu.h b/third_party/blink/renderer/platform/wtf/text/text_codec_icu.h
index 660afd4c472e8..3ee0a02ad8ce6 100644
--- a/third_party/blink/renderer/platform/wtf/text/text_codec_icu.h
+++ b/third_party/blink/renderer/platform/wtf/text/text_codec_icu.h
@@ -55,13 +55,19 @@ class TextCodecICU final : public TextCodec {
                 wtf_size_t length,
                 FlushBehavior,
                 bool stop_on_error,
-                bool& saw_error) override;
+                bool& saw_error, bool partially_tainted = false,
+                std::vector<bool>* input_tainted_bytes = nullptr,
+                std::vector<bool>* output_tainted_bytes = nullptr) override;
   std::string Encode(const UChar*,
                      wtf_size_t length,
-                     UnencodableHandling) override;
+                     UnencodableHandling, bool partially_tainted = false,
+                     std::vector<bool>* input_tainted_bytes = nullptr,
+                     std::vector<bool>* output_tainted_bytes = nullptr) override;
   std::string Encode(const LChar*,
                      wtf_size_t length,
-                     UnencodableHandling) override;
+                     UnencodableHandling, bool partially_tainted = false,
+                     std::vector<bool>* input_tainted_bytes = nullptr,
+                     std::vector<bool>* output_tainted_bytes = nullptr) override;
 
   template <typename CharType>
   std::string EncodeCommon(const CharType*,
diff --git a/third_party/blink/renderer/platform/wtf/text/text_codec_latin1.cc b/third_party/blink/renderer/platform/wtf/text/text_codec_latin1.cc
index 341e05fea5a8a..0d7be6ca06d7f 100644
--- a/third_party/blink/renderer/platform/wtf/text/text_codec_latin1.cc
+++ b/third_party/blink/renderer/platform/wtf/text/text_codec_latin1.cc
@@ -109,7 +109,9 @@ String TextCodecLatin1::Decode(const char* bytes,
                                wtf_size_t length,
                                FlushBehavior,
                                bool,
-                               bool&) {
+                               bool&, bool partially_tainted,
+                               std::vector<bool>* input_tainted_bytes,
+                               std::vector<bool>* output_tainted_bytes) {
   LChar* characters;
   if (!length)
     return g_empty_string;
@@ -276,13 +278,17 @@ std::string TextCodecLatin1::EncodeCommon(const CharType* characters,
 
 std::string TextCodecLatin1::Encode(const UChar* characters,
                                     wtf_size_t length,
-                                    UnencodableHandling handling) {
+                                    UnencodableHandling handling, bool partially_tainted,
+                                    std::vector<bool>* input_tainted_bytes,
+                                    std::vector<bool>* output_tainted_bytes) {
   return EncodeCommon(characters, length, handling);
 }
 
 std::string TextCodecLatin1::Encode(const LChar* characters,
                                     wtf_size_t length,
-                                    UnencodableHandling handling) {
+                                    UnencodableHandling handling, bool partially_tainted,
+                                    std::vector<bool>* input_tainted_bytes,
+                                    std::vector<bool>* output_tainted_bytes) {
   return EncodeCommon(characters, length, handling);
 }
 
diff --git a/third_party/blink/renderer/platform/wtf/text/text_codec_latin1.h b/third_party/blink/renderer/platform/wtf/text/text_codec_latin1.h
index 708ebab7b9c20..4fdcab5de321f 100644
--- a/third_party/blink/renderer/platform/wtf/text/text_codec_latin1.h
+++ b/third_party/blink/renderer/platform/wtf/text/text_codec_latin1.h
@@ -40,13 +40,19 @@ class TextCodecLatin1 final : public TextCodec {
                 wtf_size_t length,
                 FlushBehavior,
                 bool stop_on_error,
-                bool& saw_error) override;
+                bool& saw_error, bool partially_tainted = false,
+                std::vector<bool>* input_tainted_bytes = nullptr,
+                std::vector<bool>* output_tainted_bytes = nullptr) override;
   std::string Encode(const UChar*,
                      wtf_size_t length,
-                     UnencodableHandling) override;
+                     UnencodableHandling, bool partially_tainted = false,
+                     std::vector<bool>* input_tainted_bytes = nullptr,
+                     std::vector<bool>* output_tainted_bytes = nullptr) override;
   std::string Encode(const LChar*,
                      wtf_size_t length,
-                     UnencodableHandling) override;
+                     UnencodableHandling, bool partially_tainted = false,
+                     std::vector<bool>* input_tainted_bytes = nullptr,
+                     std::vector<bool>* output_tainted_bytes = nullptr) override;
 
   template <typename CharType>
   std::string EncodeCommon(const CharType*,
diff --git a/third_party/blink/renderer/platform/wtf/text/text_codec_replacement.cc b/third_party/blink/renderer/platform/wtf/text/text_codec_replacement.cc
index 56020874f926a..5556c72556253 100644
--- a/third_party/blink/renderer/platform/wtf/text/text_codec_replacement.cc
+++ b/third_party/blink/renderer/platform/wtf/text/text_codec_replacement.cc
@@ -38,7 +38,9 @@ String TextCodecReplacement::Decode(const char*,
                                     wtf_size_t length,
                                     FlushBehavior,
                                     bool,
-                                    bool& saw_error) {
+                                    bool& saw_error, bool partially_tainted,
+                                    std::vector<bool>* input_tainted_bytes,
+                                    std::vector<bool>* output_tainted_bytes) {
   // https://encoding.spec.whatwg.org/#replacement-decoder
 
   // 1. If byte is end-of-stream, return finished.
diff --git a/third_party/blink/renderer/platform/wtf/text/text_codec_replacement.h b/third_party/blink/renderer/platform/wtf/text/text_codec_replacement.h
index 2a543b359c510..ad3bd530f7137 100644
--- a/third_party/blink/renderer/platform/wtf/text/text_codec_replacement.h
+++ b/third_party/blink/renderer/platform/wtf/text/text_codec_replacement.h
@@ -27,7 +27,9 @@ class TextCodecReplacement final : public TextCodecUTF8 {
                 wtf_size_t length,
                 FlushBehavior,
                 bool stop_on_error,
-                bool& saw_error) override;
+                bool& saw_error, bool partially_tainted = false,
+                std::vector<bool>* input_tainted_bytes = nullptr,
+                std::vector<bool>* output_tainted_bytes = nullptr) override;
 
   bool replacement_error_returned_;
 };
diff --git a/third_party/blink/renderer/platform/wtf/text/text_codec_user_defined.cc b/third_party/blink/renderer/platform/wtf/text/text_codec_user_defined.cc
index c3885a2abe752..c30ac9742dd36 100644
--- a/third_party/blink/renderer/platform/wtf/text/text_codec_user_defined.cc
+++ b/third_party/blink/renderer/platform/wtf/text/text_codec_user_defined.cc
@@ -51,7 +51,9 @@ String TextCodecUserDefined::Decode(const char* bytes,
                                     wtf_size_t length,
                                     FlushBehavior,
                                     bool,
-                                    bool&) {
+                                    bool&, bool partially_tainted,
+                                    std::vector<bool>* input_tainted_bytes,
+                                    std::vector<bool>* output_tainted_bytes) {
   StringBuilder result;
   result.ReserveCapacity(length);
 
@@ -129,13 +131,17 @@ std::string TextCodecUserDefined::EncodeCommon(const CharType* characters,
 
 std::string TextCodecUserDefined::Encode(const UChar* characters,
                                          wtf_size_t length,
-                                         UnencodableHandling handling) {
+                                         UnencodableHandling handling, bool partially_tainted,
+                                         std::vector<bool>* input_tainted_bytes,
+                                         std::vector<bool>* output_tainted_bytes) {
   return EncodeCommon(characters, length, handling);
 }
 
 std::string TextCodecUserDefined::Encode(const LChar* characters,
                                          wtf_size_t length,
-                                         UnencodableHandling handling) {
+                                         UnencodableHandling handling, bool partially_tainted,
+                                         std::vector<bool>* input_tainted_bytes,
+                                         std::vector<bool>* output_tainted_bytes) {
   return EncodeCommon(characters, length, handling);
 }
 
diff --git a/third_party/blink/renderer/platform/wtf/text/text_codec_user_defined.h b/third_party/blink/renderer/platform/wtf/text/text_codec_user_defined.h
index a0167d49ea72f..4ec6ca7faec31 100644
--- a/third_party/blink/renderer/platform/wtf/text/text_codec_user_defined.h
+++ b/third_party/blink/renderer/platform/wtf/text/text_codec_user_defined.h
@@ -40,13 +40,19 @@ class TextCodecUserDefined final : public TextCodec {
                 wtf_size_t length,
                 FlushBehavior,
                 bool stop_on_error,
-                bool& saw_error) override;
+                bool& saw_error,bool partially_tainted = false,
+                std::vector<bool>* input_tainted_bytes = nullptr,
+                std::vector<bool>* output_tainted_bytes = nullptr) override;
   std::string Encode(const UChar*,
                      wtf_size_t length,
-                     UnencodableHandling) override;
+                     UnencodableHandling, bool partially_tainted = false,
+                     std::vector<bool>* input_tainted_bytes = nullptr,
+                     std::vector<bool>* output_tainted_bytes = nullptr) override;
   std::string Encode(const LChar*,
                      wtf_size_t length,
-                     UnencodableHandling) override;
+                     UnencodableHandling, bool partially_tainted = false,
+                     std::vector<bool>* input_tainted_bytes = nullptr,
+                     std::vector<bool>* output_tainted_bytes = nullptr) override;
 
   template <typename CharType>
   std::string EncodeCommon(const CharType*,
diff --git a/third_party/blink/renderer/platform/wtf/text/text_codec_utf16.cc b/third_party/blink/renderer/platform/wtf/text/text_codec_utf16.cc
index 46a68260cba25..3fe215f5414d0 100644
--- a/third_party/blink/renderer/platform/wtf/text/text_codec_utf16.cc
+++ b/third_party/blink/renderer/platform/wtf/text/text_codec_utf16.cc
@@ -69,7 +69,9 @@ String TextCodecUTF16::Decode(const char* bytes,
                               wtf_size_t length,
                               FlushBehavior flush,
                               bool,
-                              bool& saw_error) {
+                              bool& saw_error, bool partially_tainted,
+                              std::vector<bool>* input_tainted_bytes,
+                              std::vector<bool>* output_tainted_bytes) {
   // For compatibility reasons, ignore flush from fetch EOF.
   const bool really_flush = flush != FlushBehavior::kDoNotFlush &&
                             flush != FlushBehavior::kFetchEOF;
@@ -153,7 +155,9 @@ String TextCodecUTF16::Decode(const char* bytes,
 
 std::string TextCodecUTF16::Encode(const UChar* characters,
                                    wtf_size_t length,
-                                   UnencodableHandling) {
+                                   UnencodableHandling, bool partially_tainted,
+                                   std::vector<bool>* input_tainted_bytes,
+                                   std::vector<bool>* output_tainted_bytes) {
   // We need to be sure we can double the length without overflowing.
   // Since the passed-in length is the length of an actual existing
   // character buffer, each character is two bytes, and we know
@@ -183,7 +187,9 @@ std::string TextCodecUTF16::Encode(const UChar* characters,
 
 std::string TextCodecUTF16::Encode(const LChar* characters,
                                    wtf_size_t length,
-                                   UnencodableHandling) {
+                                   UnencodableHandling, bool partially_tainted,
+                                   std::vector<bool>* input_tainted_bytes,
+                                   std::vector<bool>* output_tainted_bytes) {
   // In the LChar case, we do actually need to perform this check in release. :)
   CHECK_LE(length, std::numeric_limits<wtf_size_t>::max() / 2);
 
diff --git a/third_party/blink/renderer/platform/wtf/text/text_codec_utf16.h b/third_party/blink/renderer/platform/wtf/text/text_codec_utf16.h
index 4fa2cdfadfdd9..346607693007d 100644
--- a/third_party/blink/renderer/platform/wtf/text/text_codec_utf16.h
+++ b/third_party/blink/renderer/platform/wtf/text/text_codec_utf16.h
@@ -41,13 +41,19 @@ class TextCodecUTF16 final : public TextCodec {
                 wtf_size_t length,
                 FlushBehavior,
                 bool stop_on_error,
-                bool& saw_error) override;
+                bool& saw_error, bool partially_tainted = false,
+                std::vector<bool>* input_tainted_bytes = nullptr,
+                std::vector<bool>* output_tainted_bytes = nullptr) override;
   std::string Encode(const UChar*,
                      wtf_size_t length,
-                     UnencodableHandling) override;
+                     UnencodableHandling, bool partially_tainted = false,
+                     std::vector<bool>* input_tainted_bytes = nullptr,
+                     std::vector<bool>* output_tainted_bytes = nullptr) override;
   std::string Encode(const LChar*,
                      wtf_size_t length,
-                     UnencodableHandling) override;
+                     UnencodableHandling, bool partially_tainted = false,
+                     std::vector<bool>* input_tainted_bytes = nullptr,
+                     std::vector<bool>* output_tainted_bytes = nullptr) override;
 
  private:
   bool little_endian_;
diff --git a/third_party/blink/renderer/platform/wtf/text/text_codec_utf8.cc b/third_party/blink/renderer/platform/wtf/text/text_codec_utf8.cc
index 52cab4e4491b6..75022a3eb2b0b 100644
--- a/third_party/blink/renderer/platform/wtf/text/text_codec_utf8.cc
+++ b/third_party/blink/renderer/platform/wtf/text/text_codec_utf8.cc
@@ -306,7 +306,9 @@ String TextCodecUTF8::Decode(const char* bytes,
                              wtf_size_t length,
                              FlushBehavior flush,
                              bool stop_on_error,
-                             bool& saw_error) {
+                             bool& saw_error, bool partially_tainted,
+                             std::vector<bool>* input_tainted_bytes,
+                             std::vector<bool>* output_tainted_bytes) {
   const bool do_flush = flush != FlushBehavior::kDoNotFlush;
   // Each input byte might turn into a character.
   // That includes all bytes in the partial-sequence buffer because
@@ -484,7 +486,9 @@ upConvertTo16Bit:
 
 template <typename CharType>
 std::string TextCodecUTF8::EncodeCommon(const CharType* characters,
-                                        wtf_size_t length) {
+                                        wtf_size_t length, bool partially_tainted,
+                                        std::vector<bool>* input_tainted_bytes,
+                                        std::vector<bool>* output_tainted_bytes) {
   // The maximum number of UTF-8 bytes needed per UTF-16 code unit is 3.
   // BMP characters take only one UTF-16 code unit and can take up to 3 bytes
   // (3x).
@@ -495,15 +499,37 @@ std::string TextCodecUTF8::EncodeCommon(const CharType* characters,
 
   wtf_size_t i = 0;
   wtf_size_t bytes_written = 0;
-  while (i < length) {
-    UChar32 character;
-    U16_NEXT(characters, i, length, character);
-    // U16_NEXT will simply emit a surrogate code point if an unmatched
-    // surrogate is encountered; we must convert it to a
-    // U+FFFD (REPLACEMENT CHARACTER) here.
-    if (0xD800 <= character && character <= 0xDFFF)
-      character = kReplacementCharacter;
-    U8_APPEND_UNSAFE(bytes.data(), bytes_written, character);
+  // xqg start
+  if (partially_tainted) {
+      while (i < length) {
+          UChar32 character;
+          bool byte_sta = (*input_tainted_bytes)[i]; // xqg: before NEXT
+          U16_NEXT(characters, i, length, character);
+          // U16_NEXT will simply emit a surrogate code point if an unmatched
+          // surrogate is encountered; we must convert it to a
+          // U+FFFD (REPLACEMENT CHARACTER) here.
+          if (0xD800 <= character && character <= 0xDFFF)
+              character = kReplacementCharacter;
+          wtf_size_t before_index = bytes_written; // xqg
+          U8_APPEND_UNSAFE(bytes.data(), bytes_written, character);
+          // xqg start
+          for(wtf_size_t j = before_index; j < bytes_written; j++){
+              output_tainted_bytes->push_back(byte_sta);
+          }
+          // xqg end
+      }
+      // xqg end
+  } else {
+      while (i < length) {
+          UChar32 character;
+          U16_NEXT(characters, i, length, character);
+          // U16_NEXT will simply emit a surrogate code point if an unmatched
+          // surrogate is encountered; we must convert it to a
+          // U+FFFD (REPLACEMENT CHARACTER) here.
+          if (0xD800 <= character && character <= 0xDFFF)
+              character = kReplacementCharacter;
+          U8_APPEND_UNSAFE(bytes.data(), bytes_written, character);
+      }
   }
 
   return std::string(reinterpret_cast<char*>(bytes.data()), bytes_written);
@@ -514,23 +540,49 @@ TextCodec::EncodeIntoResult TextCodecUTF8::EncodeIntoCommon(
     const CharType* characters,
     wtf_size_t length,
     unsigned char* destination,
-    size_t capacity) {
+    size_t capacity, bool partially_tainted,
+    std::vector<bool>* input_tainted_bytes,
+    std::vector<bool>* output_tainted_bytes) {
   TextCodec::EncodeIntoResult encode_into_result{0, 0};
 
   wtf_size_t i = 0;
   wtf_size_t previous_code_unit_index = 0;
   bool is_error = false;
-  while (i < length && encode_into_result.bytes_written < capacity &&
-         !is_error) {
-    UChar32 character;
-    previous_code_unit_index = i;
-    U16_NEXT(characters, i, length, character);
-    // U16_NEXT will simply emit a surrogate code point if an unmatched
-    // surrogate is encountered. See comment in EncodeCommon() for more info.
-    if (0xD800 <= character && character <= 0xDFFF)
-      character = kReplacementCharacter;
-    U8_APPEND(destination, encode_into_result.bytes_written, capacity,
-              character, is_error);
+  // xqg start
+  if (partially_tainted) {
+      while (i < length && encode_into_result.bytes_written < capacity &&
+             !is_error) {
+          UChar32 character;
+          previous_code_unit_index = i;
+          bool byte_sta = (*input_tainted_bytes)[i]; // xqg
+          U16_NEXT(characters, i, length, character);
+          // U16_NEXT will simply emit a surrogate code point if an unmatched
+          // surrogate is encountered. See comment in EncodeCommon() for more info.
+          if (0xD800 <= character && character <= 0xDFFF)
+              character = kReplacementCharacter;
+          wtf_size_t before_index = encode_into_result.bytes_written; // xqg
+          U8_APPEND(destination, encode_into_result.bytes_written, capacity,
+                    character, is_error);
+          // xqg start
+          for (wtf_size_t j = before_index; j < encode_into_result.bytes_written; j++) {
+                  output_tainted_bytes->push_back(byte_sta);
+          }
+          // xqg end
+      }
+      // xqg end
+  } else {
+      while (i < length && encode_into_result.bytes_written < capacity &&
+             !is_error) {
+          UChar32 character;
+          previous_code_unit_index = i;
+          U16_NEXT(characters, i, length, character);
+          // U16_NEXT will simply emit a surrogate code point if an unmatched
+          // surrogate is encountered. See comment in EncodeCommon() for more info.
+          if (0xD800 <= character && character <= 0xDFFF)
+              character = kReplacementCharacter;
+          U8_APPEND(destination, encode_into_result.bytes_written, capacity,
+                    character, is_error);
+      }
   }
 
   // |is_error| is only true when U8_APPEND cannot append the UTF8 bytes that
@@ -545,32 +597,42 @@ TextCodec::EncodeIntoResult TextCodecUTF8::EncodeIntoCommon(
   return encode_into_result;
 }
 
+// xqg start
 std::string TextCodecUTF8::Encode(const UChar* characters,
                                   wtf_size_t length,
-                                  UnencodableHandling) {
-  return EncodeCommon(characters, length);
+                                  UnencodableHandling, bool partially_tainted,
+                                  std::vector<bool>* input_tainted_bytes,
+                                  std::vector<bool>* output_tainted_bytes) {
+  return EncodeCommon(characters, length, partially_tainted, input_tainted_bytes, output_tainted_bytes);
 }
 
 std::string TextCodecUTF8::Encode(const LChar* characters,
                                   wtf_size_t length,
-                                  UnencodableHandling) {
-  return EncodeCommon(characters, length);
+                                  UnencodableHandling, bool partially_tainted,
+                                  std::vector<bool>* input_tainted_bytes,
+                                  std::vector<bool>* output_tainted_bytes) {
+  return EncodeCommon(characters, length, partially_tainted, input_tainted_bytes, output_tainted_bytes);
 }
+// xqg end
 
 TextCodec::EncodeIntoResult TextCodecUTF8::EncodeInto(
     const UChar* characters,
     wtf_size_t length,
     unsigned char* destination,
-    size_t capacity) {
-  return EncodeIntoCommon(characters, length, destination, capacity);
+    size_t capacity, bool partially_tainted,
+    std::vector<bool>* input_tainted_bytes,
+    std::vector<bool>* output_tainted_bytes) {
+  return EncodeIntoCommon(characters, length, destination, capacity, partially_tainted, input_tainted_bytes, output_tainted_bytes);
 }
 
 TextCodec::EncodeIntoResult TextCodecUTF8::EncodeInto(
     const LChar* characters,
     wtf_size_t length,
     unsigned char* destination,
-    size_t capacity) {
-  return EncodeIntoCommon(characters, length, destination, capacity);
+    size_t capacity, bool partially_tainted,
+    std::vector<bool>* input_tainted_bytes,
+    std::vector<bool>* output_tainted_bytes) {
+  return EncodeIntoCommon(characters, length, destination, capacity, partially_tainted, input_tainted_bytes, output_tainted_bytes);
 }
 
 }  // namespace WTF
diff --git a/third_party/blink/renderer/platform/wtf/text/text_codec_utf8.h b/third_party/blink/renderer/platform/wtf/text/text_codec_utf8.h
index 8e8ac62d056ce..489c285d72a45 100644
--- a/third_party/blink/renderer/platform/wtf/text/text_codec_utf8.h
+++ b/third_party/blink/renderer/platform/wtf/text/text_codec_utf8.h
@@ -48,13 +48,19 @@ class TextCodecUTF8 : public TextCodec {
                 wtf_size_t length,
                 FlushBehavior,
                 bool stop_on_error,
-                bool& saw_error) override;
+                bool& saw_error, bool partially_tainted = false,
+                std::vector<bool>* input_tainted_bytes = nullptr,
+                std::vector<bool>* output_tainted_bytes = nullptr) override;
   std::string Encode(const UChar*,
                      wtf_size_t length,
-                     UnencodableHandling) override;
+                     UnencodableHandling, bool partially_tainted = false,
+                     std::vector<bool>* input_tainted_bytes = nullptr,
+                     std::vector<bool>* output_tainted_bytes = nullptr) override;
   std::string Encode(const LChar*,
                      wtf_size_t length,
-                     UnencodableHandling) override;
+                     UnencodableHandling, bool partially_tainted = false,
+                     std::vector<bool>* input_tainted_bytes = nullptr,
+                     std::vector<bool>* output_tainted_bytes = nullptr) override;
 
   // See comment above TextCodec::EncodeInto for more information.
   // This implementation writes as many code points to |destination| as will
@@ -64,19 +70,27 @@ class TextCodecUTF8 : public TextCodec {
   EncodeIntoResult EncodeInto(const UChar*,
                               wtf_size_t length,
                               unsigned char* destination,
-                              size_t capacity) override;
+                              size_t capacity, bool partially_tainted = false,
+                              std::vector<bool>* input_tainted_bytes = nullptr,
+                              std::vector<bool>* output_tainted_bytes = nullptr) override;
   EncodeIntoResult EncodeInto(const LChar*,
                               wtf_size_t length,
                               unsigned char* destination,
-                              size_t capacity) override;
+                              size_t capacity, bool partially_tainted = false,
+                              std::vector<bool>* input_tainted_bytes = nullptr,
+                              std::vector<bool>* output_tainted_bytes = nullptr) override;
 
   template <typename CharType>
-  std::string EncodeCommon(const CharType* characters, wtf_size_t length);
+  std::string EncodeCommon(const CharType* characters, wtf_size_t length, bool partially_tainted = false,
+                           std::vector<bool>* input_tainted_bytes = nullptr,
+                           std::vector<bool>* output_tainted_bytes = nullptr);
   template <typename CharType>
   EncodeIntoResult EncodeIntoCommon(const CharType* characters,
                                     wtf_size_t length,
                                     unsigned char* destination,
-                                    size_t capacity);
+                                    size_t capacity, bool partially_tainted = false,
+                                    std::vector<bool>* input_tainted_bytes = nullptr,
+                                    std::vector<bool>* output_tainted_bytes = nullptr);
 
   template <typename CharType>
   bool HandlePartialSequence(CharType*& destination,
